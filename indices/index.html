<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simon Dobson</title>
<style>
	@font-face {
	    font-family: "libretto-icons";
	    src:url(../assets/fonts/libretto-icons.eot);
	    src:url(../assets/fonts/libretto-icons.eot#iefix) format("embedded-opentype"),
	    url(../assets/fonts/libretto-icons.woff) format("woff"),
	    url(../assets/fonts/libretto-icons.ttf) format("truetype"),
	    url(../assets/fonts/libretto-icons.svg#libretto-icons) format("svg");
	    font-weight: normal;
	    font-style: normal;
	}
    </style>
<link rel="icon" href="../images/favicon.png" sizes="16x16">
<link rel="alternate" type="application/rss+xml" href="../rss.xml">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono|Libre+Baskerville|Montserrat|Playfair+Display|Tangerine">
<link rel="stylesheet" href="../assets/css/libretto_styles.css">
<link rel="stylesheet" href="../assets/css/baguetteBox.min.css">
<link rel="stylesheet" href="../assets/css/code.css">
<link rel="stylesheet" href="../assets/css/nikola_rst.css">
<link rel="stylesheet" href="../assets/css/nikola_ipython.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
</head>
<body>
    <!-- Navigation bar -->
    <header class="nav-bar"><div class="site-branding">
	    <h1 class="site-title">
		<a href="https://simondobson.org/" title="Simon Dobson" rel="home">Simon&nbsp;Dobson</a>
	    </h1>
	</div>
	<nav class="site-navigation" role="navigation"><div class="menu-toggle">
		<span class="mobile-site-title">Simon Dobson</span>
	    </div>
	    <ul class="menu">
<li><a href="../index.html">Home</a></li>
		    <li><a href="../personal/">About&nbsp;me</a></li>
		    <li><a href="../research/">Research</a></li>
		    <li><a href="../development/projects/">Software</a></li>
		    <li><a href="../writing/">Writing</a></li>
		    <li><a href="../personal/contact/">Contact</a></li>
		<li>
<a href="../rss.xml"><i class="fa fa-rss"></i></a>
	    </li>
</ul></nav></header><div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2024/07/23/the-art-of-the-metaobject-protocol/" rel="bookmark">Tuesday 23 July, 2024</a>
			</span>
		    </div>
		    <h1><a href="../2024/07/23/the-art-of-the-metaobject-protocol/">The art of the metaobject&nbsp;protocol</a></h1>
		</div>
		<div class="entry-content">
			<div id="outline-container-org7c8dd92" class="outline-2">
<h2 id="org7c8dd92">The art of the metaobject&nbsp;protocol</h2>
<div class="outline-text-2" id="text-org7c8dd92">
<p>
Gregor Kiczales, Jim des Rivières, and Daniel Bobrow.  <i>The Art of the
Metaobject Protocol</i>. <span class="caps">MIT</span> Press.&nbsp;1991.
</p>


<p>
What <i>is</i> a meta-object protocol? – or indeed a meta-object? This
book is perhaps the clearest exposition of these&nbsp;ideas.
</p>

<p>
In most modern object-oriented languages an object is an instance
of a class. In keeping with using objects throughout, classes are
often also objects (or can be thought of as such), but are more
informatively thought of as <b>meta-objects</b> that to facilitate the
construction of &#8220;real&#8221; objects. The methods on classes can also be
thought of as meta-objects defining the code executed by the
objects when&nbsp;invoked.
</p>

<p>
The defining feature of <span class="caps">CLOS</span> is that these meta-objects are all
just Lisp objects, but objects that exist &#8220;off-stage&#8221; (to use this
book&#8217;s very intuitive metaphor) and largely invisible to a basic
user. But they&#8217;re as available to a power user as any other
objects: the &#8220;meta&#8221;-ness is a matter of design, not of
implementation. The interactions between objects and meta-objects,
for example which methods are called when invoked on a particular
object, are defined by the meta-object protocol (<span class="caps">MOP</span>), which is
itself defined in terms of methods on the meta-objects that shadow
the objects&nbsp;themselves.
</p>

<p>
(Meta-object <i>protocol</i> uses a term common in a lot of the earlier
object-oriented literature to mean a collection of functions:
meta-object <i><span class="caps">API</span></i> would be a more modern rendering, although the
protocol includes the sequencing of <span class="caps">API</span> calls and their&nbsp;relationships.)
</p>

<p>
The goal of <span class="caps">MOP</span> programming is to let the programmer extend the
programming language towards to application domain, by automating
a lot of boilerplate code and providing the structures needed to
re-structure or analyse the code the programmer actually needs to
write. In this sense it&#8217;s a continuation of the idea of macros as
powerful and potentially very domain-specific language and
compiler extensions. It&#8217;s also a continuation of reifying
underlying language mechanisms in the language itself where they
can be re-specified and&nbsp;re-mixed.
</p>

<p>
The first part of the book explains MOPs by defining a slightly
simplified version of <span class="caps">CLOS</span> (&#8220;Closette&#8221;). It assumes the reader
knows some <span class="caps">CLOS</span>, for example from <a href="/2024/07/23/object-oriented-programming-on-common-lisp-a-programmer1s-guide-to-clos/">Object-oriented
programming on Common Lisp: A programmer&#8217;s guide to <span class="caps">CLOS</span></a> (or
there&#8217;s a stand-alone introduction in Appendix A), but it <i>only</i>
assumes the knowledge level of a relative newcomer – and the
features then defined in Closette are just those parts of <span class="caps">CLOS</span>
that such a user would actually know and be comfortable with,
which is a brilliant piece of pedagogy that simplifies without
trivialising. It&#8217;s really noticeable that Closette doesn&#8217;t need
any extensions to Common Lisp: it&#8217;s defined directly in the
language itself, which shows how powerful the underlying language
is. (Full <span class="caps">CLOS</span> requires a bit of language support too, at least
for&nbsp;efficiency.)
</p>

<p>
Next come several examples of <span class="caps">MOP</span> usage, for example to re-define
how classes store their slots, or how to add attributes to slots
that can store metadata about their use or could be used to
provide higher-level operations. There&#8217;s also a long discussion
about protocol design and how this has a massive impact on how
easy a system is to use for the&nbsp;programmer.
</p>

<p>
The second part is a manual for the <span class="caps">CLOS</span> <span class="caps">MOP</span>, which is thorough
and useful, but perhaps less exciting than the first part. The
Common Lisp package <a href="https://github.com/pcostanza/closer-mop">closer-mop</a> provides this <span class="caps">API</span> as a
portable compatibility layer for use in real&nbsp;programs.
</p>

<p>
There&#8217;s also a discussion of practicalities like where awkward
circularities occur and how to break them, which is actually a
great example how to do good protocol/<span class="caps">API</span> design. In an example of
<a href="/2024/07/23/the-roots-of-lisp/">Paul Graham&#8217;s dictum</a> that modern languages evolve by mixing Lisp
concepts into a different base, <span class="caps">MOP</span> ideas appear in lots of other
languages, either for real (Smalltalk, at to a lesser extent
<a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/">Python</a>) or just for introspection (Java). Even someone not
planning on writing Lisp would benefit from reading this book just
to see the ideas in their full&nbsp;generality.
</p>
</div>
</div>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2024/07/23/object-oriented-programming-on-common-lisp-a-programmer1s-guide-to-clos/" rel="bookmark">Tuesday 23 July, 2024</a>
			</span>
		    </div>
		    <h1><a href="../2024/07/23/object-oriented-programming-on-common-lisp-a-programmer1s-guide-to-clos/">Object-oriented programming on Common Lisp: A programmer&#8217;s guide to&nbsp;<span class="caps">CLOS</span></a></h1>
		</div>
		<div class="entry-content">
			<div id="outline-container-org1c558c9" class="outline-2">
<h2 id="org1c558c9">Object-oriented programming on Common Lisp: A programmer&#8217;s guide to&nbsp;<span class="caps">CLOS</span></h2>
<div class="outline-text-2" id="text-org1c558c9">
<p class="floater">
<img src="../attachments/41/584da1-ef33-41dd-8091-43c3999f6451/clos.jpg" alt="nil"></p>

<p>
Sonja Keene.  <i>Object-Oriented Programming in Common Lisp: A
Programmer’s Guide to <span class="caps">CLOS</span></i>. Addison-Wesley. <span class="caps">ISBN</span> 0-201-17589-4.&nbsp;1989.
</p>

<p>
The definitive practical guide to using the Common Lisp Object
System (<span class="caps">CLOS</span>). It&#8217;s written from a similar perspective to other
object-oriented tutorials, which makes it very accessible for
those who&#8217;ve had experience with something like Java or Python.
However, <span class="caps">CLOS</span> <i>isn&#8217;t</i> just objects in Lisp, and <i>isn&#8217;t</i> in any sense
just an object-oriented extension. It can take some time to change
mindset enough to use it properly, and this book is a great guide
to the core&nbsp;differences.
</p>

<p>
Firstly, it follows a completely different model of how to
associate functions with data. Instead <span class="caps">CLOS</span> uses &#8220;generic&#8221;
functions, where the exact code called is dispatched dynamically
based on the types of any or all parameters: so it&#8217;s perfectly
possible to have several definitions of the <i>same</i> generic function
operating on objects of the <i>same</i> class, but taking arguments of
<i>different</i> types. This <i>multiple dispatch</i> is a lot more&nbsp;flexible.
</p>

<p>
The second point actually follows from this. <span class="caps">CLOS</span>&#8217; generic
functions can be defined to <i>any</i> Lisp types: in fact they&#8217;re not
statically associated with classes at all, and can operate on <i>any</i>
types (classes or not) across the type hierarchy. This makes it
closer to Haskell&#8217;s type classes than to Smalltalk&#8217;s (or Java&#8217;s)
virtual methods, which are strongly bound to&nbsp;classes.
</p>

<p>
Thirdly, <span class="caps">CLOS</span> methods can be combined in a range of interesting
ways, not simply by overriding previous definitions – and indeed
you can define your own if you need to. And like Smalltalk
(but unlike Java) <span class="caps">CLOS</span> classes have &#8220;metaclasses&#8221; that can
re-define their basic functions. <a href="/2024/07/23/the-art-of-the-metaobject-protocol">The art of the metaobject protocol</a>
is a better source for this level of&nbsp;detail.
</p>

<p>
The examples in the book delve into these features by means of
sensibly-sized challenges that can be used to illustrate both
basic design and implementation. and more advanced ideas like
re-defining classes on the&nbsp;fly.
</p>
</div>
</div>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2024/07/23/the-roots-of-lisp/" rel="bookmark">Tuesday 23 July, 2024</a>
			</span>
		    </div>
		    <h1><a href="../2024/07/23/the-roots-of-lisp/">The roots of&nbsp;Lisp</a></h1>
		</div>
		<div class="entry-content">
			<div id="outline-container-org0318c4d" class="outline-2">
<h2 id="org0318c4d">The roots of&nbsp;Lisp</h2>
<div class="outline-text-2" id="text-org0318c4d">
<p>
<a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>
</p>

<p>
(Only has an PostScript version, but a <span class="caps">PDF</span> is available
<a href="https://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf">here</a>.)
</p>

<p>
Re-visits McCarthy&#8217;s discoveries (or inventions, depending on
your point of view), translating the <a href="/2024/03/07/recursive-functions-of-symbolic-expressions-and-their-computation-by-machine-part-i/">earliest work</a> into modern
Lisp&nbsp;notation.
</p>

<blockquote>
<p>
It&#8217;s worth understanding what McCarthy discovered, not just as a
landmark in the history of computers, but as a model for what
programming is tending to become in our own time. It seems to me that
there have been two really clean, consistent models of programming so
far: the C model and the Lisp model. These two seem points of high
ground, with swampy lowlands between them. As computers have grown
more powerful, the new languages being developed have been moving
steadily toward the Lisp model. A popular recipe for new programming
languages in the past 20 years has been to take the C model of
computing and add to it, piecemeal, parts taken from the Lisp model,
like runtime typing and garbage&nbsp;collection.
</p>
</blockquote>

<p>
Does a great job of making the central insights accessible,
including re-phrasing the meta-circular Lisp interpreter so as to
be executable in modern Common&nbsp;Lisp.
</p>
</div>
</div>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2024/07/17/til-the-most-powerful-one-line-program-in-the-world/" rel="bookmark">Wednesday 17 July, 2024</a>
			</span>
		    </div>
		    <h1><a href="../2024/07/17/til-the-most-powerful-one-line-program-in-the-world/"><span class="caps">TIL</span>: The most powerful one-line program in the&nbsp;world</a></h1>
		</div>
		<div class="entry-content">
			<div id="outline-container-orge9df00b" class="outline-2">
<h2 id="orge9df00b"><span class="caps">TIL</span>: The most powerful one-line program in the&nbsp;world</h2>
<div class="outline-text-2" id="text-orge9df00b">
<p>
Well, the most powerful I&#8217;ve found so far,&nbsp;anyway.
</p>

<p>
Given my current obsession with <a href="/categories/lisp/">Lisp</a> you might reasonably expect it
to be in that language. But it isn&#8217;t: it&#8217;s in <a href="https://en.wikipedia.org/wiki/APL_(programming_language)"><span class="caps">APL</span></a>, and it performs
one complete generation of <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway&#8217; Game of Life</a> in one line of&nbsp;code:
</p>

<div class="highlight"><pre><span></span>  Life←{↑↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}
</pre></div>

<p>
…and does so inexplicably to anyone who doesn&#8217;t know <span class="caps">APL</span>,
obviously, but the <a href="https://aplwiki.com/wiki/John_Scholes%27_Conway%27s_Game_of_Life">basic algorithm</a> is&nbsp;simple:
</p>

<ol class="org-ol">
<li>Take an array with 1 in each occupied cell and 0&nbsp;elsewhere</li>
<li>Build four new arrays by exchanging each element with its
neighbour up, down, left, and&nbsp;right</li>
<li>Sum these arrays, which places the number of neighbours into each&nbsp;cell</li>
<li>Cut-off these values to be 1 if the cell has a value of 3 or 4,
and 0&nbsp;otherwise</li>
<li>Re-format the arrays back into the starting&nbsp;configuration</li>
</ol>
<p>
I checked it out using <a href="https://www.gnu.org/software/apl/"><span class="caps">GNU</span> <span class="caps">APL</span></a> and it works&nbsp;fine.
</p>

<p>
I discovered this gem by accident, actually implemented <a href="https://github.com/chmykh/apl-life">in <span class="caps">APL</span> in
Forth</a> where someone has developed <span class="caps">APL</span> as an embedded <span class="caps">DSL</span> within
<a href="https://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a> (another language with which I have history). After a bit of
digging I found a similar <span class="caps">APL</span> in Lisp, <a href="https://github.com/phantomics/april">April</a>, which clearly needs&nbsp;exploring.
</p>

<p>
In many ways <span class="caps">APL</span> and Lisp are parallel tracks within programming
language evolution, taking a single data structure (lists or arrays)
and providing powerful ways to manipulate them. Lisp of course has
been extended with other data structures, including arrays, which
makes the fusion of array- and list-based programming rather&nbsp;attractive.
</p>

<p>
I can&#8217;t help asking myself what would have happened if <span class="caps">APL</span> hadn&#8217;t
fallen by the wayside. (I think this was inevitable, incidentally,
once the syntax became fixed: any language that requires its own
character set was always going to struggle.) We now have huge
applications for array processing, from graphics to machine
learning, and GPUs are from one perspective just <span class="caps">APL</span> accelerator
co-processors. The ideas are still massively&nbsp;relevant.
</p>
</div>
</div>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../goodreads/a-new-kind-of-science/" rel="bookmark">Sunday 7 July, 2024</a>
			</span>
		    </div>
		    <h1><a href="../goodreads/a-new-kind-of-science/">A New Kind of&nbsp;Science</a></h1>
		</div>
		<div class="entry-content">
			<div>
    <div>
      <img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1386925097l/238558._SX98_.jpg" style="float: left; margin-right: 10px"><h2>
	Stephen Wolfram&nbsp;(1997)
      </h2>
    </div>
    <p>
      I have very mixed feelings about this book. On the one hand it&#8217;s a triumph of computational experimental technique, taking an idea that was well-known (cellular automata) and subjecting it to rigorous exploration. This uncovers a lot of new science, not least showing that complex systems can arise from even the simplest set of rules, but also that this complexity falls into classes that show graded complexity depending purely on the fine structure of the initial conditions. That&#8217;s a massively important discovery.<br><br>On the other hand&#8230;. It&#8217;s hard to describe this as a &#8220;new kind&#8221; of science. &#8220;New science,&#8221; yes, but not indicative of a new paradigm or <i>way</i> of doing science, other than by emphasising the structured use of simulation. Wolfram completely over-sells what he&#8217;s achieved, making claims he can&#8217;t substantiate to aggrandise his own contributions. And that&#8217;s a shame, not least because it&#8217;s so <i>unnecessary</i>: Wolfram has made some important discoveries, both here and to several other branches of physics and computer science, as well as popularising computational methods and tools. It&#8217;s tragic that he doesn&#8217;t seem to be able to appreciate himself as being sufficient.<br><br>The book is also quite terribly written, being almost half-composed of footnotes, meaning a reader is constantly skipping forwards and back: difficult in print, and I suspect impossible in a digital edition unless it&#8217;s been very carefully hyperlinked. And the footnotes are often important! – indeed, they often provide evidence to back-up a claim in the main text that&#8217;s entirely unsupportable from what&#8217;s been presented. So it can be seen as both excessively long and insufficiently detailed, which is quite an&nbsp;achievement.
      </p>
<p>
	3/5.
	  Finished Sunday 7 July,&nbsp;2024.
	</p>
<p>
	  (Originally published on <a href="https://www.goodreads.com/review/show/4934435584?utm_medium=api&amp;utm_source=rss">Goodreads</a>.)
  </p>
</div>
		</div>
	    </article>
</div>
    <!-- Lower Navigation links -->
    <nav class="site-content navigation-post" role="navigation"><div class="previous">
		<a href="index-148.html" rel="prev">
		    <span class="meta-nav">Older Entries</span>		</a>
	    </div>
    </nav><!-- Page Footer --><section class="footer-sidebar clear" role="complementary"><div class="widget-block">
	    <aside class="widget"><h2 class="widget-title">Simon&nbsp;Dobson</h2>
		<div class="widget-text">Aut tace aut loquere meliora silentio</div>
	    </aside>
</div>
    </section><!-- Extra JavaScript --><!-- Site Attributions --><footer class="site-footer" role="contentinfo"><div class="site-info">
	    <p></p>
	    <p>
	      Built with free and open-source software.
	      Powered by <a href="https://getnikola.com/">Nikola</a> using a theme based on
	      <a href="https://themes.getnikola.com/v7/libretto/">Libretto</a>.
	    </p>
	    <p>
	      All content Copyright © 2010–2024 Simon Dobson and licensed under
	      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="caps">CC</span>-<span class="caps">BY</span>-<span class="caps">NC</span>-<span class="caps">SA</span>-4.0</a>
	      unless otherwise&nbsp;noted.
	    </p>
	</div>
	<div class="social">
	    <ul class="menu"></ul>
</div>
    </footer>
</body>
</html>