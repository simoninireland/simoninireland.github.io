<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simon Dobson (old posts, page 30)</title>
<style>
	@font-face {
	    font-family: "libretto-icons";
	    src:url(../assets/fonts/libretto-icons.eot);
	    src:url(../assets/fonts/libretto-icons.eot#iefix) format("embedded-opentype"),
	    url(../assets/fonts/libretto-icons.woff) format("woff"),
	    url(../assets/fonts/libretto-icons.ttf) format("truetype"),
	    url(../assets/fonts/libretto-icons.svg#libretto-icons) format("svg");
	    font-weight: normal;
	    font-style: normal;
	}
    </style>
<link rel="icon" href="../images/favicon.png" sizes="16x16">
<link rel="alternate" type="application/rss+xml" href="../rss.xml">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono|Libre+Baskerville|Montserrat|Playfair+Display|Tangerine">
<link rel="stylesheet" href="../assets/css/libretto_styles.css">
<link rel="stylesheet" href="../assets/css/baguetteBox.min.css">
<link rel="stylesheet" href="../assets/css/code.css">
<link rel="stylesheet" href="../assets/css/nikola_rst.css">
<link rel="stylesheet" href="../assets/css/nikola_ipython.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
</head>
<body>
    <!-- Navigation bar -->
    <header class="nav-bar"><div class="site-branding">
	    <h1 class="site-title">
		<a href="https://simondobson.org/" title="Simon Dobson" rel="home">Simon&nbsp;Dobson</a>
	    </h1>
	</div>
	<nav class="site-navigation" role="navigation"><div class="menu-toggle">
		<span class="mobile-site-title">Simon Dobson</span>
	    </div>
	    <ul class="menu">
<li><a href="../index.html">Home</a></li>
		    <li><a href="../personal/">About&nbsp;me</a></li>
		    <li><a href="../research/">Research</a></li>
		    <li><a href="../development/projects/">Software</a></li>
		    <li><a href="../writing/">Writing</a></li>
		    <li><a href="../personal/contact/">Contact</a></li>
		<li>
<a href="../rss.xml"><i class="fa fa-rss"></i></a>
	    </li>
</ul></nav></header><div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2012/07/11/call-papers-midsens-2012/" rel="bookmark">Wednesday 11 July, 2012</a>
			</span>
		    </div>
		    <h1><a href="../2012/07/11/call-papers-midsens-2012/">Call for papers: Midsens&nbsp;2012</a></h1>
		</div>
		<div class="entry-content">
			<p>The Seventh International Workshop on Middleware Tools, Services and Run-time Support for Sensor Networks (<a href="http://www.midsens.org/" target="_blank">MidSens’12</a>) will be co-located with <a href="http://middleware2012.cs.mcgill.ca/">Middleware 2012</a> (December 3rd - 7th, 2012) in Montreal, Canada

<!--more-->

The aim of MidSens&#8216;12 is to stimulate research in the specific domain of middleware for sensor networks. The particular focus of MidSens&#8216;12 is the realization of <strong>multi-user, multi-purpose and federated sensing platforms</strong> that are capable of supporting next-generation application scenarios such as <strong>smart cities</strong>. Along with the core topic of middleware architectures, services and tool support, MidSens&#8216;12 will also seek papers describing novel programming languages, run-time support and relevant experience reports. MidSens&#8216;12 will investigate how middleware support can relieve developers from low-level, platform specific concerns, while enabling the optimal exploitation of heterogeneous resources to create <strong>sensing infrastructures of massive scale</strong>.

Effectively developing, deploying and managing sensor network platforms requires supporting middleware services, tools and run-time support. MidSens&#8216;12 welcomes papers on the following research&nbsp;topics:
</p>
<ul>
<li>Middleware Tools and&nbsp;Architectures:</li>
<ul>
<li>Software architectures for sensor&nbsp;networks</li>
    <li>Novel programming abstractions for large-scale sensor&nbsp;networks</li>
    <li>Architectures to combine mobile devices and sensor&nbsp;motes</li>
    <li>Lightweight autonomic middleware for embedded&nbsp;systems</li>
    <li>Testing and simulation tools for sensor network&nbsp;middleware</li>
    <li>Fault identification, diagnosis and&nbsp;repair</li>
</ul>
<li>Middleware&nbsp;services:</li>
<ul>
<li>Location tracking, localization, and&nbsp;synchronization.</li>
    <li>Support for real-time and safety-critical&nbsp;systems.</li>
    <li>Data management, aggregation and&nbsp;filtering.</li>
    <li>Energy-aware middleware&nbsp;mechanisms.</li>
    <li>Fault tolerance, reliability and quality of&nbsp;service.</li>
    <li>Privacy and security&nbsp;services.</li>
    <li>Virtualization, sharing and trading of&nbsp;resources.</li>
</ul>
<li>Run-time&nbsp;Support:</li>
<ul>
<li>Overlay and topology creation, maintenance and&nbsp;management.</li>
    <li>Resource/Service discovery and&nbsp;management.</li>
    <li>Support for reconfiguration and&nbsp;adaptation.</li>
    <li>Effective naming and addressing&nbsp;schemes.</li>
    <li>Support for modeling and enacting safe software&nbsp;reconfiguration.</li>
</ul>
<li>Management and&nbsp;Experiences:</li>
<ul>
<li>Managing heterogeneity and network&nbsp;dynamism.</li>
    <li>Integration of embedded systems with web&nbsp;services.</li>
    <li>Experience and evaluation of middleware&nbsp;platforms.</li>
    <li>Support for the unification of various embedded&nbsp;platforms.</li>
    <li>Shared infrastructure embedded&nbsp;systems.</li>
</ul>
</ul>
Submitted papers must be original work in English without substantial overlap with papers that have been published or that are simultaneously submitted to a journal or conference with proceedings. Submissions must not exceed 6 pages, must strictly follow the <span class="caps">ACM</span> conference proceedings format, and must be submitted in <span class="caps">PDF</span> format.

All accepted papers will appear in the <strong><span class="caps">ACM</span> Digital Library</strong> and will be indexed in <strong> <span class="caps">DBLP</span></strong>.
<h3>Important&nbsp;Dates:</h3>
<ul>
<li>Paper Submission deadline: August 15,&nbsp;2012</li>
    <li>Acceptance notification: September 21,&nbsp;2012</li>
    <li>Author registration deadline: October 5,&nbsp;2012</li>
    <li>Camera-ready version due: October 5,&nbsp;2012</li>
    <li>Workshop: December 3-7,&nbsp;2012</li>
</ul>
</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2012/06/19/asensis/" rel="bookmark">Tuesday 19 June, 2012</a>
			</span>
		    </div>
		    <h1><a href="../2012/06/19/asensis/">Workshop on naturally-inspired service&nbsp;ecosystems</a></h1>
		</div>
		<div class="entry-content">
			<p>The <a href="http://www.sapere-project.eu/" target="_blank">Sapere project</a> (of which I&#8217;m a member) is running a workshop at <a href="http://saso2012.univ-lyon1.fr/index.php" target="_blank"><span class="caps">SASO</span> 2012 in Lyons</a> on new ways to design service ecosystems.

<!--more-->

Emerging distributed computing scenarios (mobile, pervasive, and social) are characterised by intrinsic openness, decentralisation, and dynamics. According, the effective deployment and execution of distributed services and applications calls for open service  frameworks promoting situated and self-adaptive behaviours, and supporting diversity in services and long-term evolvability. This suggests adopting nature-inspired and/or socially-inspired approaches, in which services are modelled and deployed as autonomous individuals in an ecosystem of other services, data sources, and pervasive devices. Accordingly, the self-organizing interactions patterns among components and the resulting emerging dynamics of the system, as those of natural systems or of social systems, can inherently exhibit effective properties of self-adaptivity and evolvability.

Although many initiatives (like those named upon digital/business service ecosystems) recognise that the complexity of modern service systems is comparable to that of natural ecosystems, the idea that nature – other than a mean to metaphorically characterise their complexity – can become the source of inspiration for their actual modelling and implementation is only starting being metabolised.

The goal of this workshop is to bring together researchers and practitioners, with the aims of unfolding the many challenges related to the modelling, design and implementation of adaptive service ecosystems in natural and social terms, and identifying promising approaches and solutions.

Topics of interest include, but are not limited&nbsp;to:
</p>
<ul>
<li>Software architectures for  emergent distributed&nbsp;systems.</li>
    <li>Bio-inspired self-organising patterns design&nbsp;patterns.</li>
    <li>Coordination models and&nbsp;languages.</li>
    <li>Middleware&nbsp;platforms</li>
    <li>Dynamic services&nbsp;composition.</li>
    <li>Adaptive coordination models and&nbsp;patterns</li>
    <li>Self-organisation and&nbsp;coordination</li>
    <li>Coordination in systems of feedback&nbsp;loops</li>
    <li>Middleware for adaptive&nbsp;coordination</li>
    <li>Multiagent&nbsp;systems</li>
    <li>Methodologies for adaptive and self-organising system&nbsp;engineering</li>
</ul>
All accepted papers will be published by <span class="caps">IEEE</span> Xplore following the workshop.

Submission deadline is 4 July 2012. For more details please see the <a href="http://apice.unibo.it/xwiki/bin/view/ASENSIS/" target="_blank">workshop web site</a>.

<span class="caps">UPDATE</span>: Fixed typo in the submission deadline
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2012/06/14/russian-dolls/" rel="bookmark">Thursday 14 June, 2012</a>
			</span>
		    </div>
		    <h1><a href="../2012/06/14/russian-dolls/">Layered abstractions and Russian&nbsp;dolls</a></h1>
		</div>
		<div class="entry-content">
			<p>The layering of abstractions has served us well, but it&#8217;s now generating the sorts of complexity it was designed to solve. Time for a re-think?

<!--more-->Anyone who&#8217;s built a large piece of software knows that much of the effort is in managing the complexity of the project: which other software a piece of code relies on, how to keep the various aspects separate, how to manage changes and upgrades, and so on. This isn&#8217;t something that&#8217;s got easier over time: it has for a given code size and style, as we&#8217;ve understood build processes and dependency management better; but the code sizes have relentlessly increased to compensate for our improved understanding; and modern practices don&#8217;t make life any easier. Downloaded code, dynamic modules and classes, client-server and the like all generate their own intrinsic complexity.

One of the biggest sources of complexity is the use of multiple applications, especially in enterprise systems. A typical e-commerce system, for example, will make use of a web server to present pages (which themselves might contain embedded JavaScript for client-side processing), a database to track orders and inventory, a procurement system to fulfil orders, and possibly a supply-chain management system to order new inventory. That&#8217;s the application. Then there&#8217;ll be the operating system, a logging facility, a facilities management system, and a load of administrative tools and scripts. And the operating system may itself be virtualised and running as a guest within another, host operating system and hypervisor, which needs its own toolset. The interactions between these tools can be mind-boggling.

Someone once asked: who knows how to work the <a href="http://httpd.apache.org/" target="_blank">Apache web server</a>? It sounds like a simple question &#8212; any competent web manager? the main developers? &#8212; but the sting in the tail is that Apache is very configurable: so configurable, in fact, that it&#8217;s pretty much impossible to work out what a given combination of options will do (or, conversely, what combination of options to use to achieve a given effect). The interactions are just too complicated, and the web abounds with examples where interactions between (for example) the thread pool size, the operating system block size, and the Java virtual machine parameters conspire to crash a system that looks like it should be working fine. If you can&#8217;t work one server properly &#8212; one component of the system &#8212; what hope is there to get a complete system humming along?

<a href="http://blogs.cs.st-andrews.ac.uk/al/" target="_blank">Al Dearle</a> and I have been talking about this for a while. The basic issue seems to be an interaction between decomposition and dependency. In other words, the complexity comes at the &#8220;seams&#8221; between the various sub-systems, and is magnified the more configurable the components on either side of the seam are. This is important, because systems are becoming more finely decomposed: the move to component software, software-as-a-service and the like all increase the number of seams. Al&#8217;s image of this is that modern systems are like Russian dolls, where each supposedly independent component contains more components that influence the size and complexity of the component containing them. You can only simplify any individual piece so far, because it depends on so many other pieces.

Actually a lot of the seams are now unnecessary anyway. Going back to the e-commerce example, the operating system goes to great pains to provide a process abstraction to keep the components separate &#8212; to stop faults in the database affecting the web server, for example. Historically this made perfect sense and prevented a single faulty process in a time-sharing system affecting the processes of other users. Nowadays, however, it makes considerably less sense, for a number of reasons. Firstly, all the components are owned by a single nominal user (although there are still good reasons for separating the root user from the application user), so the security concerns are less pronounced. Secondly, all the components depend on each other, so a crash in the database will effectively terminate the web server anyway. (We&#8217;re simplifying, but you get the idea.) Finally, there&#8217;s a good chance that the web server, database and so on are each running in their own virtual machine, so there&#8217;s only one &#8220;real&#8221; process per machine (plus all the supporting processes). The operating system is offering protection that isn&#8217;t needed, because it&#8217;s being provided (again) by the hypervisor running the virtual machines and perhaps (<em>again</em>) by the host operating system(s) involved.

We also tend to build very flexible components (like Apache), which can deal with multiple simultaneous connections, keep users separate, allow modules to be loaded and unloaded dynamically &#8212; behave like small operating systems, in other words, replicating the <span class="caps">OS</span> functionality again at application level. This is despite the fact that, in enterprise configurations, you&#8217;ll probably know in advance the modules to be loaded and have a single user (or small user population) and fixed set of interactions: the flexibility makes the component more complex for no net gain during operation. Although it might simplify configuration and evolution slightly, there are often other mechanisms for this: in a cloud environment one can spin-up a replacement system in an evolved state and then swap the set of VMs over cleanly.

It&#8217;s easy to think that this makes no difference for modern machines, but that&#8217;s probably not the case. All these layers still need to be resourced; more importantly, they still need to be managed, maintained and secured, which take time to do well &#8212; with a result that they typically get done badly (if at all).

Can we do anything about it? One thought is that the decomposition that makes thinking about systems and programming easier makes executing those systems more complex and fragile. In many cases, once the system is configured appropriately, flexibility becomes an enemy: it&#8217;ll often be too complicated to re-configure or optimise in a live environment anyway. There may be a reason to have Russian dolls when <em>designing</em> a system, but once designed it&#8217;s better to make each doll solid to remove the possibility of then opening-up and falling apart.

So it&#8217;s not decomposition that&#8217;s the issue, it&#8217;s <em>decomposition manifested at run-time</em>. When we add new abstractions to systems, we typically add them in the form of components or libraries that can be called from other components. These components are often general, with lots of parameters and working with multiple clients &#8212; sound familiar? This is all good for the component-writer, as it lets the same code be re-used: but it bloats each system that uses the component, adding complexity and interactions.

So one thought for tackling complexity is to change where decomposition manifests itself. If instead of placing new functions in the run-time system, we placed it into the compiler used to build the run-time, we could use compilation techniques to optimise-out the unnecessary functionality so that what results is optimised for the configuration that it&#8217;s actually being placed in, rather than being general enough to represent any configuration. There&#8217;s substantial work on these ideas in the fields of staged compilation and partial evaluation (for example <a href="http://www.metaocaml.org/" target="_blank">MetaOCaml</a>, <a href="http://www.haskell.org/haskellwiki/Template_Haskell" target="_blank">Template Haskell</a>, Flask and the like): the flexibility is manifested at compile-time as compile-time abstractions, that in the course of compilation are removed and replaced with inflexible &#8212; but more efficient and potentially more dependable &#8212; specialised code. Think taking the source code for Linux, Apache and MySQL, accelerating them together at high speed, and getting out a single program that&#8217;d run on a bare machine, had nothing it didn&#8217;t actually need, and had all the options for the various (conceptual) sub-systems set correctly to work together.

Don&#8217;t believe it&#8217;s possible? Neither do I. There&#8217;s too much code and especially too much legacy code for this to work at enterprise (or even desktop) level. However, for embedded systems and sensor networks it&#8217;s a different story. For these systems, every extra abstraction that makes the programmer&#8217;s life easier is a menace if it increases the code size hitting the metal: there just isn&#8217;t the memory. But there also isn&#8217;t the legacy code base, and there is a crying need for better abstractions. So an approach to the Russian dolls that moves the abstractions out of the run-time and<a href="../2011/05/evolving/" target="_blank"> into the languages and compilers</a> might work, and might considerably improve the robustness and ease of use for many systems we need to develop. It also works well with modern language technology, and with other trends like <a href="../2011/12/middleware-doughnut/" target="_blank">ever-more-specialised middleware</a> that remove bloat and overhead at the cost of generality. Keeping the former <em>and</em> the latter seems like a worthwhile&nbsp;goal.</p>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../goodreads/1776/" rel="bookmark">Wednesday 23 May, 2012</a>
			</span>
		    </div>
		    <h1><a href="../goodreads/1776/">1776</a></h1>
		</div>
		<div class="entry-content">
			<div>
    <div>
      <img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1306787560l/1067._SX98_.jpg" style="float: left; margin-right: 10px"><h2>
	David McCullough&nbsp;(2005)
      </h2>
    </div>
    <p>
      
      </p>
<p>
	4/5.
	  Finished Wednesday 23 May,&nbsp;2012.
	</p>
<p>
	  (Originally published on <a href="https://www.goodreads.com/review/show/335040700?utm_medium=api&amp;utm_source=rss">Goodreads</a>.)
  </p>
</div>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2012/05/17/5-studentships/" rel="bookmark">Thursday 17 May, 2012</a>
			</span>
		    </div>
		    <h1><a href="../2012/05/17/5-studentships/">5 studentships in Computer Science and St&nbsp;Andrews</a></h1>
		</div>
		<div class="entry-content">
			<p>We have five more PhD scholarships tenable from September, for students interested in any of our areas of research. The details are available <a href="http://www.jobs.ac.uk/job/AEL878/funded-phd-research-studentship/" target="_blank">here</a>. Please note that I&#8217;m not taking on a PhD student this year, so don&#8217;t bother applying to work with&nbsp;me.</p>
		</div>
	    </article>
</div>
    <!-- Lower Navigation links -->
    <nav class="site-content navigation-post" role="navigation"><div class="previous">
		<a href="index-29.html" rel="prev">
		    <span class="meta-nav">Older Entries</span>		</a>
	    </div>
	    <div class="next">
		<a href="index-31.html" rel="next">
		    <span class="meta-nav">Newer Entries</span>		</a>
	    </div>
    </nav><!-- Page Footer --><section class="footer-sidebar clear" role="complementary"><div class="widget-block">
	    <aside class="widget"><h2 class="widget-title">Simon&nbsp;Dobson</h2>
		<div class="widget-text">Aut tace aut loquere meliora silentio</div>
	    </aside>
</div>
    </section><!-- Extra JavaScript --><!-- Site Attributions --><footer class="site-footer" role="contentinfo"><div class="site-info">
	    <p></p>
	    <p>
	      Built with free and open-source software.
	      Powered by <a href="https://getnikola.com/">Nikola</a> using a theme based on
	      <a href="https://themes.getnikola.com/v7/libretto/">Libretto</a>.
	    </p>
	    <p>
	      All content Copyright © 2010–2025 Simon Dobson and licensed under
	      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="caps">CC</span>-<span class="caps">BY</span>-<span class="caps">NC</span>-<span class="caps">SA</span>-4.0</a>
	      unless otherwise&nbsp;noted.
	    </p>
	</div>
	<div class="social">
	    <ul class="menu"></ul>
</div>
    </footer>
</body>
</html>