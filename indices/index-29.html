<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simon Dobson (old posts, page 29)</title>
<style>
	@font-face {
	    font-family: "libretto-icons";
	    src:url(../assets/fonts/libretto-icons.eot);
	    src:url(../assets/fonts/libretto-icons.eot#iefix) format("embedded-opentype"),
	    url(../assets/fonts/libretto-icons.woff) format("woff"),
	    url(../assets/fonts/libretto-icons.ttf) format("truetype"),
	    url(../assets/fonts/libretto-icons.svg#libretto-icons) format("svg");
	    font-weight: normal;
	    font-style: normal;
	}
    </style>
<link rel="icon" href="../images/favicon.png" sizes="16x16">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono%7CLibre+Baskerville%7CMontserrat%7CPlayfair+Display">
<link rel="stylesheet" href="../assets/css/libretto_styles.css">
<link rel="stylesheet" href="../assets/css/baguetteBox.min.css">
<link rel="stylesheet" href="../assets/css/code.css">
<link rel="stylesheet" href="../assets/css/nikola_rst.css">
<link rel="stylesheet" href="../assets/css/nikola_ipython.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
</head>
<body>
    <!-- Navigation bar -->
    <header class="nav-bar"><div class="site-branding">
	    <h1 class="site-title">
		<a href="https://simondobson.org/" title="Simon Dobson" rel="home">Simon Dobson</a>
	    </h1>
	</div>
	<nav class="site-navigation" role="navigation"><div class="menu-toggle">
		<span class="mobile-site-title">Simon Dobson</span>
	    </div>
	    <ul class="menu">
<li><a href="../index.html">Home</a></li>
		    <li><a href="../personal/">About me</a></li>
		    <li><a href="../research/">Research</a></li>
		    <li><a href="../development/projects/">Software</a></li>
		    <li><a href="../writing/">Writing</a></li>
		    <li><a href="../personal/contact/">Contact</a></li>
		    <li><a href="../rss.xml">RSS</a></li>
	    </ul></nav></header><div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2012/05/04/postmodernism-programming/" rel="bookmark">Friday 4 May, 2012</a>
			</span>
		    </div>
		    <h1><a href="../2012/05/04/postmodernism-programming/">The post-modernisation of programming languages</a></h1>
		</div>
		<div class="entry-content">
			<p>Do we now have some post-modern programming languages?

<!--more-->

Programming languages change all the time. It's never been the case that one could learn just one and then use it: programming is too rich and complicated for that to be a solution for the majority of programmers. However, we seem to be seeing a change in what we think of as programming languages and how they're used to build larger software systems.

At the risk of gross over-simplification (and ridicule), let's divide languages into various "eras". In the beginning, the <em>early</em> languages were built around some explicit notion of the machine on which they were running. Assemblers were devoted to a single machine code. Higher-level languages like Forth abstracted away from the machine code but still exposed the guts of the machine, and in particular its data bus width and memory access mechanisms.

The next step in abstraction -- to <em>pre-modernism</em> -- was to provide a machine that was still recognisably a Von Neumann system but that hid the details of the underlying machine code and architecture. C and Pascal fall into this category: their operations and abstractions are still largely those of the physical machine, but at a sufficient remove to achieve portability and a usable programming model. But we still have a view of the machine's underlying limitations. <em>Modern</em> languages like Perl, Java and Haskell offer a model of computation, and especially a model of memory, that's considerably removed from the underlying machine and enormously simplifies the programmer's task, at least for "suitable" programs.

(Interestingly enough languages don't fall into eras in the sequence of their design or popularity. Lisp considerably pre-dates C but is definitely modern using the terminology above.)

What's perhaps not obvious is that all these languages share a common design philosophy. They are all based on a small set of primitive notions combined with some ways of combining those notions, to get compound abstractions that resemble their primitive underpinnings. In C we get a small number of base types, some compound structs and unions, and pointers, and most interesting compound structures one builds will contain pointers all over the place. In Java we can build classes that create and combine objects; in Haskell we get lists and higher-order functions as the basic building blocks. The point is that the basic concepts are <em>general</em>, as are the composition operators, and the larger capabilities are in some sense a <em>consequence</em> of these initial choices and characterise the programs it's easy (or hard) to write.

This philosophy makes perfect sense, of course, which explains why it's so widespread. Programmers have to get to grips with a small set of basic concepts and composition methods. Everything else flows from this, and the extensions to the language -- libraries and the like -- will be the same as code one could write oneself: they're time-savers, but not fundamentally different from your own code. As a consequence the basic concepts have to be well-chosen to support the range of programs people will want to write. Some will be easier to write than others -- that's what makes the choice of language more than simply a matter of fashion -- but there's an acceptance that pretty much anything is writeable.<em></em>

However, we're now seeing languages emerge that aren't like this. Instead they're very much targeted at specific domains and problem sets. We've always had domain-specific languages (DSLs), of course, but the current crop seem to me to be rather different. They've abandoned the design philosophy of a small, basic set of abstractions and powerful composition, in favour of large basic abstractions and limited composition and extension. This significantly changes development, and the balance of power between the language designer and the programmer.

XSLT is the language that's brought this most to mind, and especially the transition from XSLT 1.0 to XSLT 2.0.

First we have to defend the notion that XSLT is a programming language. I first thought of it as just a transformation system for documents, and so it is: but it's targeted at such a general set of applications that it takes on the flavour of a DSL. It's essentially a functional language with pattern-matching and recursion, whose main data structure is the XML document. It lets one write programs that are driven by these documents: another way to look at it is that it gives executable semantics to a set of XML tags, allowing them to perform computation.

XSLT's design doesn't start with a small set of primitives. Instead it provides a collection of tags that can be used to perform the common document operations. If you want to number a list, for example, XSLT contains tags that support the common numbering formats: numbers, letters with brackets, and so forth. What?, you wanted something else? Well, you can <em>probably</em> do it, but it'll be indescribably hard because you'll be writing a program in a language for which full computation is an afterthought. Instead, XSLT 2.0 adds <em>new</em> numbering formats that you can select using a helpful set of tags, and this is done <em>within</em> the XSLT processor, not <em>using</em> the XSLT processor. Meaningful extension requires the intervention of the language designer.

This is a major philosophical change, a <em>post-modern</em> approach to language design. Don't focus on getting the core abstractions right: instead, build a system -- <em>any</em> system -- that demonstrates initial functionality, and then extend it with new features to meet new demands regardless of how they fit. There's no overarching conceptual scheme to the system. Instead it's judged purely on the functions it provides, regardless of how they fit together. (<a href="http://www.wall.org/~larry/pm.html" target="_blank">Larry Wall described Perl as post-modern</a>, but I don't think he meant quite what I'm getting at here -- although there are similarities.)

Post-modernism  works for three reasons. Firstly, no-one is expecting to write very large amounts of code in these systems. They're intended for <em>sub-</em>systems, not for systems themselves, and so the need for generality is limited. Secondly, there's a premium on speed of development rather than on maintenance, which in turn puts a premium on getting some result out quickly rather than on ensuring that, in the future, we can get any result out we need. The sub-systems are intended to change on a short timescale, so maintenance and extensibility is perceived to be less of an issue than agility. Thirdly, a lot of these languages target people who aren't programmers -- or at least don't think of themselves as programmers -- who are focused on something other than the code.

Post-modernism isn't wrong, and <a href="../2011/12/middleware-doughnut/" target="_blank">appears in middleware too</a>. It's also important to realise the benefits: it makes it easier to put together larger systems, and increases <a href="../2011/06/computing-experience/" target="_blank">the ambition of projects one can undertake</a> compared to having to build so much from scratch, But it may be misguided. The people who spent the 1960's writing all the COBOL code that's still running today never thought it'd still be being maintained -- and the consequences of that lead to code that's now impossible to change. Simple solutions have a tendency to grow into more complex ones -- "just one more feature and we're done" -- which can push the costs of inappropriate choices out along the project lifecycle.

More importantly, for researchers post-modernism is a seductive siren call that lets you step away from tackling some difficult choices. Instead of picking a small set of concepts, choose <em>any set</em> and then extend them, in <em>any way</em>, to build up your system. I think this obscures some insights one might otherwise gain from simplifying your set of concepts.

I think it's also worth remembering that increasing the size and number of abstractions isn't without cost: not for the computer or the compiler, but for the programmer. The more programmers have to remember, and in particular the less well the things to be remembered fit together as a conceptual whole, the harder it is to use the system to its fullest advantage. People instead stay with small sub-sets of the language or -- worse -- settle for programs producing results that aren't those they want, just to stay within their language comfort zone. This sort of simplification is a step backwards, and we need to be careful of the consequences.</p>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2012/04/26/brazil-science/" rel="bookmark">Thursday 26 April, 2012</a>
			</span>
		    </div>
		    <h1><a href="../2012/04/26/brazil-science/">Brazilian "Science without Borders" studentships available</a></h1>
		</div>
		<div class="entry-content">
			<p>The School of Computer Science has a number of opportunities available for Brazilian students through this programme.

<!--more-->

The Brazilian government is funding studentships for Brazilian nationals with a range of international universities and disciplines. The studentships are "co-tutelle", being split between an international and a Brazilian host university, and aim to improve international collaboration as well as enhancing the student experience.

A number of Schools at St Andrews  are <a href="http://www.st-andrews.ac.uk/scholarships/brazil/">part of this programme</a>, ranging across the physical and biological sciences in areas in which we have international-quality research. In Computer Science, we have <a href="http://www.st-andrews.ac.uk/scholarships/brazil/computerscience/">a wide range of project proposals on offer</a> covering all our main research activities. Interested students should contact the supervisors offering the proposed projects to check on suitability and availability. All students will be subject to the University's usual rules on quality and eligibility.</p>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../goodreads/the-great-terror-a-reassessment/" rel="bookmark">Friday 30 March, 2012</a>
			</span>
		    </div>
		    <h1><a href="../goodreads/the-great-terror-a-reassessment/">The Great Terror: A Reassessment</a></h1>
		</div>
		<div class="entry-content">
			<div>
    <div>
      <img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1386924223l/52137._SX98_.jpg" style="float: left; margin-right: 10px"><h2>
	Robert Conquest
	  (1968)
      </h2>
    </div>
    <p>
      
      </p>
<p>
	4/5.
	  Finished Friday 30 March, 2012.
	</p>
<p>
	  (Originally published on <a href="https://www.goodreads.com/review/show/303652060?utm_medium=api&amp;utm_source=rss">Goodreads</a>.)
  </p>
</div>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../goodreads/world-war-ii-behind-closed-doors-stalin-the-nazis-and-the-west/" rel="bookmark">Friday 30 March, 2012</a>
			</span>
		    </div>
		    <h1><a href="../goodreads/world-war-ii-behind-closed-doors-stalin-the-nazis-and-the-west/">World War II: Behind Closed Doors; Stalin, the Nazis, and the West</a></h1>
		</div>
		<div class="entry-content">
			<div>
    <div>
      <img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1328825155l/2353215._SX98_.jpg" style="float: left; margin-right: 10px"><h2>
	Laurence Rees
	  (2008)
      </h2>
    </div>
    <p>
      
      </p>
<p>
	4/5.
	  Finished Friday 30 March, 2012.
	</p>
<p>
	  (Originally published on <a href="https://www.goodreads.com/review/show/303651889?utm_medium=api&amp;utm_source=rss">Goodreads</a>.)
  </p>
</div>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../goodreads/hitler-and-stalin-parallel-lives/" rel="bookmark">Friday 30 March, 2012</a>
			</span>
		    </div>
		    <h1><a href="../goodreads/hitler-and-stalin-parallel-lives/">Hitler and Stalin: Parallel Lives</a></h1>
		</div>
		<div class="entry-content">
			<div>
    <div>
      <img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1560076497l/782319._SX98_.jpg" style="float: left; margin-right: 10px"><h2>
	Alan Bullock
	  (1991)
      </h2>
    </div>
    <p>
      
      </p>
<p>
	5/5.
	  Finished Friday 30 March, 2012.
	</p>
<p>
	  (Originally published on <a href="https://www.goodreads.com/review/show/303651580?utm_medium=api&amp;utm_source=rss">Goodreads</a>.)
  </p>
</div>
		</div>
	    </article>
</div>
    <!-- Lower Navigation links -->
    <nav class="site-content navigation-post" role="navigation"><div class="previous">
		<a href="index-28.html" rel="prev">
		    <span class="meta-nav">Older Entries</span>		</a>
	    </div>
	    <div class="next">
		<a href="index-30.html" rel="next">
		    <span class="meta-nav">Newer Entries</span>		</a>
	    </div>
    </nav><!-- Page Footer --><section class="footer-sidebar clear" role="complementary"><div class="widget-block">
	    <aside class="widget"><h2 class="widget-title">Simon Dobson</h2>
		<div class="widget-text">Aut tace aut loquere meliora silentio</div>
	    </aside>
</div>
    </section><!-- Site Attributions --><footer class="site-footer" role="contentinfo"><div class="site-info">
	    <p></p>
	    <p>
	      Built with open-source software, especially <a href="https://emacs.org/">Emacs</a>.
	      Powered by <a href="https://getnikola.com/">Nikola</a> using a theme based on
	      <a href="https://note2self.abraham-v.com/libretto-theme-for-nikola/">Libretto</a>.
	    </p>
	    <p>
	      All content licensed under
	      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA-4.0</a>
	      unless otherwise noted.
	    </p>
	</div>
	<div class="social">
	    <ul class="menu"></ul>
</div>
    </footer><!-- Extra JavaScript -->
</body>
</html>
