<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simon Dobson (old posts, page 29)</title>
<style>
	@font-face {
	    font-family: "libretto-icons";
	    src:url(../assets/fonts/libretto-icons.eot);
	    src:url(../assets/fonts/libretto-icons.eot#iefix) format("embedded-opentype"),
	    url(../assets/fonts/libretto-icons.woff) format("woff"),
	    url(../assets/fonts/libretto-icons.ttf) format("truetype"),
	    url(../assets/fonts/libretto-icons.svg#libretto-icons) format("svg");
	    font-weight: normal;
	    font-style: normal;
	}
    </style>
<link rel="icon" href="../images/favicon.png" sizes="16x16">
<link rel="alternate" type="application/rss+xml" href="../rss.xml">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono|Libre+Baskerville|Montserrat|Playfair+Display|Tangerine">
<link rel="stylesheet" href="../assets/css/libretto_styles.css">
<link rel="stylesheet" href="../assets/css/baguetteBox.min.css">
<link rel="stylesheet" href="../assets/css/code.css">
<link rel="stylesheet" href="../assets/css/nikola_rst.css">
<link rel="stylesheet" href="../assets/css/nikola_ipython.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
</head>
<body>
    <!-- Navigation bar -->
    <header class="nav-bar"><div class="site-branding">
	    <h1 class="site-title">
		<a href="https://simondobson.org/" title="Simon Dobson" rel="home">Simon&nbsp;Dobson</a>
	    </h1>
	</div>
	<nav class="site-navigation" role="navigation"><div class="menu-toggle">
		<span class="mobile-site-title">Simon Dobson</span>
	    </div>
	    <ul class="menu">
<li><a href="../index.html">Home</a></li>
		    <li><a href="../personal/">About&nbsp;me</a></li>
		    <li><a href="../research/">Research</a></li>
		    <li><a href="../development/projects/">Software</a></li>
		    <li><a href="../writing/">Writing</a></li>
		    <li><a href="../personal/contact/">Contact</a></li>
		<li>
<a href="../rss.xml"><i class="fa fa-rss"></i></a>
	    </li>
</ul></nav></header><div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2012/05/08/library-book/" rel="bookmark">Tuesday 8 May, 2012</a>
			</span>
		    </div>
		    <h1><a href="../2012/05/08/library-book/">When not to return a library&nbsp;book</a></h1>
		</div>
		<div class="entry-content">
			<p>Beware of books bearing illnesses.

<!--more-->

I recently read <em>Hindenburg: the wooden titan</em>, John Wheeler-Bennet&#8217;s biography of the presidency of the man who ushered Hitler into power. It&#8217;s an interesting book, written just after Hindenburg&#8217;s death and so before the second world war and the realisation of exactly what had been brought forth. You can also find <a href="http://www.vqronline.org/articles/1937/summer/hoover-wooden-titan/" target="_blank">contemporary book reviews online</a> which are likewise fascinating in what they don&#8217;t know. It really brings home <span class="caps">AJP</span> Taylor&#8217;s comment (in <em>The struggle for mastery in Europe</em>) that that hardest thing about the study of history to to remember that events now long in the past once lay in the future.

<a href="http://blogs.cs.st-andrews.ac.uk/simondobson/files/2012/05/2012-03-17-17.12.12-e1336223919163.jpg"><img class="alignleft size-medium wp-image-1138" title="Bookplate" src="http://blogs.cs.st-andrews.ac.uk/simondobson/files/2012/05/2012-03-17-17.12.12-e1336223919163-190x300.jpg" alt="" width="190" height="300"></a>What was unexpectedly fascinating was the bookplate in the front of the volume I borrowed from the university library, which was published in 1937. (I think it&#8217;s a first edition.) The top half is fairly standard, but the bottom part describes something you wouldn&#8217;t expect to find <em></em>in a library book:

<em>&#8220;A person shall not return any public library book which he knows to have been exposed to infection from a notifiable disease &#8230; [including] smallpox, cholera, diphtheria, &#8230;&#8221;</em>

And so on. The list of diseases includes things against which we are now routinely vaccinated (diphtheria, tuberculosis), those we haven&#8217;t seen in the <span class="caps">UK</span> in my lifetime (typhus), and those most people would now brush-off with a course of antibiotics (flu, pneumonia). Except, of course, that at the time there was far less vaccination and no antibiotics at all, since <a href="https://en.wikipedia.org/wiki/Penicillin" target="_blank">mass production didn&#8217;t start until the 1940&#8217;s</a>.

So as well as being an observation of a period in history from a point in time from which its significance was only poorly understood, this book is a time capsule from a period when diseases were a lot bigger and broader threat than they are&nbsp;now.</p>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2012/05/04/postmodernism-programming/" rel="bookmark">Friday 4 May, 2012</a>
			</span>
		    </div>
		    <h1><a href="../2012/05/04/postmodernism-programming/">The post-modernisation of programming&nbsp;languages</a></h1>
		</div>
		<div class="entry-content">
			<p>Do we now have some post-modern programming languages?

<!--more-->

Programming languages change all the time. It&#8217;s never been the case that one could learn just one and then use it: programming is too rich and complicated for that to be a solution for the majority of programmers. However, we seem to be seeing a change in what we think of as programming languages and how they&#8217;re used to build larger software systems.

At the risk of gross over-simplification (and ridicule), let&#8217;s divide languages into various &#8220;eras&#8221;. In the beginning, the <em>early</em> languages were built around some explicit notion of the machine on which they were running. Assemblers were devoted to a single machine code. Higher-level languages like Forth abstracted away from the machine code but still exposed the guts of the machine, and in particular its data bus width and memory access mechanisms.

The next step in abstraction &#8212; to <em>pre-modernism</em> &#8212; was to provide a machine that was still recognisably a Von Neumann system but that hid the details of the underlying machine code and architecture. C and Pascal fall into this category: their operations and abstractions are still largely those of the physical machine, but at a sufficient remove to achieve portability and a usable programming model. But we still have a view of the machine&#8217;s underlying limitations. <em>Modern</em> languages like Perl, Java and Haskell offer a model of computation, and especially a model of memory, that&#8217;s considerably removed from the underlying machine and enormously simplifies the programmer&#8217;s task, at least for &#8220;suitable&#8221; programs.

(Interestingly enough languages don&#8217;t fall into eras in the sequence of their design or popularity. Lisp considerably pre-dates C but is definitely modern using the terminology above.)

What&#8217;s perhaps not obvious is that all these languages share a common design philosophy. They are all based on a small set of primitive notions combined with some ways of combining those notions, to get compound abstractions that resemble their primitive underpinnings. In C we get a small number of base types, some compound structs and unions, and pointers, and most interesting compound structures one builds will contain pointers all over the place. In Java we can build classes that create and combine objects; in Haskell we get lists and higher-order functions as the basic building blocks. The point is that the basic concepts are <em>general</em>, as are the composition operators, and the larger capabilities are in some sense a <em>consequence</em> of these initial choices and characterise the programs it&#8217;s easy (or hard) to write.

This philosophy makes perfect sense, of course, which explains why it&#8217;s so widespread. Programmers have to get to grips with a small set of basic concepts and composition methods. Everything else flows from this, and the extensions to the language &#8212; libraries and the like &#8212; will be the same as code one could write oneself: they&#8217;re time-savers, but not fundamentally different from your own code. As a consequence the basic concepts have to be well-chosen to support the range of programs people will want to write. Some will be easier to write than others &#8212; that&#8217;s what makes the choice of language more than simply a matter of fashion &#8212; but there&#8217;s an acceptance that pretty much anything is writeable.<em></em>

However, we&#8217;re now seeing languages emerge that aren&#8217;t like this. Instead they&#8217;re very much targeted at specific domains and problem sets. We&#8217;ve always had domain-specific languages (DSLs), of course, but the current crop seem to me to be rather different. They&#8217;ve abandoned the design philosophy of a small, basic set of abstractions and powerful composition, in favour of large basic abstractions and limited composition and extension. This significantly changes development, and the balance of power between the language designer and the programmer.

<span class="caps">XSLT</span> is the language that&#8217;s brought this most to mind, and especially the transition from <span class="caps">XSLT</span> 1.0 to <span class="caps">XSLT</span> 2.0.

First we have to defend the notion that <span class="caps">XSLT</span> is a programming language. I first thought of it as just a transformation system for documents, and so it is: but it&#8217;s targeted at such a general set of applications that it takes on the flavour of a <span class="caps">DSL</span>. It&#8217;s essentially a functional language with pattern-matching and recursion, whose main data structure is the <span class="caps">XML</span> document. It lets one write programs that are driven by these documents: another way to look at it is that it gives executable semantics to a set of <span class="caps">XML</span> tags, allowing them to perform computation.

<span class="caps">XSLT</span>&#8217;s design doesn&#8217;t start with a small set of primitives. Instead it provides a collection of tags that can be used to perform the common document operations. If you want to number a list, for example, <span class="caps">XSLT</span> contains tags that support the common numbering formats: numbers, letters with brackets, and so forth. What?, you wanted something else? Well, you can <em>probably</em> do it, but it&#8217;ll be indescribably hard because you&#8217;ll be writing a program in a language for which full computation is an afterthought. Instead, <span class="caps">XSLT</span> 2.0 adds <em>new</em> numbering formats that you can select using a helpful set of tags, and this is done <em>within</em> the <span class="caps">XSLT</span> processor, not <em>using</em> the <span class="caps">XSLT</span> processor. Meaningful extension requires the intervention of the language designer.

This is a major philosophical change, a <em>post-modern</em> approach to language design. Don&#8217;t focus on getting the core abstractions right: instead, build a system &#8212; <em>any</em> system &#8212; that demonstrates initial functionality, and then extend it with new features to meet new demands regardless of how they fit. There&#8217;s no overarching conceptual scheme to the system. Instead it&#8217;s judged purely on the functions it provides, regardless of how they fit together. (<a href="http://www.wall.org/~larry/pm.html" target="_blank">Larry Wall described Perl as post-modern</a>, but I don&#8217;t think he meant quite what I&#8217;m getting at here &#8212; although there are similarities.)

Post-modernism  works for three reasons. Firstly, no-one is expecting to write very large amounts of code in these systems. They&#8217;re intended for <em>sub-</em>systems, not for systems themselves, and so the need for generality is limited. Secondly, there&#8217;s a premium on speed of development rather than on maintenance, which in turn puts a premium on getting some result out quickly rather than on ensuring that, in the future, we can get any result out we need. The sub-systems are intended to change on a short timescale, so maintenance and extensibility is perceived to be less of an issue than agility. Thirdly, a lot of these languages target people who aren&#8217;t programmers &#8212; or at least don&#8217;t think of themselves as programmers &#8212; who are focused on something other than the code.

Post-modernism isn&#8217;t wrong, and <a href="../2011/12/middleware-doughnut/" target="_blank">appears in middleware too</a>. It&#8217;s also important to realise the benefits: it makes it easier to put together larger systems, and increases <a href="../2011/06/computing-experience/" target="_blank">the ambition of projects one can undertake</a> compared to having to build so much from scratch, But it may be misguided. The people who spent the 1960&#8217;s writing all the <span class="caps">COBOL</span> code that&#8217;s still running today never thought it&#8217;d still be being maintained &#8212; and the consequences of that lead to code that&#8217;s now impossible to change. Simple solutions have a tendency to grow into more complex ones &#8212; &#8220;just one more feature and we&#8217;re done&#8221; &#8212; which can push the costs of inappropriate choices out along the project lifecycle.

More importantly, for researchers post-modernism is a seductive siren call that lets you step away from tackling some difficult choices. Instead of picking a small set of concepts, choose <em>any set</em> and then extend them, in <em>any way</em>, to build up your system. I think this obscures some insights one might otherwise gain from simplifying your set of concepts.

I think it&#8217;s also worth remembering that increasing the size and number of abstractions isn&#8217;t without cost: not for the computer or the compiler, but for the programmer. The more programmers have to remember, and in particular the less well the things to be remembered fit together as a conceptual whole, the harder it is to use the system to its fullest advantage. People instead stay with small sub-sets of the language or &#8212; worse &#8212; settle for programs producing results that aren&#8217;t those they want, just to stay within their language comfort zone. This sort of simplification is a step backwards, and we need to be careful of the&nbsp;consequences.</p>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2012/04/26/brazil-science/" rel="bookmark">Thursday 26 April, 2012</a>
			</span>
		    </div>
		    <h1><a href="../2012/04/26/brazil-science/">Brazilian &#8220;Science without Borders&#8221; studentships&nbsp;available</a></h1>
		</div>
		<div class="entry-content">
			<p>The School of Computer Science has a number of opportunities available for Brazilian students through this programme.

<!--more-->

The Brazilian government is funding studentships for Brazilian nationals with a range of international universities and disciplines. The studentships are &#8220;co-tutelle&#8221;, being split between an international and a Brazilian host university, and aim to improve international collaboration as well as enhancing the student experience.

A number of Schools at St Andrews  are <a href="http://www.st-andrews.ac.uk/scholarships/brazil/">part of this programme</a>, ranging across the physical and biological sciences in areas in which we have international-quality research. In Computer Science, we have <a href="http://www.st-andrews.ac.uk/scholarships/brazil/computerscience/">a wide range of project proposals on offer</a> covering all our main research activities. Interested students should contact the supervisors offering the proposed projects to check on suitability and availability. All students will be subject to the University&#8217;s usual rules on quality and&nbsp;eligibility.</p>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../goodreads/the-great-terror-a-reassessment/" rel="bookmark">Friday 30 March, 2012</a>
			</span>
		    </div>
		    <h1><a href="../goodreads/the-great-terror-a-reassessment/">The Great Terror: A&nbsp;Reassessment</a></h1>
		</div>
		<div class="entry-content">
			<div>
    <div>
      <img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1386924223l/52137._SX98_.jpg" style="float: left; margin-right: 10px"><h2>
	Robert Conquest&nbsp;(1968)
      </h2>
    </div>
    <p>
      
      </p>
<p>
	4/5.
	  Finished Friday 30 March,&nbsp;2012.
	</p>
<p>
	  (Originally published on <a href="https://www.goodreads.com/review/show/303652060?utm_medium=api&amp;utm_source=rss">Goodreads</a>.)
  </p>
</div>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../goodreads/world-war-ii-behind-closed-doors-stalin-the-nazis-and-the-west/" rel="bookmark">Friday 30 March, 2012</a>
			</span>
		    </div>
		    <h1><a href="../goodreads/world-war-ii-behind-closed-doors-stalin-the-nazis-and-the-west/">World War <span class="caps">II</span>: Behind Closed Doors; Stalin, the Nazis, and the&nbsp;West</a></h1>
		</div>
		<div class="entry-content">
			<div>
    <div>
      <img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1328825155l/2353215._SX98_.jpg" style="float: left; margin-right: 10px"><h2>
	Laurence Rees&nbsp;(2008)
      </h2>
    </div>
    <p>
      
      </p>
<p>
	4/5.
	  Finished Friday 30 March,&nbsp;2012.
	</p>
<p>
	  (Originally published on <a href="https://www.goodreads.com/review/show/303651889?utm_medium=api&amp;utm_source=rss">Goodreads</a>.)
  </p>
</div>
		</div>
	    </article>
</div>
    <!-- Lower Navigation links -->
    <nav class="site-content navigation-post" role="navigation"><div class="previous">
		<a href="index-28.html" rel="prev">
		    <span class="meta-nav">Older Entries</span>		</a>
	    </div>
	    <div class="next">
		<a href="index-30.html" rel="next">
		    <span class="meta-nav">Newer Entries</span>		</a>
	    </div>
    </nav><!-- Page Footer --><section class="footer-sidebar clear" role="complementary"><div class="widget-block">
	    <aside class="widget"><h2 class="widget-title">Simon&nbsp;Dobson</h2>
		<div class="widget-text">Aut tace aut loquere meliora silentio</div>
	    </aside>
</div>
    </section><!-- Extra JavaScript --><!-- Site Attributions --><footer class="site-footer" role="contentinfo"><div class="site-info">
	    <p></p>
	    <p>
	      Built with free and open-source software.
	      Powered by <a href="https://getnikola.com/">Nikola</a> using a theme based on
	      <a href="https://themes.getnikola.com/v7/libretto/">Libretto</a>.
	    </p>
	    <p>
	      All content Copyright © 2010–2025 Simon Dobson and licensed under
	      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="caps">CC</span>-<span class="caps">BY</span>-<span class="caps">NC</span>-<span class="caps">SA</span>-4.0</a>
	      unless otherwise&nbsp;noted.
	    </p>
	</div>
	<div class="social">
	    <ul class="menu"></ul>
</div>
    </footer>
</body>
</html>