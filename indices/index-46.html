<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simon Dobson (old posts, page 46)</title>
<style>
	@font-face {
	    font-family: "libretto-icons";
	    src:url(../assets/fonts/libretto-icons.eot);
	    src:url(../assets/fonts/libretto-icons.eot#iefix) format("embedded-opentype"),
	    url(../assets/fonts/libretto-icons.woff) format("woff"),
	    url(../assets/fonts/libretto-icons.ttf) format("truetype"),
	    url(../assets/fonts/libretto-icons.svg#libretto-icons) format("svg");
	    font-weight: normal;
	    font-style: normal;
	}
    </style>
<link rel="icon" href="../images/favicon.png" sizes="16x16">
<link rel="alternate" type="application/rss+xml" href="../rss.xml">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Sans+Mono%7CLibre+Baskerville%7CMontserrat%7CPlayfair+Display%7CTangerine">
<link rel="stylesheet" href="../assets/css/libretto_styles.css">
<link rel="stylesheet" href="../assets/css/baguetteBox.min.css">
<link rel="stylesheet" href="../assets/css/code.css">
<link rel="stylesheet" href="../assets/css/nikola_rst.css">
<link rel="stylesheet" href="../assets/css/nikola_ipython.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
</head>
<body>
    <!-- Navigation bar -->
    <header class="nav-bar"><div class="site-branding">
	    <h1 class="site-title">
		<a href="https://simondobson.org/" title="Simon Dobson" rel="home">Simon Dobson</a>
	    </h1>
	</div>
	<nav class="site-navigation" role="navigation"><div class="menu-toggle">
		<span class="mobile-site-title">Simon Dobson</span>
	    </div>
	    <ul class="menu">
<li><a href="../index.html">Home</a></li>
		    <li><a href="../personal/">About me</a></li>
		    <li><a href="../research/">Research</a></li>
		    <li><a href="../development/projects/">Software</a></li>
		    <li><a href="../writing/">Writing</a></li>
		    <li><a href="../personal/contact/">Contact</a></li>
		<li>
<a href="../rss.xml"><i class="fa fa-rss"></i></a>
	    </li>
</ul></nav></header><div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2013/07/31/power/" rel="bookmark">Wednesday 31 July, 2013</a>
			</span>
		    </div>
		    <h1><a href="../2013/07/31/power/">Basic power measurements</a></h1>
		</div>
		<div class="entry-content">
			<p>Some initial measurements of power consumption.</p>
<!--more-->

<p>How much power does Arduino sleep mode save? The simplest way to work this out is to power an Arduino from a battery pack and measure the current being drawn in the different modes. A simple program to demonstrate the different modes is:
</p>
<ul>
<li>Normal <code>delay()</code> loop</li>
    <li>Deep sleep for a period (deep sleep)</li>
    <li>Flash the LED (awake)</li>
    <li>Flash the LED differently while sending out radio messages (awake and transmitting)</li>
</ul>
We perform these tasks repeatedly, keeping them going for 10s each to let the power draw stabilise.
<p>The results are as follows:</p>
<table style="border: 1"><tbody>
<tr>
<td>Activity</td>
<td>Power mode</td>
<td>Current</td>
</tr>
<tr>
<td>Nothing</td>
<td>
<code>delay()</code> loop</td>
<td>43mA</td>
</tr>
<tr>
<td>Nothing</td>
<td>Deep sleep</td>
<td>33mA</td>
</tr>
<tr>
<td>Steady LED</td>
<td>Deep sleep</td>
<td>34mA</td>
</tr>
<tr>
<td>Flashing LED</td>
<td>Awake</td>
<td>45mA</td>
</tr>
<tr>
<td>Xbee (quiet)</td>
<td>Deep sleep</td>
<td>72mA</td>
</tr>
<tr>
<td>Xbee (quiet)</td>
<td>Awake</td>
<td>85mA</td>
</tr>
<tr>
<td>Xbee (transmitting)</td>
<td>Awake</td>
<td>87mA</td>
</tr>
</tbody></table>
<p>The good news is that SleepySketch makes it very easy to access the deep sleep mode, and to stay in it by default. This is good, as the normal approach of using <code>delay()</code> is quite power-hungry. The bad news is that the "at rest" power consumption of an Arduino even in deep sleep  -- the quiescent current being drawn by the voltage regulator and other components on the board, regardless of what the microcontroller is doing -- is about 35mA, with an XBee drawing an additional 40mA.There is very little difference in power whether the radio is transmitting or not (although the current being drawn looked more variable when transmitting, suggesting that there's some variation happening faster than the ammeter's sample time).</p>
<p>The radio isn't put to sleep when the Arduino is asleep, which is clearly something that needs to happen: it draws power even when the Arduino is incapable of using it. Something to explore. Potentially more serious is the power being drawn when the Arduino is asleep. A battery pack with 4 x 1500mAH batteries will be drained in about 7 days (6000mAH / 35mA) even with the system asleep all the time.</p>
<p>[UPDATE 1Aug2013: made the table layout a bit clearer.]</p>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2013/07/31/big-rich/" rel="bookmark">Wednesday 31 July, 2013</a>
			</span>
		    </div>
		    <h1><a href="../2013/07/31/big-rich/">Big, or just rich?</a></h1>
		</div>
		<div class="entry-content">
			<p>The current focus on "big data" may be obscuring something more interesting: it's often not the pure size of a dataset that's important.

<!--more-->

The idea of extracting insight from large bodies of data promises significant advances in science and commerce. Given a large dataset, "big data" techniques cover a number of possible approaches:
</p>
<ul>
<li>Look through the data for recurring patterns (data mining)</li>
    <li>Present a summary of the data to highlight features (analytics)</li>
    <li>(Less commonly) Identify automatically from the dataset what's happening in the real world (situation recognition)</li>
</ul>
There's a wealth of <a href="http://data.gov.uk/" target="_blank">UK government data available</a>, for example. Making it machine-readable means it can be presented in different ways, for example <a href="http://www.telegraph.co.uk/news/uknews/crime/8294450/Crime-maps-are-just-the-beginning.html" target="_blank">geographically</a>. The real opportunities seem to come from cross-overs between datasets, though, where they can be mined and manipulated to find relationships that might otherwise remain hidden, for example the effects of crime on house prices.

Although the size and availability of datasets clearly makes a difference here -- big open data -- we might be confusing two issues. In some circumstances we might be better looking for smaller but richer datasets, and for richer connections between them.

<em>Big data</em> is a strange name to start with: when is data "big"? The only meaningful definition I can think of is "a dataset that's large relative to the current computing and storage capacity being deployed against it" -- which of course means that big data has always been with us, and indeed always will be. It also suggests that data might become less "big" if we become sufficiently interested in it to deploy more computing power to processing it. The alternative term popular in some places, <em>data science</em>, is equally tautologous, as I can't readily name a science that <em>isn't</em> based on data. (This isn't just academic pedantry, by the way: terms matter, if only to distinguish what topics are, and aren't, covered by big data/data science research.)

It's worth reviewing what big data lets us do. Having more data is useful when looking for patterns, since it makes the pattern stand out from the background noise. Those patterns in turn can reveal important processes at work in the world underlying the data, processes whose reach, significance, or even existence may be unsuspected. There may be patterns in the patterns, suggesting correlation or causality in the underling processes, and these can then be used for prediction: if pattern A almost always precedes pattern B in the dataset, then when I see a pattern A in the future I may infer that there's an instance of B coming. The statistical machine learning techniques that let one do this kind of analysis are powerful, but dumb: it still requires human identification and interpretation of the underlying processes to to conclude that A <em>causes</em> B, as opposed to A and B simply occurring together through some acausal correlation, or being related by some third, undetected process. A data-driven analysis won't reliably help you to distinguish between these options without further, non-data-driven insight.

Are there are cases in which less data is better? Our experience with situation recognition certainly suggests that this is the case. When you're trying to relate data to the the real world, it's essential to have <em>ground truth</em>, a record of what <em>actually</em> happened. You can then make a prediction about what the data indicates about the real world, and verify that this prediction is true or not against known circumstances. Doing this well over a dataset provides some confidence that the technique will work well against other data, where your prediction is all you have. In this case, what matters is not simply the size of the dataset, but its relationship to another dataset recording the actual state of the world: it's the <em>richness</em> that matters, not strictly the size (although having more data to train against is always welcome).

Moreover, rich connections may help with the more problematic part of data science, the identification of the processes underlying the dataset. While there may be no way to distinguish causality from correlation within a single dataset -- because they look indistinguishably alike -- the patterns of data points in the one dataset may often be related to patterns and data points in another dataset in which they <em>don't</em> look alike. So the richness provides a translation from one system to another, where the second provides discrimination not available in the first.

I've been struggling to think of an example of this idea, and this is the best I've come up with (and it's not all that good). Suppose we have tracking data for people around an area, and we see that person A repeatedly seems to follow person B around. Is A following B? Stalking them? Or do they live together, or work together (or even just close together)? We can distinguish between these alternatives by having a link from people to their jobs, homes, relationships and the like.

There's a converse concern, which is that poor discrimination can lead to the wrong conclusions being drawn: classifying person B as a potential stalker when he's actually an innocent who happens to follow a similar schedule. An automated analysis of a single dataset risks finding spurious connections, and it's increasingly the case that these false-positives (or -negatives, for that matter) could have real-world consequences.

Focusing on connections between data has its own dangers, of course, since we already know that we can make very precise classifications of people's actions from relatively small, but richly connected, datasets. Maybe the point here is that focusing exclusively on the size of a dataset masks both the advantages to be had from richer connections with other datasets, and the benefits and risks associated with smaller but better-connected datasets. Looking deeply can be as effective (or more so) as looking broadly.
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2013/07/26/improvements/" rel="bookmark">Friday 26 July, 2013</a>
			</span>
		    </div>
		    <h1><a href="../2013/07/26/improvements/">Some improvements to SleepySketch</a></h1>
		</div>
		<div class="entry-content">
			<p>It's funny how even early experiences change the way you think about a design. Two minor changes to SleepySketch have been suggested by early testing.</p>
<!--more-->

<p>The first issue is obvious: milliseconds are a really inconvenient way to think about timing, especially when you're planning on staying asleep for long periods. A single method in SleepySketch to convert from more programmer-friendly days/hours/minutes/seconds times makes a lot of difference.</p>
<p>The second issue concerns scheduling -- or rather regular
scheduling. Most sampling and communication tasks occur on predictable
schedules, say every five hours. In an <a href="../2013/06/01/actor-systems/" target="_blank">actor
framework</a>, that means the actor instance (or another one) has to
be re-scheduled after the first has run. We can do this within the
definition of the actor, for example using the <code>post()</code>
action:</p>
<div class="code"><pre class="code literal-block"><span class="n">class</span><span class="w"> </span><span class="n">PeriodicActor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">public</span><span class="w"> </span><span class="n">Actor</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="nf">post</span><span class="p">();</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="nf">behaviour</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="kt">void</span><span class="w"> </span><span class="n">PeriodicActor</span><span class="o">::</span><span class="n">post</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">scheduleIn</span><span class="p">(</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">expandTime</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<p>(This also demonstrates the <code>expandTime()</code> function to re-schedule after 0 days and 5 hours, incidentally.) Simple, but bad design: we can't re-use <code>PeriodicActor</code> on a different schedule. If we add a variable to keep track of the repeating period, we'd be mixing up "real" behaviour with scheduling; more importantly, we'd have to do that for <em>every</em> actor that wants to run repeatedly.</p>
<p>A better way is to use an actor combinator that takes an actor and a period and creates an actor that runs first re-schedules the actor to run after the given period, and then runs the underlying actor. (We do it this way so that the period isn't affected by the time the actor actually takes to run.)</p>
<div class="code"><pre class="code literal-block"><span class="n">Actor</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">RepeatingActor</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">SomeActor</span><span class="p">(),</span><span class="w"> </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">expandTime</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">));</span>
<span class="n">Sleepy</span><span class="p">.</span><span class="n">scheduleIn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">expandTime</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span>
</pre></div>

<p>The <code>RepeatingActor</code> runs the behaviour of
<code>SomeActor</code> every 5 hours, and we initially schedule it to
run in 5 hours. We can actually encapsulate all of this by adding a
method to <code>SleepySketch</code> itself:</p>
<div class="code"><pre class="code literal-block"><span class="n">Sleepy</span><span class="p">.</span><span class="n">scheduleEvery</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">SomeActor</span><span class="p">(),</span><span class="w"> </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">expandTime</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">));</span>
</pre></div>

<p>to perform the wrapping and initial scheduling automatically.</p>
<p>Simple sleepy sketches can now be created at set-up, by scheduling
repeating actors, and we can define the various actors and re-use them
in different scheduling situations without complicating their own
code.</p>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2013/07/26/radio-survey/" rel="bookmark">Friday 26 July, 2013</a>
			</span>
		    </div>
		    <h1><a href="../2013/07/26/radio-survey/">Radio survey</a></h1>
		</div>
		<div class="entry-content">
			<p>A simple radio survey establishes the ranges that the radios can manage.</p>
<!--more-->

<p>The 2mW XBee radios we've got have a nominal range of 100m -- but that's in free air, with no obstructions like bushes, ditches, and houses, and not when enclosed in a plastic box to protect them from the elements. There's a reasonable chance that these obstacles will reduce the real range significantly.</p>
<p><img alt="Arduino, radio, batteries, and their enclosure in the field (literally)" src="../images/citizen-sensing/sensor-enclosure.jpg"></p>
<p>A radio survey is fairly simple to accomplish. We load software that talks to a server on the base station -- something as simple as possible, like sending a single packet with a count every ten seconds -- and keep careful track of the return values coming back from the radio library. We then use the only output device we have -- an LED -- to indicate the success or failure of each operation, preferably with an indication of <em>why</em> it failed if it did. (Three flashes for unsuccessful transmission, five for no response received, and so forth.) We then walk away from the base station, watching the behaviour of the radio. When it starts to get errors, we've reached the edge of the effective range.</p>
<p>With two sensor motes, we can also check wireless mesh networking. If we place the first mote in range of the base station, we should then be able to walk further and have the second mote connect <em>via</em> the first, automatically. That's the theory, anyway...</p>
<p>(One extra thing to improve robustness: if the radios lose connection or get power-cycled, they can end up on a different radio channel to the co-ordinator. To prevent this, the radio needs to have an ATJV1 command issued to it. The easiest way to do this is at set-up, <a href="../2013/07/02/xctu/" target="_blank">through the advanced settings in X-CTU</a>.)</p>
<p>The results are fairly unsurprising. In an enclosure, in the field, with a base station inside a house (and so behind double glazing and suchlike) the effective range of the XBees is about 30--40m -- somewhat less than half the nominal range, and not really sufficient to reach the chosen science site: another 10--20m would be fine. On the other hand, the XBees mesh together seamlessly: taking a node out of range and placing another between it and the base station connects the network with no effort.</p>
<p>This is somewhat disappointing, but that's what this project is all about: the practicalities of sensor networking with cheap hardware.</p>
<p>There are several options to improve matters. A higher-powered radio would help: the 50mW XBee has a nominal range of 1km and so would be easily sufficient (and could probably be run at reduced transmission power). A router node halfway between base station and sensors could extend the network, and the cost of an additional non-sensing component. Better antennas on the 2mW radios might help too, especially if they could be placed outside the enclosure.</p>
<p>It's also worth noting that the radio segment is horrendously hard to debug with only a single LED for signalling. Adding more LEDs might help, but it's still a very poor debugging interface, even compared to printing status messages to the USB port.</p>
		</div>
	    </article>
</div>
	<div class="site-content">
	    <article class="format-standard libretto-long-form"><div class="title-block post-format-icon-pin">
		    <div class="entry-meta">
			<span class="posted-on">
			    Posted on <a href="../2013/07/25/sleepy-sketches/" rel="bookmark">Thursday 25 July, 2013</a>
			</span>
		    </div>
		    <h1><a href="../2013/07/25/sleepy-sketches/">Sleepy sketches</a></h1>
		</div>
		<div class="entry-content">
			<p>Keeping the microcontroller asleep as much as possible is a key goal for a sensor system, so it makes sense to organise the entire software process around that.

<!--more-->

The standard Arduino software model is, well, standard: programs ("sketches") are structured in terms of a <code>setup()</code> function that runs once when the system restarts and a <code>loop()</code> function that is run repeatedly. This suggests that the system spends its time running, which possibly isn't all that desirable: a sensor system typically tries to <a href="../2013/07/25/sleepy-sketches/2013/07/23/arduino-watchdog">stay in a low-power mode</a> as much as possible. The easiest way to do this is to provide a programming framework that handles the sleeping, and where the active bits of the program are scheduled automatically.

There are at least two ways to do this. The simplest is a library that lets <code>loop()</code> sleep, either directly or indirectly. This is good for simple programs and not so good for more complicated ones, as it means that <code>loop()</code> encapsulates all the program's logic in a single block. A more modern and compositional approach is to let program fragments request when they want to run somehow, and have a scheduler handle the sleeping, waking up, and execution of those fragments. That lets (for example) one fragment decide at run-time to schedule another

If we adopt this approach,we have to worry about the fact that one fragment might lock-out another. A desktop system might use threads; this is more problematic for a microcontroller, but an alternative is to force all fragments to only execute for a finite amount of time, so that the scheduler always gets control back. This might lead to a fragment not running when it asked (if other fragments were still running), but if we assume that the system spends most of its time asleep anyway, there will be plenty of catch-up time. Doing this results in an <a href="../2013/06/01/actor-systems/">actor system</a> where the fragments are actors that are scheduled from an actor queue.

Turning this into code, we get the <code>SleepySketch</code> library: a library for building Arduino sketches that spend most of their time sleeping.

![SleepySketch design](/images/citizen-sensing/sleepysketch.png)

There are a few wrinkles that need to be taken care of for running on a resource-constrained system. Firstly, the number of actors available is fixed at start-up (defaulting to 10), so that we can balance RAM usage.(With only 2k to play with, we need to be careful). Secondly, we use a class to manage the sleeping functionality in different ways: a <code>BusySleeper</code> that uses the normal <code>delay()</code> function (a busy loop) with no power-saving functions, a <code>HeavySleeper</code> that uses the watchdog timer to shut the system down as far as possible, and possibly some other intermediate strategies. Actors are provided by sub-classing the <code>Actor</code> class and providing a behaviour. We also allow pre- and post-behaviour actions to define families of actors, for example sensor observers. We separate the code for an actor from its scheduling.

The standard library uses singleton classes quite a lot, so for example the <code>Serial</code> object represents the USB connection from an Arduino to its host computer and is the target for all methods. We use the same approach and define a singleton, <code>Sleepy</code>

The program structure then loops something like this. If we assume
that we've defined an actor class <code>PingActor</code>, then we can
do the following:


</p>
<div class="code"><pre class="code literal-block"><span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>
<span class="w">   </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">HeavySleeper</span><span class="p">());</span>

<span class="w">   </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">scheduleIn</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">PingActor</span><span class="p">(</span><span class="s">"Ping!"</span><span class="p">),</span><span class="w"> </span><span class="mi">10000</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>



The <code>setup()</code> code initialises the serial port and the sleepy sketch using a <code>HeavySleeper</code>, and then schedules an actor to run in 10000ms. The loop() code runs the actors while there are actors remaining to schedule. If the <code>PingActor</code> instance just prints its message, then there will be no further actors to execute and the program will end; alternatively the actor could schedule further actors to be run later, and the sketch will pick them up. The sketch will remain asleep for as long as possible (probably for over 9s between start-up and the first ping), allowing for some fairly significant power saving.

This is a first design, now just about working. It's still not as easy
as it could be, however, and needs some testing to make sure that the
power savings do actually materialise.
		</div>
	    </article>
</div>
    <!-- Lower Navigation links -->
    <nav class="site-content navigation-post" role="navigation"><div class="previous">
		<a href="index-45.html" rel="prev">
		    <span class="meta-nav">Older Entries</span>		</a>
	    </div>
	    <div class="next">
		<a href="index-47.html" rel="next">
		    <span class="meta-nav">Newer Entries</span>		</a>
	    </div>
    </nav><!-- Page Footer --><section class="footer-sidebar clear" role="complementary"><div class="widget-block">
	    <aside class="widget"><h2 class="widget-title">Simon Dobson</h2>
		<div class="widget-text">Aut tace aut loquere meliora silentio</div>
	    </aside>
</div>
    </section><!-- Extra JavaScript --><!-- Site Attributions --><footer class="site-footer" role="contentinfo"><div class="site-info">
	    <p></p>
	    <p>
	      Built with free and open-source software.
	      Powered by <a href="https://getnikola.com/">Nikola</a> using a theme based on
	      <a href="https://note2self.abraham-v.com/libretto-theme-for-nikola/">Libretto</a>.
	    </p>
	    <p>
	      All content licensed under
	      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC-BY-NC-SA-4.0</a>
	      unless otherwise noted.
	    </p>
	</div>
	<div class="social">
	    <ul class="menu"></ul>
</div>
    </footer>
</body>
</html>
