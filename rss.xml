<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson</title><link>https://simondobson.org/</link><description>Aut tace aut loquere meliora silentio</description><atom:link href="https://simondobson.org/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Sat, 03 Aug 2024 18:58:47 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Build: An Unorthodox Guide to Making Things Worth Making</title><link>https://simondobson.org/goodreads/build-an-unorthodox-guide-to-making-things-worth-making/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1652120231l/59696349._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Tony Fadell
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      Twenty-five years ago, more or less, I ran a start-up company. I wish books like this had existed back then to help me understand what start-ups need to do.&lt;br&gt;&lt;br&gt;Fadell has perhaps the best pedigree imaginable, including being involved both in massive successes (the iPod, the iPhone, the Nest thermostat) and crashing failures (General Magic), and the best thing about this book is his willingness to share them, warts and all. He's clearly come to a place in his life where he regards everything as a learning opportunity and a teaching opportunity, rather than needing to project a particular image of himself.&lt;br&gt;&lt;br&gt;The business advice is fascinating, even for someone who doesn't intend to start a company: there's plenty to learn about organisation structures and politics. I suspect it'd be absolute gold for anyone thinking of making hardware devices for the modern software-dominated world, though. Fadell has a clear understanding of what's needed to make a physical product succeed, and his emphases on story-telling and understanding the customer's journey as a route to success are compelling. &lt;br&gt;&lt;br&gt;There's also a lot of insight into some of the major companies and personalities he's met along the way. He's positive about Apple, clear-eyed about Steve Jobs' strengths and weaknesses – and clearly quite shell-shocked by his exposure to Google as not what he was expecting them to be.
      &lt;/p&gt;&lt;p&gt;
	5/5.
	  Finished Saturday 3 August, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6567722144?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/build-an-unorthodox-guide-to-making-things-worth-making/</guid><pubDate>Sat, 03 Aug 2024 00:00:00 GMT</pubDate></item><item><title>SS-GB</title><link>https://simondobson.org/goodreads/ss-gb/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1689536758l/63326204._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Len Deighton
	  (1979)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      An alternative history that has aged well. The premise is quite common: what if Nazi Germany had invaded Britain in the Spring of 1941, and succeeded? The plot revolves around rescuing the King and retrieving atomic secrets, both to be sent to America.&lt;br&gt;&lt;br&gt;But it's the politics of a Nazi occupation that clearly most fascinated Deighton, because he build a labyrinth of plots and counter-plots between Army, SS, British Resistance, and American isolationism. These internecine struggles are actually quite familiar from the actual history of Nazi occupations, so it's quite fascinating to see them transplanted to a fictional Britain. It's so well done that it's a shame it isn't part of a series (of which Deighton wrote several).
      &lt;/p&gt;&lt;p&gt;
	4/5.
	  Finished Saturday 3 August, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6432286432?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/ss-gb/</guid><pubDate>Sat, 03 Aug 2024 00:00:00 GMT</pubDate></item><item><title>Metacircular Semantics for Common Lisp Special Forms</title><link>https://simondobson.org/2024/08/02/metacircular-semantics-for-common-lisp-special-forms/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org003e69b" class="outline-2"&gt;
&lt;h2 id="org003e69b"&gt;Metacircular Semantics for Common Lisp Special Forms&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org003e69b"&gt;
&lt;p&gt;
Henry G. Baker. &lt;i&gt;&lt;a href="https://doi.org/10.1145/382126.382662"&gt;Metacircular Semantics for Common Lisp Special Forms&lt;/a&gt;&lt;/i&gt;.
ACM SIGPLAN Lisp Pointers &lt;b&gt;V&lt;/b&gt;, pp.11–20. 1992.
&lt;/p&gt;

&lt;p&gt;
A response to the criticisms of McCarthy's semantics for Common
Lisp that it didn't specify the behaviours of special forms, and
of the standardisation process of adopting prose definitions that
are too "lawyerly" for engineering.
&lt;/p&gt;

&lt;p&gt;
The approach is to define the special forms in terms of other
constructions, for example &lt;code&gt;if&lt;/code&gt; in terms of nested lambda
abstractions to prevent execution of the unwanted branch. This is
both useful for understanding and a way of minimising the number
of under-defined special forms.
&lt;/p&gt;

&lt;p&gt;
It suggests treating &lt;code&gt;catch&lt;/code&gt; / &lt;code&gt;throw&lt;/code&gt; as basic, both because other
control-transfer forms can be expressed sing them and because it
emphasises the interactions that preclude Common Lisp having
continuations like Scheme's. However there's also an argument
pursued that some other structures (like &lt;code&gt;values&lt;/code&gt;) provide extra
information that can be useful for compilers looking to optimise.
It's a deep exploration of the underpinnings of the language from
both theoretical and practical perspectives.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><category>semantics</category><guid>https://simondobson.org/2024/08/02/metacircular-semantics-for-common-lisp-special-forms/</guid><pubDate>Fri, 02 Aug 2024 10:29:45 GMT</pubDate></item><item><title>Casting SPELs in Lisp</title><link>https://simondobson.org/2024/08/02/casting-spels-in-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org8bdeee5" class="outline-2"&gt;
&lt;h2 id="org8bdeee5"&gt;Casting SPELs in Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8bdeee5"&gt;
&lt;p&gt;
&lt;a href="https://www.lisperati.com/casting.html"&gt;https://www.lisperati.com/casting.html&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A tongue-in-cheek – but still excellent – comicbook-style
introduction to Lisp programming. (There's also a version
&lt;a href="https://www.lisperati.com/casting-spels-emacs/html/casting-spels-emacs-1.html"&gt;specifically for Emacs Lisp&lt;/a&gt;.) It's structured around building an
adventure-style game, which as well as being a classic also offers
lots of opportunities for exploring different data structures and
algorithms: one can easily imagine expanding it to include (for
example) an AI second player or autonomous non-player characters
and gradually building a really complicated application from a
standing start.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/08/02/casting-spels-in-lisp/</guid><pubDate>Fri, 02 Aug 2024 10:25:53 GMT</pubDate></item><item><title>My mental model of setf was wrong</title><link>https://simondobson.org/2024/07/27/my-mental-model-of-setf-was-wrong/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org304e782" class="outline-2"&gt;
&lt;h2 id="org304e782"&gt;My mental model of setf was wrong&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org304e782"&gt;
&lt;p&gt;
I realised recently that I've been thinking about &lt;code&gt;setf&lt;/code&gt; all wrong.
&lt;/p&gt;

&lt;p&gt;
Lisp lets programs define new &lt;code&gt;setf&lt;/code&gt; forms for assignment. The most
common example is from CLOS, where a class like this:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defclass&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ss"&gt;:accessor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a-var&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
will give rise to a class and two functions, &lt;code&gt;a-var&lt;/code&gt; to read the
value of the &lt;code&gt;var&lt;/code&gt; slot on an instance of &lt;code&gt;A&lt;/code&gt;, and a &lt;code&gt;setf&lt;/code&gt; target used
as &lt;code&gt;(setf (a-var instance) 24)&lt;/code&gt; to set the &lt;code&gt;var&lt;/code&gt; slot of &lt;code&gt;instance&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
It's natural to read that like as executing &lt;code&gt;(a-var instance)&lt;/code&gt; to
retrieve a location, and &lt;code&gt;setf&lt;/code&gt; using this location to assign to.
The documentation reinforces this view, talking about
"generalised places" as the targets for &lt;code&gt;setf&lt;/code&gt; to store things. My
mental model was strengthened by idioms like &lt;code&gt;(setf (car pair) 23)&lt;/code&gt;
to set the car of a pair or list, and &lt;code&gt;(setf (cdr pair) '(1 2 3)&lt;/code&gt;
to set the cdr. The first argument is a &lt;i&gt;locator&lt;/i&gt; expression
returning the place to update, and the second argument is the &lt;i&gt;new
value&lt;/i&gt; to put there.
&lt;/p&gt;

&lt;p&gt;
Natural. But wrong.
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
The thing I missed is that &lt;code&gt;setf&lt;/code&gt; is a &lt;i&gt;macro&lt;/i&gt;: it can access the
&lt;i&gt;structure&lt;/i&gt; of its arguments but not their &lt;i&gt;values&lt;/i&gt;. You can't write
code like this:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;h&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;h&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
and expect the &lt;code&gt;car&lt;/code&gt; of &lt;code&gt;l&lt;/code&gt; to be updated, which would make sense if
&lt;code&gt;setf&lt;/code&gt; were working on a location, because &lt;code&gt;h&lt;/code&gt; would be that
location. But it isn't.
&lt;/p&gt;

&lt;p&gt;
What actually happens is that the &lt;code&gt;setf&lt;/code&gt; macro looks, at compile
time, at the structure of its first (locator) argument, and uses
that to dispatch to a method. Using the slot accessor above, the
&lt;code&gt;setf&lt;/code&gt; form expands to something like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a-var&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;slot-value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'a-var&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This is a method with two pieces of selection: specialised on the
type of an argument (&lt;code&gt;A&lt;/code&gt;), and named with the &lt;i&gt;selector&lt;/i&gt; used to
within the locator (&lt;code&gt;a-var&lt;/code&gt;). It's definition expands to &lt;i&gt;another&lt;/i&gt;
&lt;code&gt;setf&lt;/code&gt;, this time specialised against &lt;code&gt;slot-value&lt;/code&gt; and an instance of
&lt;code&gt;standard-object&lt;/code&gt;. Specialising on the selector explains why we
need that selector to be present syntactically at compile time.
&lt;/p&gt;

&lt;p&gt;
My mistake was thinking that the similarity between access form
and &lt;code&gt;setf&lt;/code&gt; form was necessary and functional – and it isn't
either. This has some interesting consequences.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org598a20d" class="outline-3"&gt;
&lt;h3 id="org598a20d"&gt;The selector is entirely arbitrary&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org598a20d"&gt;
&lt;p&gt;
If we don't like using &lt;code&gt;car&lt;/code&gt; to indicate the head of a list – and
some people don't – we could in principle define a new
specialisation such as:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rplaca&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
and use it as &lt;code&gt;(setf (head l) 45)&lt;/code&gt; &lt;i&gt;even though &lt;code&gt;head&lt;/code&gt; isn't a
defined function&lt;/i&gt;. All we need is a selector symbol.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd341b0f" class="outline-3"&gt;
&lt;h3 id="orgd341b0f"&gt;There can be more arguments&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd341b0f"&gt;
&lt;p&gt;
Ever since I first encountered them I wondered why the lambda
lists for new &lt;code&gt;setf&lt;/code&gt; specialisations was so strange: the new value
and &lt;i&gt;then&lt;/i&gt; the arguments – but not the selector – of the place to
be updated? Once you get a better mental model, the reason
becomes obvious: there can be &lt;i&gt;multiple&lt;/i&gt; arguments to the &lt;code&gt;setf&lt;/code&gt;
locator, possibly actually a variable number, alongside the
selector, so we need to be able to find the new value reliably.
The easiest way is to put it at the front of the lambda list.
&lt;/p&gt;

&lt;p&gt;
There's actually a common example of this sitting in plain sight
that I'd missed. You access the elements of a Lisp array using
the &lt;code&gt;aref&lt;/code&gt; function, which takes the array and the index, such as
(&lt;code&gt;aref a 23)&lt;/code&gt;. The corresponding &lt;code&gt;setf&lt;/code&gt; form looks like &lt;code&gt;(setf (aref
     a 23) 0)&lt;/code&gt;, with the locator taking several arguments like the
function. &lt;i&gt;But it isn't calling the function&lt;/i&gt;: it's decomposing a
pattern that &lt;i&gt;looks exactly like&lt;/i&gt; the function call for
convenience, and which passes several arguments to the
specialised method that will look something like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;aref&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The new value is reliably in the first argument position, with
the rest of the locator arguments after it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd7988ba" class="outline-3"&gt;
&lt;h3 id="orgd7988ba"&gt;You can specialise by value too&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd7988ba"&gt;
&lt;p&gt;
Since the &lt;code&gt;setf&lt;/code&gt; forms are just methods, you could if you wanted to
specialise them on the type of the new value as well as on the
locator. As a trivial example:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;assign-head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"Assigned an integer ~s"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;assign-head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"Assigned a string ~s"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;assign-head&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"zero"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Assigned a string "zero"
&lt;/pre&gt;


&lt;p&gt;
Obviously there are better ways to do this, but it's a good
example of the flexibility that comes from &lt;code&gt;setf&lt;/code&gt; not really being
all that special a form at all: just a creative use of the power
of generic functions.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb382c77" class="outline-3"&gt;
&lt;h3 id="orgb382c77"&gt;Can we build our own &lt;code&gt;setf&lt;/code&gt;-like macros?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb382c77"&gt;
&lt;p&gt;
Yes: &lt;code&gt;setf&lt;/code&gt; is entirely constructable within "ordinary" Lisp.
&lt;/p&gt;

&lt;p&gt;
There are two parts to the construction. Firstly, we need the
name of the method that underlies a particular selector.
&lt;/p&gt;

&lt;p&gt;
We can build our own functions with names like this, although not
using &lt;code&gt;defun&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defvar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;*weird-name*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"(1 2 3)"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;*weird-name*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"We did *weird-name* on ~s"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;*weird-name*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"a string"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;

"We did *weird-name* on \"a string\""
&lt;/pre&gt;


&lt;p&gt;
For &lt;code&gt;setf&lt;/code&gt;, the style of name used for the methods implementing the
different choices is &lt;code&gt;(setf selector)&lt;/code&gt; – a function named by a
list – where &lt;i&gt;selector&lt;/i&gt; is the symbol at the head of locator list.
(Some Lisps construct a symbol from the list elements, rather
than using it directly. I'm not sure what, if anything, the
Common Lisp language definition says about how this should work.)
&lt;/p&gt;

&lt;p&gt;
For the second part of the construction, &lt;code&gt;setf&lt;/code&gt; takes the locator,
synthesises the function name symbol using the selector, and
calls a generic function with this name, passing the new value
and the rest of the locator as arguments.
&lt;/p&gt;

&lt;p&gt;
So to define a new construct &lt;code&gt;our-setf&lt;/code&gt; we might do something like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmacro&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;our-setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;locator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;new-value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;selector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;locator&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;our-setf-function-name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"(our-setf ~a)"&lt;/span&gt;
&lt;span class="w"&gt;                                                           &lt;/span&gt;&lt;span class="nv"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;our-setf-function-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;new-value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;locator&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When called as something like &lt;code&gt;(our-setf (head '(1 2 3)) 0)&lt;/code&gt; the
macro will code to call a method &lt;code&gt;(our-setf head)&lt;/code&gt; (as a symbol),
passing it (&lt;code&gt;0 '(1 2 3))&lt;/code&gt; as arguments and allowing the machinery of
generic functions to determine which method is actually called.
We define these methods of the form &lt;code&gt;(our-setf head)&lt;/code&gt; and specialise
them as required.
&lt;/p&gt;

&lt;p&gt;
(It's actually a bit more complicated than this because we need
to define a generic function for &lt;code&gt;(our-setf head)&lt;/code&gt;. We have to go
backstage and programmatically define the generic function. But
the idea remains the same.)
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
After all this, my mental model of &lt;code&gt;setf&lt;/code&gt; is a lot clearer – and,
I hope, closer the reality at least. It combines a highly
structured use of macros, synthesised function names, and generic
functions – and no special machinery at all.
&lt;/p&gt;

&lt;p&gt;
However, there's some subtlety at play too, not obvious at first
acquaintance. We don't want our synthesised function names to
accidentally capture the names of user-supplied code. It's
possible that using a naming style like &lt;code&gt;setf-car&lt;/code&gt; would do just
this, and a program happens to define a function with this name.
But the names &lt;code&gt;setf&lt;/code&gt; synthesises are &lt;i&gt;lists&lt;/i&gt;, unlikely to be captured
accidentally, which lets us define the specialised methods "as
normal" even though some of the other parts of the process have
to happen backstage.
&lt;/p&gt;

&lt;p&gt;
This shows the power of macros and generic functions. It also
shows how deeply the latter are embedded into Lisp. They're
usually thought of as part of CLOS, but they actually have little
explicit relationship to class and objects at all, and have been
woven all through Lisp to build flexible code structures.
&lt;/p&gt;

&lt;p&gt;
UPDATED 2023-07-30: I incorrectly said originally that one
couldn't use forms like &lt;code&gt;(defun (setf abc) ...)&lt;/code&gt;: you can, just as
with &lt;code&gt;defmethod&lt;/code&gt; and &lt;code&gt;defgeneric&lt;/code&gt;, and name a function using a list.
Thanks to Hacker News contributor &lt;a href="https://phoe.github.io"&gt;phoe-krk&lt;/a&gt; for correcting me. I
was also slightly loose in my use of &lt;i&gt;specialisation&lt;/i&gt;, which I've
tightened up.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>macroprogramming</category><category>programming</category><guid>https://simondobson.org/2024/07/27/my-mental-model-of-setf-was-wrong/</guid><pubDate>Sat, 27 Jul 2024 13:29:18 GMT</pubDate></item><item><title>The art of the metaobject protocol</title><link>https://simondobson.org/2024/07/23/the-art-of-the-metaobject-protocol/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org7c8dd92" class="outline-2"&gt;
&lt;h2 id="org7c8dd92"&gt;The art of the metaobject protocol&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7c8dd92"&gt;
&lt;p&gt;
Gregor Kiczales, Jim des Rivières, and Daniel Bobrow.  &lt;i&gt;The Art of the
Metaobject Protocol&lt;/i&gt;. MIT Press. 1991.
&lt;/p&gt;


&lt;p&gt;
What &lt;i&gt;is&lt;/i&gt; a meta-object protocol? – or indeed a meta-object? This
book is perhaps the clearest exposition of these ideas.
&lt;/p&gt;

&lt;p&gt;
In most modern object-oriented languages an object is an instance
of a class. In keeping with using objects throughout, classes are
often also objects (or can be thought of as such), but are more
informatively thought of as &lt;b&gt;meta-objects&lt;/b&gt; that to facilitate the
construction of "real" objects. The methods on classes can also be
thought of as meta-objects defining the code executed by the
objects when invoked.
&lt;/p&gt;

&lt;p&gt;
The defining feature of CLOS is that these meta-objects are all
just Lisp objects, but objects that exist "off-stage" (to use this
book's very intuitive metaphor) and largely invisible to a basic
user. But they're as available to a power user as any other
objects: the "meta"-ness is a matter of design, not of
implementation. The interactions between objects and meta-objects,
for example which methods are called when invoked on a particular
object, are defined by the meta-object protocol (MOP), which is
itself defined in terms of methods on the meta-objects that shadow
the objects themselves.
&lt;/p&gt;

&lt;p&gt;
(Meta-object &lt;i&gt;protocol&lt;/i&gt; uses a term common in a lot of the earlier
object-oriented literature to mean a collection of functions:
meta-object &lt;i&gt;API&lt;/i&gt; would be a more modern rendering, although the
protocol includes the sequencing of API calls and their
relationships.)
&lt;/p&gt;

&lt;p&gt;
The goal of MOP programming is to let the programmer extend the
programming language towards to application domain, by automating
a lot of boilerplate code and providing the structures needed to
re-structure or analyse the code the programmer actually needs to
write. In this sense it's a continuation of the idea of macros as
powerful and potentially very domain-specific language and
compiler extensions. It's also a continuation of reifying
underlying language mechanisms in the language itself where they
can be re-specified and re-mixed.
&lt;/p&gt;

&lt;p&gt;
The first part of the book explains MOPs by defining a slightly
simplified version of CLOS ("Closette"). It assumes the reader
knows some CLOS, for example from &lt;a href="/2024/07/23/object-oriented-programming-on-common-lisp-a-programmer1s-guide-to-clos/"&gt;Object-oriented
programming on Common Lisp: A programmer's guide to CLOS&lt;/a&gt; (or
there's a stand-alone introduction in Appendix A), but it &lt;i&gt;only&lt;/i&gt;
assumes the knowledge level of a relative newcomer – and the
features then defined in Closette are just those parts of CLOS
that such a user would actually know and be comfortable with,
which is a brilliant piece of pedagogy that simplifies without
trivialising. It's really noticeable that Closette doesn't need
any extensions to Common Lisp: it's defined directly in the
language itself, which shows how powerful the underlying language
is. (Full CLOS requires a bit of language support too, at least
for efficiency.)
&lt;/p&gt;

&lt;p&gt;
Next come several examples of MOP usage, for example to re-define
how classes store their slots, or how to add attributes to slots
that can store metadata about their use or could be used to
provide higher-level operations. There's also a long discussion
about protocol design and how this has a massive impact on how
easy a system is to use for the programmer.
&lt;/p&gt;

&lt;p&gt;
The second part is a manual for the CLOS MOP, which is thorough
and useful, but perhaps less exciting than the first part. The
Common Lisp package &lt;a href="https://github.com/pcostanza/closer-mop"&gt;closer-mop&lt;/a&gt; provides this API as a
portable compatibility layer for use in real programs.
&lt;/p&gt;

&lt;p&gt;
There's also a discussion of practicalities like where awkward
circularities occur and how to break them, which is actually a
great example how to do good protocol/API design. In an example of
&lt;a href="/2024/07/23/the-roots-of-lisp/"&gt;Paul Graham's dictum&lt;/a&gt; that modern languages evolve by mixing Lisp
concepts into a different base, MOP ideas appear in lots of other
languages, either for real (Smalltalk, at to a lesser extent
&lt;a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/"&gt;Python&lt;/a&gt;) or just for introspection (Java). Even someone not
planning on writing Lisp would benefit from reading this book just
to see the ideas in their full generality.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>oo</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/23/the-art-of-the-metaobject-protocol/</guid><pubDate>Tue, 23 Jul 2024 08:13:16 GMT</pubDate></item><item><title>Object-oriented programming on Common Lisp: A programmer's guide to CLOS</title><link>https://simondobson.org/2024/07/23/object-oriented-programming-on-common-lisp-a-programmer1s-guide-to-clos/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org1c558c9" class="outline-2"&gt;
&lt;h2 id="org1c558c9"&gt;Object-oriented programming on Common Lisp: A programmer's guide to CLOS&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1c558c9"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/41/584da1-ef33-41dd-8091-43c3999f6451/clos.jpg" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Sonja Keene.  &lt;i&gt;Object-Oriented Programming in Common Lisp: A
Programmer’s Guide to CLOS&lt;/i&gt;. Addison-Wesley. ISBN 0-201-17589-4. 1989.
&lt;/p&gt;

&lt;p&gt;
The definitive practical guide to using the Common Lisp Object
System (CLOS). It's written from a similar perspective to other
object-oriented tutorials, which makes it very accessible for
those who've had experience with something like Java or Python.
However, CLOS &lt;i&gt;isn't&lt;/i&gt; just objects in Lisp, and &lt;i&gt;isn't&lt;/i&gt; in any sense
just an object-oriented extension. It can take some time to change
mindset enough to use it properly, and this book is a great guide
to the core differences.
&lt;/p&gt;

&lt;p&gt;
Firstly, it follows a completely different model of how to
associate functions with data. Instead CLOS uses "generic"
functions, where the exact code called is dispatched dynamically
based on the types of any or all parameters: so it's perfectly
possible to have several definitions of the &lt;i&gt;same&lt;/i&gt; generic function
operating on objects of the &lt;i&gt;same&lt;/i&gt; class, but taking arguments of
&lt;i&gt;different&lt;/i&gt; types. This &lt;i&gt;multiple dispatch&lt;/i&gt; is a lot more flexible.
&lt;/p&gt;

&lt;p&gt;
The second point actually follows from this. CLOS' generic
functions can be defined to &lt;i&gt;any&lt;/i&gt; Lisp types: in fact they're not
statically associated with classes at all, and can operate on &lt;i&gt;any&lt;/i&gt;
types (classes or not) across the type hierarchy. This makes it
closer to Haskell's type classes than to Smalltalk's (or Java's)
virtual methods, which are strongly bound to classes.
&lt;/p&gt;

&lt;p&gt;
Thirdly, CLOS methods can be combined in a range of interesting
ways, not simply by overriding previous definitions – and indeed
you can define your own if you need to. And like Smalltalk
(but unlike Java) CLOS classes have "metaclasses" that can
re-define their basic functions. &lt;a href="/2024/07/23/the-art-of-the-metaobject-protocol"&gt;The art of the metaobject protocol&lt;/a&gt;
is a better source for this level of detail.
&lt;/p&gt;

&lt;p&gt;
The examples in the book delve into these features by means of
sensibly-sized challenges that can be used to illustrate both
basic design and implementation. and more advanced ideas like
re-defining classes on the fly.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>oo</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/23/object-oriented-programming-on-common-lisp-a-programmer1s-guide-to-clos/</guid><pubDate>Tue, 23 Jul 2024 08:03:11 GMT</pubDate></item><item><title>The roots of Lisp</title><link>https://simondobson.org/2024/07/23/the-roots-of-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org0318c4d" class="outline-2"&gt;
&lt;h2 id="org0318c4d"&gt;The roots of Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0318c4d"&gt;
&lt;p&gt;
&lt;a href="http://www.paulgraham.com/rootsoflisp.html"&gt;http://www.paulgraham.com/rootsoflisp.html&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
(Only has an PostScript version, but a PDF is available
&lt;a href="https://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf"&gt;here&lt;/a&gt;.)
&lt;/p&gt;

&lt;p&gt;
Re-visits McCarthy's discoveries (or inventions, depending on
your point of view), translating the &lt;a href="/2024/03/07/recursive-functions-of-symbolic-expressions-and-their-computation-by-machine-part-i/"&gt;earliest work&lt;/a&gt; into modern
Lisp notation.
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
It's worth understanding what McCarthy discovered, not just as a
landmark in the history of computers, but as a model for what
programming is tending to become in our own time. It seems to me that
there have been two really clean, consistent models of programming so
far: the C model and the Lisp model. These two seem points of high
ground, with swampy lowlands between them. As computers have grown
more powerful, the new languages being developed have been moving
steadily toward the Lisp model. A popular recipe for new programming
languages in the past 20 years has been to take the C model of
computing and add to it, piecemeal, parts taken from the Lisp model,
like runtime typing and garbage collection.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
Does a great job of making the central insights accessible,
including re-phrasing the meta-circular Lisp interpreter so as to
be executable in modern Common Lisp.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/23/the-roots-of-lisp/</guid><pubDate>Tue, 23 Jul 2024 08:00:41 GMT</pubDate></item><item><title>TIL: The most powerful one-line program in the world</title><link>https://simondobson.org/2024/07/17/til-the-most-powerful-one-line-program-in-the-world/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge9df00b" class="outline-2"&gt;
&lt;h2 id="orge9df00b"&gt;TIL: The most powerful one-line program in the world&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge9df00b"&gt;
&lt;p&gt;
Well, the most powerful I've found so far, anyway.
&lt;/p&gt;

&lt;p&gt;
Given my current obsession with &lt;a href="/categories/lisp/"&gt;Lisp&lt;/a&gt; you might reasonably expect it
to be in that language. But it isn't: it's in &lt;a href="https://en.wikipedia.org/wiki/APL_(programming_language)"&gt;APL&lt;/a&gt;, and it performs
one complete generation of &lt;a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life"&gt;Conway' Game of Life&lt;/a&gt; in one line of code:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  Life←{↑↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
…and does so inexplicably to anyone who doesn't know APL,
obviously, but the &lt;a href="https://aplwiki.com/wiki/John_Scholes%27_Conway%27s_Game_of_Life"&gt;basic algorithm&lt;/a&gt; is simple:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Take an array with 1 in each occupied cell and 0 elsewhere&lt;/li&gt;
&lt;li&gt;Build four new arrays by exchanging each element with its
neighbour up, down, left, and right&lt;/li&gt;
&lt;li&gt;Sum these arrays, which places the number of neighbours into each cell&lt;/li&gt;
&lt;li&gt;Cut-off these values to be 1 if the cell has a value of 3 or 4,
and 0 otherwise&lt;/li&gt;
&lt;li&gt;Re-format the arrays back into the starting configuration&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
I checked it out using &lt;a href="https://www.gnu.org/software/apl/"&gt;GNU APL&lt;/a&gt; and it works fine.
&lt;/p&gt;

&lt;p&gt;
I discovered this gem by accident, actually implemented &lt;a href="https://github.com/chmykh/apl-life"&gt;in APL in
Forth&lt;/a&gt; where someone has developed APL as an embedded DSL within
&lt;a href="https://en.wikipedia.org/wiki/Forth_(programming_language)"&gt;Forth&lt;/a&gt; (another language with which I have history). After a bit of
digging I found a similar APL in Lisp, &lt;a href="https://github.com/phantomics/april"&gt;April&lt;/a&gt;, which clearly needs
exploring.
&lt;/p&gt;

&lt;p&gt;
In many ways APL and Lisp are parallel tracks within programming
language evolution, taking a single data structure (lists or arrays)
and providing powerful ways to manipulate them. Lisp of course has
been extended with other data structures, including arrays, which
makes the fusion of array- and list-based programming rather
attractive.
&lt;/p&gt;

&lt;p&gt;
I can't help asking myself what would have happened if APL hadn't
fallen by the wayside. (I think this was inevitable, incidentally,
once the syntax became fixed: any language that requires its own
character set was always going to struggle.) We now have huge
applications for array processing, from graphics to machine
learning, and GPUs are from one perspective just APL accelerator
co-processors. The ideas are still massively relevant.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>apl</category><category>programming</category><category>til</category><guid>https://simondobson.org/2024/07/17/til-the-most-powerful-one-line-program-in-the-world/</guid><pubDate>Wed, 17 Jul 2024 09:20:53 GMT</pubDate></item><item><title>Notes on Complexity: A Scientific Theory of Connection, Consciousness, and Being</title><link>https://simondobson.org/goodreads/notes-on-complexity-a-scientific-theory-of-connection-consciousness-and-being/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1673876917l/62686859._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Neil Theise
	  (2023)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      I'd heard a lot about this book, and expected a lot from it. Theise isn't the first writer get lost in quantum weirdness, and he won't be the last.&lt;br&gt;&lt;br&gt;The first half is a tour of complexity science, focusing on where the boundaries of complex systems lie: the "quenched disorder" threshold between static order and complete disorder, and the existence of emergent phase changes in systems constructed from lots of simple interactions. Lovelock's "daisyworld" is a great example of this, and Theise is very strong on assigning credit where it is due (Lynn Margulis' contributions are often overlooked). It's an approach that could be taken a lot further.&lt;br&gt;&lt;br&gt;But then it all goes wrong, lost in the mazes of quantum theory and its superficial compatibilities with various kinds of mysticism. But there are lots of different mystic systems, and choosing to focus on three that have been selected for their similarities with a naive interpretation of quantum mechanics tells us precisely nothing about reality: there are plenty of others that are entirely incompatible (including most mainstream religions), which suggests it's at least possible for mysticism and science to coincide by chance. And it's a category error to then try to reason &lt;i&gt;back&lt;/i&gt; from the mystic to the scientific in an attemot to "explain" complexity.&lt;br&gt;&lt;br&gt;This absolutely &lt;i&gt;isn't&lt;/i&gt; what it claims to be – a scientific theory of consciousness and connectedness – because it commits the fundamental error of being selective with the data. Just because we can't (yet) explain quantum entanglement and decoherence doesn't mean that panpsychism has anything to tell us about reality. This sort of "reconciliation" of science ("western") and mysticism ("eastern") isn't new, isn't informative, and (to my mind) does both a disservice.
      &lt;/p&gt;&lt;p&gt;
	1/5.
	  Finished Wednesday 17 July, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/5814381629?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/notes-on-complexity-a-scientific-theory-of-connection-consciousness-and-being/</guid><pubDate>Wed, 17 Jul 2024 00:00:00 GMT</pubDate></item></channel></rss>