<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson</title><link>https://simondobson.org/</link><description>Aut tace aut loquere meliora silentio</description><atom:link href="https://simondobson.org/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2025 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Fri, 31 Jan 2025 08:32:58 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Lisp: Style and design</title><link>https://simondobson.org/2025/01/31/lisp-style-and-design/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org07a794e" class="outline-2"&gt;
&lt;h2 id="org07a794e"&gt;Lisp: Style and design&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org07a794e"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/da/4751c9-60cc-4acc-bfd3-ad7d50aa536a/lisp-style-design.jpg" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Molly Miller and Eric Benson. &lt;i&gt;Lisp: Style and Design&lt;/i&gt;. Digital Press.
ISBN 978-0135384220. 1990.
&lt;/p&gt;

&lt;p&gt;
A book that would serve as a primer for someone tackling a
significant piece of programming for the first time.
&lt;/p&gt;

&lt;p&gt;
The style is a bit stiff and occasionally slightly patronising,
definitely positioned as being from senior to junior programmers.
The depth of the material is variable: I found the treatment of
macros quite superficial, not helped by the examples generating
questionable code. It also places relatively little emphasis on
CLOS and generic functions, which would get more space in a more
modern treatment..
&lt;/p&gt;

&lt;p&gt;
The best chapters are those on debugging and (especially)
performance engineering, which dig into the interactive tools
generally available within Lisp and give a good end-to-end
description of the use of &lt;code&gt;declare&lt;/code&gt; forms to aid compiler
optimisations.
&lt;/p&gt;

&lt;p&gt;
But again the book's age shows. It predates the obsessive
relationship that many modern programmers have with unit testing
and test automation, treating testing as an interactive activity
alongside debugging rather than as a core and permanent part of
program development and maintenance.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>style-guide</category><guid>https://simondobson.org/2025/01/31/lisp-style-and-design/</guid><pubDate>Fri, 31 Jan 2025 08:27:35 GMT</pubDate></item><item><title>New release of epydemic</title><link>https://simondobson.org/2024/11/29/new-release-of-epydemic/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org0c1efed" class="outline-2"&gt;
&lt;h2 id="org0c1efed"&gt;New release of epydemic&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0c1efed"&gt;
&lt;p&gt;
It's been a while – about 15 months since v.1.13.1 – but today I
finally released v.1.14.1 of &lt;code&gt;epydemic&lt;/code&gt;, a library for epidemic (and)
other simulation over complex networks.
&lt;/p&gt;

&lt;p&gt;
This release include several bug-fixes and two major changes.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb28d1d3" class="outline-3"&gt;
&lt;h3 id="orgb28d1d3"&gt;Better Newman-Ziff percolation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb28d1d3"&gt;
&lt;p&gt;
The Newman-Ziff algorithm for bond and site percolation is widely
used. The version that's been in &lt;code&gt;epydemic&lt;/code&gt; for a while emphasise
speed over everything. However, in the course of some work by one
of my MSc students on how grids of different dimensions respond to
random failure, we discovered that we needed to be able to do some
more flexible operations. In particular, we wanted to sample things
other than just the size of the largest connected component, and
wanted to be able to dig into to exactly how the network was
deforming.
&lt;/p&gt;

&lt;p&gt;
The problem was that this information wasn't readily available. It
&lt;i&gt;was&lt;/i&gt; encoded within the algorithm's data structure, but it wasn't
being reflected as an evolving network that was easy to get at. So
we upgraded the algorithm to build a working copy of the network as
it was constructed, so that it could be interrogated by
normal &lt;code&gt;networkx&lt;/code&gt; operations within the sampling process. This adds
some time penalty, but it's acceptable slowdown for the extra
capability.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org88cc177" class="outline-3"&gt;
&lt;h3 id="org88cc177"&gt;Multiple process instances&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org88cc177"&gt;
&lt;p&gt;
&lt;code&gt;epydemic&lt;/code&gt; defines different epidemic processes (and indeed
non-disease processes like pulse-coupled oscillators). Until now
these have been usable alone in a simulation, but not together: one
couldn't run &lt;i&gt;two&lt;/i&gt; diseases in the &lt;i&gt;same&lt;/i&gt; simulation over the &lt;i&gt;same&lt;/i&gt;
population simultaneously. Doing so is obviously very desirable,
especially if you want to explore co-infecting diseases.
&lt;/p&gt;

&lt;p&gt;
Co-infection is a difficult problem. As a first step we've added
multiple process instances which can have their own parameters and
results – or can share parameters if required. This involves
assigning distinct names to each instance, and then optionally
using them to decorate parameter/result names.
&lt;/p&gt;

&lt;p&gt;
This is fiddly if done manually, so we also added some methods on
the &lt;code&gt;Process&lt;/code&gt; class to get and set parameters and results using any
instance name on the calling process. For example:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="n"&gt;params&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

   &lt;span class="c1"&gt;# network&lt;/span&gt;
   &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt;
   &lt;span class="n"&gt;kmean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
   &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERNetwork&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;
   &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERNetwork&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;KMEAN&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kmean&lt;/span&gt;

   &lt;span class="c1"&gt;# first infection&lt;/span&gt;
   &lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SIR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Disease1"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setParameters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;SIR&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;P_INFECT&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="n"&gt;SIR&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;P_INFECTED&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;5.0&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;
                         &lt;span class="p"&gt;})&lt;/span&gt;

   &lt;span class="c1"&gt;# second infection&lt;/span&gt;
   &lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SIR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Disease2"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setParameters&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;SIR&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;P_INFECT&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="n"&gt;SIR&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;P_INFECTED&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;5.0&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;
                         &lt;span class="p"&gt;})&lt;/span&gt;

   &lt;span class="c1"&gt;# common removal rate&lt;/span&gt;
   &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIR&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;P_REMOVE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.005&lt;/span&gt;

   &lt;span class="c1"&gt;# run the processes together&lt;/span&gt;
   &lt;span class="n"&gt;ps&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ProcessSequence&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
   &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StochasticDynamics&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ERNetwork&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
   &lt;span class="n"&gt;rc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fatal&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The &lt;code&gt;setParameters&lt;/code&gt; call sets the parameters decorated with the name
of the process, if it has one. There are other operations for
extracting the parameters, and for interacting with experimental
results without getting into the details of decoration.
&lt;/p&gt;

&lt;p&gt;
See &lt;a href="https://pypi.org/project/epydemic/"&gt;the project documentation&lt;/a&gt; for more details, as well as an
updated tutorial and a cookbook recipe for co-infection (which is
based around the code above). The &lt;a href="https://github.com/simoninireland/epydemic"&gt;Github repo&lt;/a&gt; is also available. To
upgrade, just run:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;upgrade&lt;/span&gt; &lt;span class="n"&gt;epydemic&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
or delete and re-build any virtual environments.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>epydemic</category><category>network science</category><category>software</category><guid>https://simondobson.org/2024/11/29/new-release-of-epydemic/</guid><pubDate>Fri, 29 Nov 2024 16:35:46 GMT</pubDate></item><item><title>Lisp as a second language</title><link>https://simondobson.org/2024/11/29/lisp-as-a-second-language/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org0e5ab39" class="outline-2"&gt;
&lt;h2 id="org0e5ab39"&gt;Lisp as a second language&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0e5ab39"&gt;
&lt;p&gt;
Peter Desain.  &lt;i&gt;&lt;a href="https://hdl.handle.net/2066/74778"&gt;Lisp as a Second Language: Functional Aspects&lt;/a&gt;&lt;/i&gt;.
Perspectives on New Music &lt;b&gt;20&lt;/b&gt;, pp.192–222. 1990.
&lt;/p&gt;

&lt;p&gt;
In some ways this article should come under "applications", as
it's mainly concerned with using Lisp to represent and manipulate
music. Indeed, it presents a system that can be used to perform
all sorts of common transformations of the tones and timing of a
piece. It's easy to see how the resulting system could be used to
compose and then to drive instruments, for example through a MIDI
interface.
&lt;/p&gt;

&lt;p&gt;
The music perspective is however secondary to the goal of teaching
and showcasing Lisp through the medium of a realistic example of
symbolic programming. It covers a lot of ground, starting with
lists and functions and including first-class functions and
combinators as means of implementing the musical structures. It's
a great piece of pedagogy that treats the application and the
language as closely linked, and not shying-away from some quite
advanced techniques that have clear applications in the domain. It
would be great to see this used as a basis for actual musical
composition and performance.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/11/29/lisp-as-a-second-language/</guid><pubDate>Fri, 29 Nov 2024 15:01:40 GMT</pubDate></item><item><title>Two Lisp compilers written in Lisp</title><link>https://simondobson.org/2024/10/18/two-lisp-compilers-written-in-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org1478a92" class="outline-2"&gt;
&lt;h2 id="org1478a92"&gt;Two Lisp compilers written in Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1478a92"&gt;
&lt;p&gt;
&lt;a href="http://www.ulisp.com/show?4W2I"&gt;A Lisp compiler to ARM written in Lisp&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;a href="http://www.ulisp.com/show?4Y20="&gt;A Lisp compiler to RISC-V written in Lisp&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Two native-code compilers written in the &lt;a href="http://www.ulisp.com/show?3J"&gt;uLisp&lt;/a&gt; dialect that targets
microcontroller-class machines. Both use a combination of stack
and register allocation to get efficiency – and they're &lt;i&gt;very&lt;/i&gt;
efficient, with the compiled versions sometimes being 100x faster
than the interpreted code.
&lt;/p&gt;

&lt;p&gt;
These are not complete ports, and indeed not on a complete or
standard underlying Lisp implementation. But it's still fascinating
to see how &lt;i&gt;simple&lt;/i&gt; it is, built as a recursive-descent tree-walker
that emits assembler directly. With careful initial design even a
compiler with no optimisation pathways can still get great speed-up
over an interpreter.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>implementation-techniques</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/10/18/two-lisp-compilers-written-in-lisp/</guid><pubDate>Fri, 18 Oct 2024 09:24:36 GMT</pubDate></item><item><title>The different energy footprints of different programming languages</title><link>https://simondobson.org/2024/09/27/the-different-energy-footprints-of-different-programming-languages/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgb8af6ca" class="outline-2"&gt;
&lt;h2 id="orgb8af6ca"&gt;The different energy footprints of different programming languages&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb8af6ca"&gt;
&lt;p&gt;
I've recently been thinking about low-power computing, from AI and
data centres down to sensors, as part of a new initiative the
University is considering. It's easy to forget the resource
footprint of our computing systems – especially those that are "out
of sight, out of mind" in the cloud – but there's growing evidence
that their growth threatens the renewable energy transition. Some of
the figures for AI electricity and water usage are astonishing.
&lt;/p&gt;

&lt;p&gt;
One aspect of this is the effect of choice of programming language.
I can across some work from 2017 on this:
&lt;/p&gt;

&lt;p&gt;
Rui Pereira, Marco Couto, Francisco Ribeiro, Rui Rua, Cunha Jácome,
João Paulo Fernandes, and João Saraiva. &lt;i&gt;&lt;a href="https://doi.org/10.1145/3136014.3136031"&gt;Energy Efficiency across
Programming Languages: How Do Energy, Time, and Memory Relate?&lt;/a&gt;&lt;/i&gt; In
&lt;i&gt;Proceedings of the 10th ACM SIGPLAN International Conference on
Software Language Engineering&lt;/i&gt;. 2017.
&lt;/p&gt;

&lt;p&gt;
The authors compare 13 benchmarks run in 27 different languages,
with the benchmarks being chosen widely to avoid being biased by
numeric performance. I was expecting some patterns: compiled
languages doing better on performance, memory, and energy usage, for
example. But I wasn't expecting exactly &lt;i&gt;how&lt;/i&gt; widely the figures
diverged, or some of the details.
&lt;/p&gt;

&lt;p&gt;
The following table is from the paper, annotated by me. The figures
are normalised against the best result in each category (so the top
language has value 1, and so on).
&lt;/p&gt;

&lt;p width="80%" align="center"&gt;
&lt;img src="https://simondobson.org/attachments/fb/debea0-0913-41c2-90bc-726153de8d28/pl-energy.png" alt="pl-energy.png"&gt;
&lt;/p&gt;

&lt;p&gt;
The two most-used languages for web application, Python and
JavaScript, perform uniformly pretty badly: 75 times C's energy
usage, in Python's case. But although JavaScript does substantially
better on energy (only a factor of 4), TypeScript – which is
usually thought of as JavaScript with type pre-processing –
requires 21 times C's energy, or 5 times JavaScript's. Why is that?
– I can't think of a reason.
&lt;/p&gt;

&lt;p&gt;
But the real surprise was that "research" languages like Haskell and
Lisp both hold up well: twice C's energy, in Lisp's case. I don't
think that would surprise modern Lisp programmers, who are used to
their compilers' efficiencies – but it would surprise someone used
only to the "hearsay" about Lisp. The same for Haskell, actually,
whose modern compilers really leverage the extra structure. When you
consider that both those languages are pretty much dependent on
garbage collection and so are doing substantially &lt;i&gt;more&lt;/i&gt; work than the
equivalent C program, it's impressive.
&lt;/p&gt;

&lt;p&gt;
(Also look in the table for Racket, consistently lower than Lisp
despite their close similarities. I suspect this is a compiler
optimisation issue more than anything else.)
&lt;/p&gt;

&lt;p&gt;
This work clearly isn't complete or definitive. Clojure is entirely
missing, as is Scala, and there will have been compiler improvements
since 2017 for the languages with the most active developer
communities. But it's still quite sobering that the differences are
&lt;i&gt;so&lt;/i&gt; wide, and that we've chosen to push languages that exacerbate
energy usage rather than managing it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>haskell</category><category>javascript</category><category>lisp</category><category>low power</category><category>programming</category><category>python</category><guid>https://simondobson.org/2024/09/27/the-different-energy-footprints-of-different-programming-languages/</guid><pubDate>Fri, 27 Sep 2024 15:15:23 GMT</pubDate></item><item><title>Purely functional data structures</title><link>https://simondobson.org/2024/09/27/purely-functional-data-structures/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge75e26b" class="outline-2"&gt;
&lt;h2 id="orge75e26b"&gt;Purely functional data structures&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge75e26b"&gt;
&lt;p&gt;
Chris Okasaki. &lt;i&gt;Purely Functional Data Structures&lt;/i&gt;. Cambridge
University Press. ISBN 978-051153-010-4. 1998.
&lt;/p&gt;

&lt;p&gt;
Not a Lisp book &lt;i&gt;per se&lt;/i&gt;, but a treatment of data structures from a
functional programming perspective. The code examples are in
Standard ML, but the ideas apply strongly to Lisp and Scheme.
Definitely a useful source for an alternative take on data
structuring that doesn't start from assumptions of imperative
programming and mutability.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/09/27/purely-functional-data-structures/</guid><pubDate>Fri, 27 Sep 2024 15:12:14 GMT</pubDate></item><item><title>Lisp as the Maxwell's equations of software</title><link>https://simondobson.org/2024/09/27/lisp-as-the-maxwell1s-equations-of-software/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgbfd6534" class="outline-2"&gt;
&lt;h2 id="orgbfd6534"&gt;Lisp as the Maxwell's equations of software&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbfd6534"&gt;
&lt;p&gt;
&lt;a href="https://michaelnielsen.org/ddi/lisp-as-the-maxwells-equations-of-software/"&gt;Lisp as the Maxwell’s equations of software – DDI&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A take on Lisp as the computational version of fundamental
equations in physics. The claim is that learning Lisp is a
foundational skill, and this page goes on to develop a
"TiddlyLisp" interpreter in Python. As you'd expect this isn't an
espcially practical Lisp: but it's remarkably functional, and I
suspect will demystify Lisp for programmers familiar with
interpreters for other languages.
&lt;/p&gt;

&lt;p&gt;
See also a &lt;a href="https://queue.acm.org/detail.cfm?id=1039523"&gt;conversation with Alan Kay&lt;/a&gt; where he uses the "Maxwell's
equations":
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
That was the big revelation to me when I was in graduate
school – when I finally understood that the half page of code on the
bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These
were “Maxwell’s Equations of Software!” This is the whole world of
programming in a few lines that I can put my hand over.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
And in the second half of this article, the Lisp interpreter in
Python is translated into a Lisp interpreter in Lisp, which is a
very concrete way of showing how metacircularity can work
in &lt;a href="/2024/03/07/recursive-functions-of-symbolic-expressions-and-their-computation-by-machine-part-i/"&gt;McCarthy's original style&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>implementation-techniques</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/09/27/lisp-as-the-maxwell1s-equations-of-software/</guid><pubDate>Fri, 27 Sep 2024 15:06:55 GMT</pubDate></item><item><title>Guard methods on CLOS generic functions</title><link>https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org5f0970d" class="outline-2"&gt;
&lt;h2 id="org5f0970d"&gt;Guard methods on CLOS generic functions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5f0970d"&gt;
&lt;p&gt;
There are times when one wants to be able to guard a method's
execution. A typical case is for callbacks, where we only want the
callback to run under certain circumstances – but it's easier to
write the callbacks themselves as though they'll &lt;i&gt;always&lt;/i&gt; be called.
&lt;/p&gt;

&lt;p&gt;
Object-oriented programs typically use a pattern for this: they
split the function into two methods, one for the guard and one for
the action being guarded. A sub-class can then override the guard
independently of the action, and some sub-classes may override
both guard and action.
&lt;/p&gt;

&lt;p&gt;
This splitting seems a little awkward, though, and there are times
when I'd prefer to have everything (guard and action) defined as
part of the one method. Fortunately there's a Lisp-ier solution
involving defining a new method combination to get exactly this
behaviour.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb956012" class="outline-3"&gt;
&lt;h3 id="orgb956012"&gt;Standard method combination&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb956012"&gt;
&lt;p&gt;
CLOS, unlike most languages, allows a programmer to control how
methods are combined in terms of overriding. The "standard"
combination allows for &lt;code&gt;:before&lt;/code&gt;, &lt;code&gt;:after&lt;/code&gt;, and &lt;code&gt;:around&lt;/code&gt; methods as
well as undecorated "primary" methods.
&lt;/p&gt;

&lt;p&gt;
When a generic function is called, the list of applicable primary
methods is determined based on the types of arguments. most
specific method first&lt;sup&gt;&lt;a id="fnr.most-specific-first" class="footref" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fn.most-specific-first" role="doc-backlink"&gt;1&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;p&gt;
The same process is performed for all applicable &lt;code&gt;:before&lt;/code&gt; methods,
and then again for applicable &lt;code&gt;:after&lt;/code&gt; methods, and then &lt;i&gt;again&lt;/i&gt; for
&lt;code&gt;:around&lt;/code&gt; methods. The &lt;code&gt;:after&lt;/code&gt; and &lt;code&gt;:around&lt;/code&gt; are always ordered most
specific first, while the &lt;code&gt;:before&lt;/code&gt; methods are always ordered
least-specific first.
&lt;/p&gt;

&lt;p&gt;
Once these lists have been constructed, the "effective" method
that results is called. If there are &lt;code&gt;:around&lt;/code&gt; methods, they are
called in order. An &lt;code&gt;:around&lt;/code&gt; method may, as part of its body, call
&lt;code&gt;call-next-method&lt;/code&gt; to invoke the next-most-specific &lt;code&gt;:around&lt;/code&gt; method
– or may not.
&lt;/p&gt;

&lt;p&gt;
If a call to &lt;code&gt;call-next-method&lt;/code&gt; has no more &lt;code&gt;:around&lt;/code&gt; methods to call
– or of there were no &lt;code&gt;:around&lt;/code&gt; methods defined – all the &lt;code&gt;:before&lt;/code&gt;
methods are run and their return values discarded. Then the
primary methods are run in the same manner as &lt;code&gt;:around&lt;/code&gt; methods,
with any calls to &lt;code&gt;call-next-method&lt;/code&gt; calling the next primary
method. After the primary methods have returned, all the &lt;code&gt;:after&lt;/code&gt;
methods are run and their return values discarded. The result of
the method call is the result returned from the primary methods.
The process is roughly like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;prog1&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In this code, &lt;code&gt;call-method&lt;/code&gt; calls its first method argument, and
any call to &lt;code&gt;call-next-method&lt;/code&gt; calls the next method in the list.
&lt;code&gt;call-methods&lt;/code&gt; calls all the methods in a list of methods,
discarding their return values.
&lt;/p&gt;

&lt;p&gt;
Contrast that with Java or Python, where methods on more-specific
classes override those on less-specific, and have the option to
call up to the superclass method. Essentially this makes all
methods similar to &lt;code&gt;:around&lt;/code&gt;, and there's no real equivalent of
&lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgeb7f77e" class="outline-3"&gt;
&lt;h3 id="orgeb7f77e"&gt;Other method combinations&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgeb7f77e"&gt;
&lt;p&gt;
The above is referred to as &lt;i&gt;standard method combination&lt;/i&gt;, implying
the existence of &lt;i&gt;non-standard&lt;/i&gt; combination. CLOS lets the
programmer define new combinations, and indeed defines a few
itself. For our purposes the most important alternative method
combination is &lt;code&gt;and&lt;/code&gt;, which runs all primary methods within an &lt;code&gt;and&lt;/code&gt;
form treating all methods as predicates. There are only primary
methods allowed.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf506076" class="outline-3"&gt;
&lt;h3 id="orgf506076"&gt;Guards as method combination&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf506076"&gt;
&lt;p&gt;
For our use case, we want to be able to return values from primary
methods, and allow &lt;code&gt;:around&lt;/code&gt;, &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt; methods. However, we
&lt;i&gt;also&lt;/i&gt; want to have some methods act as predicates that guard the
execution of the effective method thus formed. We want to be able
to add guard methods that are always run first, regardless of their
specificity, and then run the effective method only if &lt;i&gt;all&lt;/i&gt; the guards
are satisfied. The net result is that all parts of the generic
function are provided as methods on it, but some can now be boolean
guards that act as gatekeepers on the rest of the methods.
Naturally we want the guards to be selected for specificity
alongside the other methods, letting the CLOS machinery pick &lt;i&gt;all&lt;/i&gt;
the functionality that's appropriate to a particular method call.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8335913" class="outline-3"&gt;
&lt;h3 id="org8335913"&gt;Why this isn't just &lt;code&gt;:around&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8335913"&gt;
&lt;p&gt;
It might sound like we can get this behaviour using &lt;code&gt;:around&lt;/code&gt;
methods that perform guarding. But we can't – quite.
&lt;/p&gt;

&lt;p&gt;
Suppose we define a primary method:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
We can write a guard quite happily as an &lt;code&gt;:around&lt;/code&gt; method:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-next-method&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This method will only allow the method to proceed when the
condition holds, otherwise it returns &lt;code&gt;nil&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
(52 NIL)
&lt;/p&gt;

&lt;p&gt;
So far so good.
&lt;/p&gt;

&lt;p&gt;
However, the problem is that CLOS orders the &lt;code&gt;:around&lt;/code&gt; methods
most specific first. Suppose we have another &lt;code&gt;:around&lt;/code&gt; method
specialised against a more specific type:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-next-method&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When this method is called with an integer this method gets run
before the previous guard:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
6
&lt;/p&gt;

&lt;p&gt;
and we get a non-nil result, despite the guard method indicating
that we shouldn't. If we provide an argument that doesn't trigger
the first &lt;code&gt;:around&lt;/code&gt; method, then we can get caught by the guard:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
NIL
&lt;/p&gt;

&lt;p&gt;
This is of course perfectly sensible behaviour in many cases.
However, it does mean that the "guards" we're supplying are
executed as &lt;i&gt;part&lt;/i&gt; of the effective method rather than &lt;i&gt;before&lt;/i&gt; it,
and therefore can't guarantee that the method is properly guarded
by &lt;i&gt;all&lt;/i&gt; the guards, regardless of their specialisation. Another
way of looking at this is that a later, more specialised, "guard"
can override one set by an earlier, less specialised, method,
which again may not be what's desired.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1a26b34" class="outline-3"&gt;
&lt;h3 id="org1a26b34"&gt;A &lt;code&gt;guarded&lt;/code&gt; method combination&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1a26b34"&gt;
&lt;p&gt;
Fortunately we can get the behaviour we want by defining a new
method combination, &lt;code&gt;guarded&lt;/code&gt;. A &lt;code&gt;guarded&lt;/code&gt; generic function accepts
five method qualifiers:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;undecorated primary methods;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt; methods that run before and after the
primary methods;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:around&lt;/code&gt; methods that run around the &lt;code&gt;:before&lt;/code&gt;-primary-&lt;code&gt;:after&lt;/code&gt;
combination; and&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:if&lt;/code&gt; methods that act as guards, running before any &lt;code&gt;:around&lt;/code&gt;
methods to determine whether &lt;i&gt;any&lt;/i&gt; of the "functional" methods
are run or not&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
We first need a helper function&lt;sup&gt;&lt;a id="fnr.call-methods" class="footref" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fn.call-methods" role="doc-backlink"&gt;2&lt;/a&gt;&lt;/sup&gt; to construct the
code to run the chain of &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt; methods while
discarding their return values.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;methods&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;"Return `call-method' forms for all METHODS."&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mapcar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="nv"&gt;methods&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
We can then use the macro &lt;code&gt;define-method-combination&lt;/code&gt; to define our
new method combination.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;define-method-combination&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&amp;amp;optional&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:most-specific-first&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;ifs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:if&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:before&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:required&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:after&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;before-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;after-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;primary-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;core-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;prog1&lt;/span&gt;
&lt;span class="w"&gt;                                  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
&lt;span class="w"&gt;                                    &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="nv"&gt;before-form&lt;/span&gt;
&lt;span class="w"&gt;                                    &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;primary-form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                                &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="nv"&gt;after-form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;around-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;
&lt;span class="w"&gt;                               &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                                             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                                              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;core-form&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;                               &lt;/span&gt;&lt;span class="nv"&gt;core-form&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ifs&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ifs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;around-form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="nv"&gt;around-form&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The macro is described in detail in the &lt;a href="https://novaspec.org/cl/f_define-method-combination"&gt;hyperspec&lt;/a&gt;, but its
behaviour is quite simple. The list of forms (&lt;code&gt;arounds&lt;/code&gt; and so on)
define variables that extract the methods that have the given
decorations – so &lt;code&gt;arounds&lt;/code&gt; gets a list of &lt;code&gt;:around&lt;/code&gt; methods,
&lt;code&gt;primaries&lt;/code&gt; gets the undecorated (primary) methods, and so on. In
particular, &lt;code&gt;ifs&lt;/code&gt; gets any methods decorated with &lt;code&gt;:if&lt;/code&gt;: these are
the guards.
&lt;/p&gt;

&lt;p&gt;
The body of the macro constructs the code needed to build the
methods' behaviours. The &lt;code&gt;let*&lt;/code&gt; defines the code for the different
parts. &lt;code&gt;core-form&lt;/code&gt; is slightly optimised in the case when there is
only one primary method; otherwise it runs the &lt;code&gt;:before&lt;/code&gt; methods
and then the primary method, captures the result of the latter,
then runs the &lt;code&gt;:after&lt;/code&gt; methods, and then returns its result. (This
is the first time I've ever used &lt;code&gt;prog1&lt;/code&gt; for real: now I know why
it exists.) If there are &lt;code&gt;:around&lt;/code&gt; methods, &lt;code&gt;around-form&lt;/code&gt; wraps up a
list consisting of the &lt;code&gt;:around&lt;/code&gt; methods and a method constructed
from &lt;code&gt;core-form&lt;/code&gt;, letting it be run as the result of the final
&lt;code&gt;call-next-method&lt;/code&gt; call.
&lt;/p&gt;

&lt;p&gt;
The body of the &lt;code&gt;let*&lt;/code&gt; wraps-up &lt;code&gt;around-form&lt;/code&gt; within an &lt;code&gt;if&lt;/code&gt; whose
condition is the conjunction of all the &lt;code&gt;:if&lt;/code&gt; methods. Only if all
these methods return true (well, not &lt;code&gt;nil&lt;/code&gt; in the usual Lisp style)
will the code of &lt;code&gt;around-form&lt;/code&gt; be executed. Again the code is
optimised for the case where there are no guards, in which case
we just get &lt;code&gt;around-form&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Notice that &lt;code&gt;define-method-combination&lt;/code&gt; returns &lt;i&gt;code&lt;/i&gt;, like all
macros: it doesn't execute the methods itself. This is a hint as
to what happens off-stage: CLOS uses the method combination at
compile time to construct effective methods which can then be
cached to minimise the performance hit from all the flexibility
provided by method combination.
&lt;/p&gt;

&lt;p&gt;
Now we can re-do our example from above:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;;; a generic function defined to use our new method combination&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defgeneric&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:method-combination&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;;; the functionality, split into two methods&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-next-method&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;;; this guard used to be :around and is now :if&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
(52 NIL NIL)
&lt;/p&gt;

&lt;p&gt;
The guard now stops execution of the effective method if its
condition isn't met – and if it &lt;i&gt;is&lt;/i&gt; met, passes control through
to the complete method stack. This happens regardless of where
the guard is specialised in terms of the class hierarchy: the
guards run before any "functional" code. (That &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt;
methods work too, and multiple guards, and that the combination
works when applied to class hierarchies, are left as exercises to
the reader.)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0bd74b1" class="outline-3"&gt;
&lt;h3 id="org0bd74b1"&gt;Critique&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0bd74b1"&gt;
&lt;p&gt;
You may object to this solution on the grounds that it introduces
a weird asymmetry into methods: some as functional and some as
guards, with different return types. Maybe you prefer to keep
guards in separate methods using the usual object-oriented
pattern. That's entirely reasonable. But I think there are
sufficient cases where this kind of guarding makes sense to have
it as a pattern, especially as it has no effect unless explicitly
selected for a generic function.
&lt;/p&gt;

&lt;p&gt;
I have to say I'm amazed how &lt;i&gt;little&lt;/i&gt; code is needed: around 30
lines, including the helper function. It shows off the power of
CLOS, and how it's possible to change even the basic underlying
structures of the object system with relative ease. But it also
shows how Lisp opens-up the space of programming styles, things
that benefit from being policies that can be changed, rather than
hard-coding one particular choice.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;h2 class="footnotes"&gt;Footnotes: &lt;/h2&gt;
&lt;div id="text-footnotes"&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.most-specific-first" class="footnum" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fnr.most-specific-first" role="doc-backlink"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara" role="doc-footnote"&gt;&lt;p class="footpara"&gt;
This is also programmable when required, for
example to run methods least-specific-first.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.call-methods" class="footnum" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fnr.call-methods" role="doc-backlink"&gt;2&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara" role="doc-footnote"&gt;&lt;p class="footpara"&gt;
I got the idea for this function from
&lt;a href="https://github.com/sellout/method-combination-utilities"&gt;method-combination-utilities&lt;/a&gt;, and included it literally to avoid
creating another dependency.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>programming</category><guid>https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/</guid><pubDate>Thu, 05 Sep 2024 14:36:23 GMT</pubDate></item><item><title>The Himmler Brothers: A German Family History</title><link>https://simondobson.org/goodreads/the-himmler-brothers-a-german-family-history/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1328831850l/1629056._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Katrin Himmler
	  (2005)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      The family history of Heinrich Himmler and his two brothers Gebhard and Ernst, as told by his great-niece.&lt;br&gt;&lt;br&gt;There's a lot of fascinating backstory in this book, and it explains a lot. It portrays Heinrich Himmler as very much the product of a middle-class, socially ambitious family who pushed him relentlessly to succeed and only seemed really to embrace him after he achiveed visible success as a Reichstag deputy and then later as Reichsführer-SS. The author, Katrin, has access to lots of family papers and photographs that have never been explored before, as well as being able to talk informally to Heinrich's brothers' children about their experiences. This makes this a profoundly personal exploration of Heinrich's rise and fall.&lt;br&gt;&lt;br&gt;That's also its weakness, of course, of which Katrin herself is well aware: it was cleaerly not an easy book to write, and one led her to realise how much families re-write their own histories – understandbaly so in the light of what happened. It also means the the book as a whole concentrates on the domestic side of Heinrich's life, which can be jarring: the period from him being a secretary to leading the SS is covered in less than a page. Overall, though, there's a lot of keen insight provided into the making of a monster.
      &lt;/p&gt;&lt;p&gt;
	4/5.
	  Finished Thursday 22 August, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6782101538?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/the-himmler-brothers-a-german-family-history/</guid><pubDate>Thu, 22 Aug 2024 00:00:00 GMT</pubDate></item><item><title>Prophet Song</title><link>https://simondobson.org/goodreads/prophet-song/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1726520473l/175740709._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Paul    Lynch
	  (2023)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      A timely and troubling consideration of social breakdown.&lt;br&gt;&lt;br&gt;The most notable thing about this novel is that it happens in Ireland: not "far away", but in a European country that is nevertheless seen as collapsing through (it is hinted) a shift to the right taken by fully democrtic means, and a subsequent descent into authoritarianism. That's a perfectly believable scenario for many countries.&lt;br&gt;&lt;br&gt;Lynch writes in a stream-of-consciousness style that manages to be comprehensible while still retaining the slightly bewildered feeling of someone caught-up in event they don't fully understand and can't quite keep up with. There's enough Irish vernacular and geographical detail to make the story hard-hitting for anyone who knows Dublin.&lt;br&gt;&lt;br&gt;Some people desperately cling to processes that no longer have any meaning; there are huge numbers of forms to fill out despite them serving no purpose; there's lots of bureaucracy used to drum people into compliance; and there's lots of venality hiding behind the continuation of these processes to convert them into vehicles for personal gain. Rules tighten as order breaks down, and the same cast of chancers and bandits and people-smugglers emerge in Ireland as in other countries that have gone through this kind of trauma. And that I think is the main message of the book. The themes and characters emerging from social breakdown are universal, and a European country would go the same way as anywhere else.
      &lt;/p&gt;&lt;p&gt;
	5/5.
	  Finished Tuesday 20 August, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6042005187?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/prophet-song/</guid><pubDate>Tue, 20 Aug 2024 00:00:00 GMT</pubDate></item></channel></rss>