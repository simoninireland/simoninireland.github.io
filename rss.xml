<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson</title><link>https://simondobson.org/</link><description>Aut tace aut loquere meliora silentio</description><atom:link href="https://simondobson.org/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Fri, 02 Feb 2024 14:12:08 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>LISPcraft</title><link>https://simondobson.org/2024/02/02/lispcraft/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org29167e9" class="outline-2"&gt;
&lt;h2 id="org29167e9"&gt;LISPcraft&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org29167e9"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/fc/8f0d76-df2a-43eb-b5ca-a79b21c2351a/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Robert Wilensky.  &lt;i&gt;LISPcraft&lt;/i&gt;. W.W. Norton. ISBN
0-393-95442-0. 1984.
&lt;/p&gt;

&lt;p&gt;
Hard to know whether to include this as an introduction or
collection of applications, since it runs all the way from basic
uses to pattern-matching and associative retrieval, by way of the
non-list data types in Lisp, and includes discussion of the symbol
table and other internals that definitely fall into the "advanced"
category.
&lt;/p&gt;

&lt;p&gt;
However, this was my second introduction to Lisp (after &lt;a href="/2024/01/27/structure-and-interpretation-of-computer-programs/"&gt;SICP&lt;/a&gt;), so
it has a fond place in my memory. The fact that it deals with
language internals isn't a bad thing, because it deals with the
basics so well. It's very much a traditional programming
introduction focusing on the "needed" parts of the language. It
pre-dates the Common Lisp standard and doesn't touch on CLOS,
which perhaps make it a less appropriate choice for newcomers
these days than &lt;a href="/2024/01/27/practical-common-lisp/"&gt;Practical Common Lisp&lt;/a&gt;.
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
There is also a second edition. I haven't read it, but it seems that
it addresses at least the concern about being non-standard:
&lt;/p&gt;

&lt;p&gt;
Robert Wilensky.  &lt;i&gt;Common LISPcraft&lt;/i&gt;. W.W. Norton. ISBN
978-039395544-6. 1986.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/02/02/lispcraft/</guid><pubDate>Fri, 02 Feb 2024 12:23:08 GMT</pubDate></item><item><title>The CONNIVER reference manual</title><link>https://simondobson.org/2024/02/02/the-conniver-reference-manual/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org0fda5a5" class="outline-2"&gt;
&lt;h2 id="org0fda5a5"&gt;The CONNIVER reference manual&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0fda5a5"&gt;
&lt;p&gt;
Drew McDermott and Gerald Jay Sussman.  &lt;i&gt;&lt;a href="https://dspace.mit.edu/handle/1721.1/6204"&gt;The Conniver Reference
Manual&lt;/a&gt;&lt;/i&gt;. Technical report AIM-259a. MIT AI Laboratory. 1974.
&lt;/p&gt;

&lt;p&gt;
I think Conniver may have a claim to being the most influential
language you've never heard of. It's a mostly forgotten Lisp
variant that was a laboratory for some radically different
language design ideas, and a precursor to a surprising set of
features – many of which are still uncommon in the mainstream.
&lt;/p&gt;

&lt;p&gt;
Conniver was intended to manage knowledge databases. This does
make the report slightly hard to read in places, as there are a
lot of explicit references to planning techniques wrapped-up with
language mechanisms that don't really depend on them.
&lt;/p&gt;

&lt;p&gt;
Conniver is (to the best of my knowledge) the first appearance of
&lt;b&gt;generators&lt;/b&gt; in a programming language. It is therefore a distant
precursor of all the lazy functional languages and libraries, as
well as the generators found in Python. Implementing generators
&lt;i&gt;within&lt;/i&gt; a language (rather than as a built-in part of one)
requires control structures that can be exited and re-entered, and
therefore needs more flexible frames for controlling executing
code rather than conventional stack frames that are unwound
destructively on return.
&lt;/p&gt;

&lt;p&gt;
The obvious (for Lisp, anyway) next step is to make these "hairy"
control structures visible within the language, to allow them to
be re-arranged in interesting ways. It does this by exposing the
structure of frames, consisting of:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;the bound variables&lt;/li&gt;
&lt;li&gt;the state of the ongoing computation within the frame (&lt;i&gt;e.g.&lt;/i&gt;,
the program counter)&lt;/li&gt;
&lt;li&gt;a link (the &lt;code&gt;ALINK&lt;/code&gt;) to the frame within which free variables
should be looked-up&lt;/li&gt;
&lt;li&gt;a link (the &lt;code&gt;CLINK&lt;/code&gt;) to the frame to which control should return
on exit from the frame&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
This structure in turn mandates the use of &lt;b&gt;spaghetti stack&lt;/b&gt; (or
&lt;a href="https://en.wikipedia.org/wiki/Parent_pointer_tree"&gt;parent pointer trees&lt;/a&gt;) where frames are implemented using lists
that can be combined in richer ways than actual, literal stacks.
Thee are the underpinnings of several different common structures:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;generators and continuations&lt;/li&gt;
&lt;li&gt;closures&lt;/li&gt;
&lt;li&gt;non-local transfers, like &lt;code&gt;CATCH&lt;/code&gt; and &lt;code&gt;THROW&lt;/code&gt; in Common Lisp, and
therefore probably encompassing the entire condition system&lt;/li&gt;
&lt;li&gt;functions with access to extra state (as with object methods,
but in this case used as callbacks for database updates)&lt;/li&gt;
&lt;li&gt;symbolic debuggers (not mentioned in the text)&lt;/li&gt;
&lt;li&gt;lexical &lt;i&gt;versus&lt;/i&gt; dynamic variable scope (not mentioned in the
text, and I think it's a binary choice between one or the other
depending on the &lt;code&gt;ALINK&lt;/code&gt;, rather than accommodating lexical and
"special" variable classes as Common Lisp does)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
So these features are constructed in Conniver from more basic
mechanisms rather than being provided built-in. I'm fascinated by
what other structures one might build when every frame has &lt;i&gt;two&lt;/i&gt;
independent super-frames (one for variable lookup,one for control
return) instead of one, and both can be modified independently.
This is radically different to most languages in which frames are
hidden and their manipulation reserved for the compiler and
run-time: it's a set of ideas that re-surface at the object level
in metaobject protocols.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>language-reference</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/02/02/the-conniver-reference-manual/</guid><pubDate>Fri, 02 Feb 2024 12:14:30 GMT</pubDate></item><item><title>Common Lisp: the language</title><link>https://simondobson.org/2024/02/02/common-lisp-the-language/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge0d8015" class="outline-2"&gt;
&lt;h2 id="orge0d8015"&gt;Common Lisp: the language&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge0d8015"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/20/46d76e-4b50-4cf1-866c-7515d6fd427f/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Guy Steele.  &lt;i&gt;&lt;a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html"&gt;Common Lisp: The Language&lt;/a&gt;&lt;/i&gt;. Digital Press. ISBN
1-55558-041-6. 1990.
&lt;/p&gt;

&lt;p&gt;
The reference manual for Common Lisp, also &lt;a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html"&gt;available online in its
entirety&lt;/a&gt;. This is very much a reference manual and not a
tutorial, but having said that it's a lot more accessible than
many such documents.
&lt;/p&gt;

&lt;p&gt;
It's remarkable that Common Lisp's standard has been stable for
over thirty years, despite enormous advances in Lisp practices in
that time. It shows the care that went into the original
standardisation process, but also the effects of some detailed
technical choices and (especially) the use of macros in preference
to new core mechanisms.
&lt;/p&gt;

&lt;p&gt;
However, it has to be said that the standard also fixed in place
certain choices that now seem questionable. It's a matter of
opinion, of course, but personally I think the questionable set
includes at least: multiple-value returns and binds, which are
unnecessary when you can return lists and destructure them and
that impinge on the minimalism of the core language; and allowing
symbols to be bound simultaneously to values and functions, which
unnecessarily treats the two differently (and for which reason it
was removed from Scheme).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>language-reference</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/02/02/common-lisp-the-language/</guid><pubDate>Fri, 02 Feb 2024 12:10:26 GMT</pubDate></item><item><title>Structure and interpretation of computer programs</title><link>https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org0638c56" class="outline-2"&gt;
&lt;h2 id="org0638c56"&gt;Structure and interpretation of computer programs&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0638c56"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/52/6b5639-18fe-4fc6-b8b1-7c93e3011194/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Harold Abelson and Gerald Jay Sussman.  &lt;i&gt;&lt;a href="https://web.mit.edu/6.001/6.037/sicp.pdf"&gt;Structure and
Interpretation of Computer Programs&lt;/a&gt;&lt;/i&gt;. MIT Press. 1985.
&lt;/p&gt;

&lt;p&gt;
A book once described (&lt;a href="https://simondobson.org/2010/05/14/cs-book-worth-reading-twice/"&gt;by me&lt;/a&gt;, actually) as "the only computer
science book worth reading twice", and which was the foundational
text for teaching programming at MIT for decades.
&lt;/p&gt;

&lt;p&gt;
There are many reasons that this book is so popular and
long-lived. It's resolutely an introductory text, but it treats
topics that are uncommon in introductions, and does so to a depth
that's quite astonishing – although it has to be said that the
authors avoid the more complex constructions like conditions and
the complexities of macros, (They do deal with continuations,
however, which are essential for good Scheme programming.)
&lt;/p&gt;

&lt;p&gt;
But what other introduction to programming includes a complete
meta-linguistic re-implementation of the language itself? – and
in two different styles! It can do this because Scheme is so
regular and so simple – &lt;i&gt;homoiconic&lt;/i&gt; (one representation for
programs and data), (although they don't use that term).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/</guid><pubDate>Sat, 27 Jan 2024 15:46:19 GMT</pubDate></item><item><title>Learn Common Lisp in Y minutes</title><link>https://simondobson.org/2024/01/27/learn-common-lisp-in-y-minutes/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org1e4659c" class="outline-2"&gt;
&lt;h2 id="org1e4659c"&gt;Learn Common Lisp in Y minutes&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1e4659c"&gt;
&lt;p&gt;
&lt;a href="https://learnxinyminutes.com/docs/common-lisp/"&gt;https://learnxinyminutes.com/docs/common-lisp/&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A one-web-page introduction to Common Lisp covering pretty much
all the language in enough detail to at least start writing simple
command-line programs (and understanding those of others).
Includes macros and CLOS. Quite an achievement to make it all so
readable.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/01/27/learn-common-lisp-in-y-minutes/</guid><pubDate>Sat, 27 Jan 2024 14:14:35 GMT</pubDate></item><item><title>Practical Common Lisp</title><link>https://simondobson.org/2024/01/27/practical-common-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org12de14d" class="outline-2"&gt;
&lt;h2 id="org12de14d"&gt;Practical Common Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org12de14d"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/b8/4b7fa7-83e9-4756-8ede-1c3cdeaeafef/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Peter Seibel.  &lt;i&gt;&lt;a href="https://gigamonkeys.com/book/"&gt;Practical Common Lisp&lt;/a&gt;&lt;/i&gt;. Apress. ISBN
978-1-4302-0017-8. 2005.
&lt;/p&gt;

&lt;p&gt;
The classic, very thorough and hands-on tutorial introduction that
doesn't skip the hard parts like the condition system and
non-local blocks and exists (and the relationship between the
two). It's also got good chapters on CLOS.
&lt;/p&gt;

&lt;p&gt;
The text is complemented by a set of modern examples, for web
services, database, and binary file parsers: quite a long way
removed from the examples in many introductory texts. It doesn't
make much use of macro programming in these examples, which is a
shame, so follow with On Lisp or Let over Lambda once the
structure of the language is clear.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/01/27/practical-common-lisp/</guid><pubDate>Sat, 27 Jan 2024 13:15:30 GMT</pubDate></item><item><title>TIL: An RSS-focused search engine</title><link>https://simondobson.org/2024/01/26/til-an-rss-focused-search-engine/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org77d1ec3" class="outline-2"&gt;
&lt;h2 id="org77d1ec3"&gt;TIL: An RSS-focused search engine&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org77d1ec3"&gt;
&lt;p&gt;
Today I learned about &lt;a href="https://feedle.world/"&gt;feedle&lt;/a&gt;, a search engine focused on searching
blogs and podcasts – web sites that export an &lt;a href="https://en.wikipedia.org/wiki/RSS"&gt;RSS feed&lt;/a&gt;, in other
words. And the search results are themselves RSS feed that can be
subscribed to live.
&lt;/p&gt;

&lt;p&gt;
This feels like a quite a big thing for accessing content without
resort to the internet giants, and for the &lt;a href="https://indieweb.org/"&gt;IndieWeb&lt;/a&gt; in general. It
means that search can prefer syndicated and typically small-scale
content rather than being influenced by search engine optimisation
(SEO) or sponsorship affecting the link rankings.
&lt;/p&gt;

&lt;p&gt;
Of course this also need management, and feedle is a curated source:
you have to submit your RSS feed to it for review and (hopefully)
inclusion. I've done that for &lt;a href="https://simon.dobson.org/rss.xml"&gt;this site's feed&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>internet</category><category>til</category><guid>https://simondobson.org/2024/01/26/til-an-rss-focused-search-engine/</guid><pubDate>Fri, 26 Jan 2024 13:10:23 GMT</pubDate></item><item><title>Locally overriding a function throughout a dynamic extent</title><link>https://simondobson.org/2024/01/22/locally-overriding-a-function-throughout-a-dynamic-extent/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org3d747c3" class="outline-2"&gt;
&lt;h2 id="org3d747c3"&gt;Locally overriding a function throughout a dynamic extent&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3d747c3"&gt;
&lt;p&gt;
A horribly dangerous but occasionally useful Lisp technique.
&lt;/p&gt;

&lt;p&gt;
My use case is as follows. &lt;code&gt;ebib&lt;/code&gt; has a command to copy a
formatted reference to the kill ring, using
&lt;code&gt;citar-citeproc-format-reference&lt;/code&gt; to actually do the formatting.
This means it's easy to change the style of the formatted
reference. However, &lt;code&gt;citar-citeproc-format-reference&lt;/code&gt;  itself uses
&lt;code&gt;citar-render-bib&lt;/code&gt; with a plain-text formatter. This is a sensible
default, but since I'm almost always copying references into
org-more documents, it loses a lot of information: it'd be better
to use the org formatter, but there's no argument to specify it.
&lt;/p&gt;

&lt;p&gt;
Clearly the correct solution is to change
&lt;code&gt;citar-citeproc-format-reference&lt;/code&gt; to take a key or optional
argument to specify the formatter, but that involves changing
someone else's code. The hacker solution is to change the call
&lt;code&gt;(citeproc-render-bib proc 'plain)&lt;/code&gt; to &lt;code&gt;(citeproc-render-bib proc
  'org)&lt;/code&gt;, but without re-writing the entire surrounding function to
keep the change just to the case where I need it.
&lt;/p&gt;

&lt;p&gt;
One way to do this would be to define a variant
&lt;code&gt;citeproc-render-bib&lt;/code&gt; that ignores its second argument (the
formatter) and always uses &lt;code&gt;'org&lt;/code&gt; instead, and then substitute
this variant for the original – but &lt;i&gt;only&lt;/i&gt; in the dynamic extent
of a &lt;i&gt;particular&lt;/i&gt; call to &lt;code&gt;citar-citeproc-format-reference&lt;/code&gt;. In
most languages this would be impossible – but not in Emacs Lisp.
&lt;/p&gt;

&lt;p&gt;
The solution is to use &lt;code&gt;cl-letf&lt;/code&gt;, which overrides the values of
general places for the duration of its body forms and restores the
original value on exit (normal or otherwise). The important point
is that the change occurs across the &lt;i&gt;extent&lt;/i&gt; of the body – the
body and all the code called from the body – and not merely in
the &lt;i&gt;scope&lt;/i&gt; of the body, which would only affect calls made there
directly.
&lt;/p&gt;

&lt;p&gt;
For example, consider in the following:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Which when called gives:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
36
&lt;/pre&gt;


&lt;p&gt;
If we want to override the default value (10) that's passed to &lt;code&gt;f&lt;/code&gt;
and instead use 25, we can define a new version that ignores the
second argument and uses our preferred default, and then
temporarily override the definition of &lt;code&gt;f&lt;/code&gt; in the calling
environment. If we want to use the original in the overriding
definition we need to grab it first. This gives:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cl-letf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;				    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
51
&lt;/pre&gt;


&lt;p&gt;
What's going on? The &lt;code&gt;cl-letf&lt;/code&gt; macro is like &lt;code&gt;let&lt;/code&gt; but works with
general places (as in &lt;code&gt;setf&lt;/code&gt;). It sets the places in its argument
list for the duration of its body, and then restores them on exit,
regardless of whether that exit is normal or &lt;i&gt;via&lt;/i&gt; a condition.
&lt;/p&gt;

&lt;p&gt;
The &lt;code&gt;(symbol-function 'f)&lt;/code&gt; form returns the place that stores the
function associated with symbol &lt;code&gt;f&lt;/code&gt;. We use it twice: once to
capture this function so we can use it later, and once to identify
the place where we store our new variant function. This new binding
is then used for all calls made from the body of the &lt;code&gt;cl-letf&lt;/code&gt;,
regardless of depth, so the call to &lt;code&gt;first&lt;/code&gt; makes use of our variant
definition of &lt;code&gt;f&lt;/code&gt; rather than the original – but with the original
then being used in the variant in our case!
&lt;/p&gt;

&lt;p&gt;
If we'd used &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;cl-flet&lt;/code&gt; instead of &lt;code&gt;cl-letf&lt;/code&gt; we wouldn't
have got the behaviour we're looking for:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cl-flet&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;	      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
36
&lt;/pre&gt;


&lt;p&gt;
Why? Because &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;cl-flet&lt;/code&gt; work over the &lt;i&gt;scope&lt;/i&gt; of the body,
so only calls to &lt;code&gt;f&lt;/code&gt; directly from the body of the assignment are
affected – not calls from calls. This is a great illustration of
the difference between the closely-related concepts of (static,
lexical) scope and (dynamic, run-time) extent, incidentally.
&lt;/p&gt;

&lt;p&gt;
I did say it was horrible :-). It's basically like adding
temporary &lt;code&gt;:around&lt;/code&gt; advice, and could probably benefit from a
macro to wrap it up. It's also inconceivable that it's thread- or
co-routine-safe, although I haven't checked.
&lt;/p&gt;

&lt;p&gt;
Part of the horribleness comes from the fact that the redefinition
is made for the entire dynamic extent of the body forms, which
means &lt;i&gt;all&lt;/i&gt; instances of the overridden function will use the
overridden value. There might be more than you think! But for
well-understood code it's sometimes useful, avoiding duplicating
code to make tiny changes.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>emacs</category><category>lisp</category><category>programming</category><guid>https://simondobson.org/2024/01/22/locally-overriding-a-function-throughout-a-dynamic-extent/</guid><pubDate>Mon, 22 Jan 2024 10:34:45 GMT</pubDate></item><item><title>This Is How They Tell Me the World Ends: The Cyberweapons Arms Race</title><link>https://simondobson.org/goodreads/this-is-how-they-tell-me-the-world-ends-the-cyberweapons-arms-race/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1610927353l/49247043._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Nicole Perlroth
	  (2021)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      A hugely detailed and deeply researched history of the market for "zero-day: exploits, the faults and technologies underlying computer viruses and ransomware. It's a hugely complicated and technical field which Perlroth does an amazing job of making accessible to a non-technical audience. (I should probably say here that I teach computer security.)&lt;br&gt;&lt;br&gt;Most of the book is a real page-turner, deeply embedded with the government agencies, companies, and hackers who compose the zero-day market. It's scathing of the US' trying to play both sides of the street, developing and buying zero-days in order to collect intelligence while weakening the security of ordinary users in the process by not informing the software developers of the problems they've found. They clearly knew this was dangerous, and even developed a doctrine for us: "NOBUS", bugs that "no-one but us" would be smart enough to find or develop. This idea goes wrong spectacularly, as other nations realise how cheaply they too can have cyberweapons programmes: ironically they're encouraged by the deployment of the Stuxnet virus to damage the Iranian nuclear programme. The leaks of the NSA's zero-day stockpile by the Shadow Brokers – an event that's somewhat under-explored – and their later use in hacks against US elections, are payback for hubris.&lt;br&gt;&lt;br&gt;Perlroth is scathing of the Trump presidency's neglect of cybersecurity and unwillingness to sanction Russia for known attacks – in part because it might cast doubt on Trump's legitimacy as an elected president, but also seemingly from willful blindness and a mistrust of the professionals (including the military) tasked with protecting US networks. She was writing during the pandemic and before Trump conceded the 2020 election (to the extent that he ever did), and so if anything she understated the impacts of disinformation spreading.&lt;br&gt;&lt;br&gt;The conclusions are a little breathless, but well-intentioned and technically appropriate, if a little US-centric – and in fairness the US has at least attempted to set up a more transparent approach to managing cyberweapons, even though the approach is drastically compromised by the desire to keep intelligence-gathering capabilities. Cybersecurity is an area where offence and defence are closely intertwined, and there's a strong argument that the costs to society of the former mandate a focus on the latter. We need to accept that many cyberweapons that are used (or leaked) can be reverse-engineered and re-used against their original developers with little real up-front financial investment.&lt;br&gt;&lt;br&gt;There's some editing. including a repeated mis-use of "affect" rather than "effect", and a really disastrous throw-away reference to the book &lt;i&gt;Dune&lt;/i&gt;, the description of which is almost entirely wrong: surely an editor should have picked that up?
      &lt;/p&gt;&lt;p&gt;
	4/5.
	  Finished Sunday 21 January, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/4691376169?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/this-is-how-they-tell-me-the-world-ends-the-cyberweapons-arms-race/</guid><pubDate>Sun, 21 Jan 2024 00:00:00 GMT</pubDate></item><item><title>Edible Economics: A Hungry Economist Explains the World</title><link>https://simondobson.org/goodreads/edible-economics-a-hungry-economist-explains-the-world/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1656314692l/61030740._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Ha-Joon Chang
	  (2022)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      A book that combines food with economics? Not really.&lt;br&gt;&lt;br&gt;I'm torn by this book. I enjoyed the food parts, especially the author's anecdotes about his move to the UK from Korea, and how he's observed the UK's food scene change from incredibly insular and conservative to amazingly open and dynamic over the course of a couple of decades. It's a change I also lived through and remember well.&lt;br&gt;&lt;br&gt;I also enjoyed the economics. Chang is an eclectic collector of economic theories – all the more surprising because he's an academic. He has an appropriate degree of scepticism for ideology and single explanation of complex questions, which is refreshing. He skewers some of the common myths, such as the "explanation" that poor countreis stay poor because their people don't work hard enough, ingoring the massive structural factors in play. He's equally scathing about the other "explanation" about the free-trade roots of the successes of the US and UK economies, given that they were actually massively protectionist during their main periods of growth. And he makes several policy suggestions for modern economies.&lt;br&gt;&lt;br&gt;But.... as a book, I don't think it works at all. The conceit of explaining economics through food remains just that: a conceit that's not really threaded through the narrative in a meaningful way. The links are often just too tenuous. To give one example, a chapter that leads with anchovies ends up talking about natural-resource extraction economics using the example of bird guano – well, birds eat anchovies, so... Most of the chapters are basically diviided between food and economics with an often desperate attempt to tie them together. The economics is accessible, and a writer who can do that probably doesn't need a gimmick to structure his work.
      &lt;/p&gt;&lt;p&gt;
	3/5.
	  Finished Saturday 20 January, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6013201080?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>bonanza</category><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/edible-economics-a-hungry-economist-explains-the-world/</guid><pubDate>Sat, 20 Jan 2024 00:00:00 GMT</pubDate></item></channel></rss>