<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson</title><link>https://simondobson.org/</link><description>Aut tace aut loquere meliora silentio</description><atom:link href="https://simondobson.org/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Fri, 15 Mar 2024 19:19:30 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>How Lisp is designing nanotechnology</title><link>https://simondobson.org/2024/03/15/how-lisp-is-designing-nanotechnology/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org73b3aa3" class="outline-2"&gt;
&lt;h2 id="org73b3aa3"&gt;How Lisp is designing nanotechnology&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org73b3aa3"&gt;
&lt;p&gt;
&lt;a href="https://www.youtube.com/watch?v=fytGL8vzGeQ"&gt;How Lisp is designing nanotechnology&lt;/a&gt; (video, 52 minutes).
&lt;/p&gt;

&lt;p&gt;
An interview on the &lt;a href="https://www.youtube.com/@DeveloperVoices"&gt;Developer Voices&lt;/a&gt; podcast with &lt;a href="https://www.schafmeistergroup.com/"&gt;Prof Christian
Schafmeister&lt;/a&gt; on designing enzymes using a custom dialect of Lisp
to control computational chemistry libraries.
&lt;/p&gt;

&lt;p&gt;
He initially started from an idea based on CAD applications
(written in Smalltalk), but rapidly realised there were too many
possible components and combinations to work with graphically and
so started treating it as a language-design problem – and
designed a custom Lisp based on &lt;a href="https://ecl.common-lisp.dev/"&gt;ECL&lt;/a&gt;. Lisp provides simplicity and
efficiency, as well as being a "forever" language in which
software keeps working over the long term.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>applications</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/15/how-lisp-is-designing-nanotechnology/</guid><pubDate>Fri, 15 Mar 2024 19:19:15 GMT</pubDate></item><item><title>A micro-manual for Lisp: Not the whole truth</title><link>https://simondobson.org/2024/03/15/a-micro-manual-for-lisp-not-the-whole-truth/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge13fcda" class="outline-2"&gt;
&lt;h2 id="orge13fcda"&gt;A micro-manual for Lisp: Not the whole truth&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge13fcda"&gt;
&lt;p&gt;
John McCarthy.  &lt;i&gt;&lt;a href="https://doi.org/10.1145/960118.808386"&gt;A Micro-Manual for Lisp: Not the Whole Truth&lt;/a&gt;&lt;/i&gt;. ACM
SIGPLAN Notices &lt;b&gt;13&lt;/b&gt;, pp.215–216. 1978.
&lt;/p&gt;

&lt;p&gt;
A "manual" in the sense of providing a complete implementation of
Lisp – in Lisp itself.
&lt;/p&gt;

&lt;p&gt;
Is that useful? A semantics expert would say "no", since such a
model has no real explanatory power: the recursion doesn't
bottom-out to define the concepts. However, a programming language
expert might disagree and observe that this is &lt;i&gt;meta-linguistic
abstraction&lt;/i&gt;, the use of one high-level language to capture the
definition of another. The "host" language provides a higher level
of abstraction than is usual when writing interpreters and
compilers, so it becomes easier to experiment with different forms
of "target" language as there's less low-level work to do. This
benefit exists even when host and target are the same: essentially
the target is bootstrapped and can then be adjusted while running
within an earlier version of itself.
&lt;/p&gt;

&lt;p&gt;
As far as I know this is the first example of meta-linguistic
abstraction in the computer science literature. The idea was
popularised by &lt;a href="/2024/01/27/structure-and-interpretation-of-computer-programs/"&gt;SICP&lt;/a&gt; (using Scheme), and forms the basis for a lot
of modern bootstrapped compilers.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/15/a-micro-manual-for-lisp-not-the-whole-truth/</guid><pubDate>Fri, 15 Mar 2024 17:25:10 GMT</pubDate></item><item><title>The Lisp machine</title><link>https://simondobson.org/2024/03/14/the-lisp-machine/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgdeaa592" class="outline-2"&gt;
&lt;h2 id="orgdeaa592"&gt;The Lisp machine&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdeaa592"&gt;
&lt;p&gt;
Richard Greenblatt.  &lt;i&gt;&lt;a href="https://dspace.mit.edu/bitstream/handle/1721.1/41114/AI_WP_079.pdf"&gt;The Lisp Machine&lt;/a&gt;&lt;/i&gt;. Working
paper 79. MIT AI Laboratory. 1974.
&lt;/p&gt;

&lt;p&gt;
A description of the architecture later built and sold by LMI.
&lt;/p&gt;

&lt;p&gt;
A visionary description of a machine to run Lisp at a
"non-prohibitive cost" of $70,000 per system. (The web tells me
that this is the equivalent of &lt;a href="https://www.in2013dollars.com/us/inflation/1974?amount=70000"&gt;$440,000&lt;/a&gt; in 2024.) A completely
integrated system based on a Cons processor and using a PDP-11 as
a console. A relocating, compacting, garbage collector with
invisible forwarding pointers. Non-linear spaghetti stacks to
support advanced programming constructs.
&lt;/p&gt;

&lt;p&gt;
One of the many notable facets of this design is one of its
proposals (the "frame pushdown list") to avoid excessive conses
and garbage collection overhead by maintaining lists of blocks of
particular sizes. It uses this approach to manage the creation of
call stack frames; modern Python implementations use this scheme
throughout to avoid heap fragmentation through allocating and
re-allocating blocks of different sizes. (Lisp has this feature
generally, of course, with its use of fixed-size cons cells.)
&lt;/p&gt;

&lt;p&gt;
It's also fascinating to see that, even at this early stage,
hardware design was being seen as an exercise in refinement to
maintain software-level abstractions even as features were being
pushed into hardware – while still providing optimised
implementations that were invisible to the programmer.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>hardware</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/14/the-lisp-machine/</guid><pubDate>Thu, 14 Mar 2024 16:50:46 GMT</pubDate></item><item><title>Lisp for the web</title><link>https://simondobson.org/2024/03/10/lisp-for-the-web/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org8cbb477" class="outline-2"&gt;
&lt;h2 id="org8cbb477"&gt;Lisp for the web&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8cbb477"&gt;
&lt;p&gt;
Adam Tornhill.  &lt;i&gt;&lt;a href="http://leanpub.com/lispweb"&gt;Lisp for the Web&lt;/a&gt;&lt;/i&gt;. Leanpub. 2015.
&lt;/p&gt;

&lt;p&gt;
A short, practical guide to build a dynamic web site entirely
using Common Lisp. Makes extensive use of several libraries,
including the intriguingly-named &lt;a href="https://edicl.github.io/hunchentoot/"&gt;hunchentoot&lt;/a&gt; web server (named
after a never-staged musical written by Frank Zappa), the &lt;a href="https://edicl.github.io/cl-who/"&gt;CL-WHO&lt;/a&gt;
HTML generator, and – perhaps most interesting – the &lt;a href="https://cliki.net/Parenscript"&gt;Parenscript&lt;/a&gt;
Lisp to Javascript compiler.
&lt;/p&gt;

&lt;p&gt;
One gain from using Lisp is the ability to wrap-up standard
constructions like page templates as macros. Other than this, it's
hard to assess whether the gains are all that significant. One
interesting point is that the whole development occurs in Lisp, so
there's no cognitive dissonance between writing the back-end and
the front-end: essentially the same argument for using &lt;a href="https://nodejs.org/"&gt;node.js&lt;/a&gt; as
a back-end framework. While Parenscript isn't a fully-featured
Lisp-in-the-browser it again can benefit from macros and other
features. There's a throwaway comment about linking it to &lt;a href="https://jquery.com/"&gt;jQuery&lt;/a&gt;,
although that isn't demonstrated in practice: it feels intriguing,
though, especially if there's a way to represent jQuery
functionality idiomatically in Lisp.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>applications</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/10/lisp-for-the-web/</guid><pubDate>Sun, 10 Mar 2024 10:28:45 GMT</pubDate></item><item><title>List processing</title><link>https://simondobson.org/2024/03/07/list-processing/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge901cfd" class="outline-2"&gt;
&lt;h2 id="orge901cfd"&gt;List processing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge901cfd"&gt;
&lt;p&gt;
J.M. Foster.  &lt;i&gt;List Processing&lt;/i&gt;. Macdonald and Co. 1967.
&lt;/p&gt;

&lt;p&gt;
A slim volume discussing list processing with reference to Lisp
and to other list processing systems of the time (including some
libraries embedded into Fortran).
&lt;/p&gt;

&lt;p&gt;
The most fascinating part of the book is its bibliography, which
references a lot of papers that have disappeared from the
collective memory of computer science, but whose implications
were profound.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/07/list-processing/</guid><pubDate>Thu, 07 Mar 2024 19:39:09 GMT</pubDate></item><item><title>Recursive functions of symbolic expressions and their computation by machine, Part I</title><link>https://simondobson.org/2024/03/07/recursive-functions-of-symbolic-expressions-and-their-computation-by-machine-part-i/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org59665c6" class="outline-2"&gt;
&lt;h2 id="org59665c6"&gt;Recursive functions of symbolic expressions and their computation by machine, Part I&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org59665c6"&gt;
&lt;p&gt;
John McCarthy.  &lt;i&gt;&lt;a href="https://doi.org/10.1145/367177.367199"&gt;Recursive Functions of Symbolic Expressions and
Their Computation by Machine, Part I&lt;/a&gt;&lt;/i&gt;. Communications of the ACM
&lt;b&gt;3&lt;/b&gt;, pp.184–195. 1960.
&lt;/p&gt;

&lt;p&gt;
The original Lisp paper from 1960, which opens:
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
A programming system called LISP (for LISt Processor) has been
developed for the IBM 704 computer…
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
The paper then proceeds to lay out everything that's since been
built on: the basic constructs, the use of cons cells (pairs) as a
data representation, the world's first garbage collection algorithm,
an equational semantics, and ideas for interpretation and
compilation. It's awesome, and humbling to read it and realise its
age and the vision of computing it developed.
&lt;/p&gt;

&lt;p&gt;
(Despite this paper being labelled Part I, incidentally, there
isn't a part II.)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/07/recursive-functions-of-symbolic-expressions-and-their-computation-by-machine-part-i/</guid><pubDate>Thu, 07 Mar 2024 19:34:45 GMT</pubDate></item><item><title>Paradigms of artificial intelligence programming: Case studies in Common Lisp</title><link>https://simondobson.org/2024/03/07/paradigms-of-artificial-intelligence-programming-case-studies-in-common-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgca14d34" class="outline-2"&gt;
&lt;h2 id="orgca14d34"&gt;Paradigms of artificial intelligence programming: Case studies in Common Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgca14d34"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/55/a8fc4d-075e-4914-90ea-c2bcc0021821/screenshot.png" alt="nil"&gt;
&lt;/p&gt;


&lt;p&gt;
Peter Norvig.  &lt;i&gt;&lt;a href="https://norvig.github.io/paip-lisp/"&gt;Paradigms of Artificial Intelligence Programming:
Case Studies in Common Lisp&lt;/a&gt;&lt;/i&gt;. Morgan Kaufmann. 1992.
&lt;/p&gt;

&lt;p&gt;
An absolute classic of both AI and Lisp, and really two books in
one. The applications presented cover the entire range of
"classic" AI up to the late 90s: expert systems, logic
programming, symbolic mathematics, knowledge representation,
constraint programming, game search, syntax-driven natural
language processing, and more.
&lt;/p&gt;

&lt;p&gt;
It uses Lisp as the programming vehicle, and doesn't shy-away from
depth, dealing with the effects of garbage collection (and how to
program effectively in its presence), the effects of different
representations, low-level optimisation and disassembly, and all
the approaches one needs to use Lisp in real, scalable practice.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/07/paradigms-of-artificial-intelligence-programming-case-studies-in-common-lisp/</guid><pubDate>Thu, 07 Mar 2024 19:07:31 GMT</pubDate></item><item><title>Common Lisp recipes: A problem-solution approach</title><link>https://simondobson.org/2024/03/06/common-lisp-recipes-a-problem-solution-approach/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org89dc61a" class="outline-2"&gt;
&lt;h2 id="org89dc61a"&gt;Common Lisp recipes: A problem-solution approach&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org89dc61a"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/2e/6e47a1-73a8-4ac5-a703-1f6ab0a2262b/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Edmund Weitz.  &lt;i&gt;&lt;a href="https://doi.org/10.1007/978-1-4842-1176-2"&gt;Common Lisp Recipes: A Problem-Solution Approach&lt;/a&gt;&lt;/i&gt;.
Apress. 2016.
&lt;/p&gt;

&lt;p&gt;
An extensive list of recipes for using common data structures,
how the differ in Lisp from the equivalents in other languages,
and what novel features Lisp has to offer. A great place to start
when moving away from being a beginner, and for dipping into in
search of solutions.
&lt;/p&gt;

&lt;p&gt;
It's probably strongest on the "gotchas" and dangers that Lisp
presents, but also has a lot to say about coding style and code
optimisation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/06/common-lisp-recipes-a-problem-solution-approach/</guid><pubDate>Wed, 06 Mar 2024 18:55:31 GMT</pubDate></item><item><title>The Common Lisp condition system</title><link>https://simondobson.org/2024/03/06/the-common-lisp-condition-system/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org73023d1" class="outline-2"&gt;
&lt;h2 id="org73023d1"&gt;The Common Lisp condition system&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org73023d1"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/06/efe121-b8ab-4558-a705-733fbbe7b1f9/978-1-4842-6134-7.webp" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Michał "phoe" Herda.  &lt;i&gt;&lt;a href="https://doi.org/10.1007/978-1-4842-6134-7"&gt;The Common Lisp Condition System&lt;/a&gt;&lt;/i&gt;. Apress. 2020.
&lt;/p&gt;

&lt;p&gt;
An enormously detailed look at the condition system, sometimes
regarded as the Lisp equivalent of exception-handling in other
languages.
&lt;/p&gt;

&lt;p&gt;
But that's massively unfair to the condition system, which is
really a way to deal with non-local transfers of control in the
most flexible way possible. Exceptions are &lt;i&gt;just one type&lt;/i&gt; of
this, and the condition system aims to separate three aspects that
are often combined in other languages: detecting and signalling a
condition, responding to a condition, and deciding on the binding
between the two, possibly combining responses differently in
different contexts. It's a set of concepts that are in many ways
foreign to a lot of other languages, and so justify the detail for
those occasions when these techniques are appropriate: deciding
&lt;i&gt;when&lt;/i&gt; they are appropriate is non-trivial, a matter of both
functionality and style.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/06/the-common-lisp-condition-system/</guid><pubDate>Wed, 06 Mar 2024 18:46:57 GMT</pubDate></item><item><title>Anatomy of Lisp</title><link>https://simondobson.org/2024/03/06/anatomy-of-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgfe57785" class="outline-2"&gt;
&lt;h2 id="orgfe57785"&gt;Anatomy of Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfe57785"&gt;
&lt;p&gt;
John Allen.  &lt;i&gt;Anatomy of Lisp&lt;/i&gt;. McGraw-Hill. ISBN
0-07-001115-X. 1978.
&lt;/p&gt;

&lt;p&gt;
This is a hard book to characterise. It's simultaneously an
introduction, a collection of advanced (for the time) programming
techniques, and a guide to some very low-level implementation
details. It contains a lot of the usual introductory material, but
then delves into different representational choices for the basic
data structures – lists, but also arrays and hash tables as well
as Lisp code itself – and for the frames needed to represent
function calls. It the tackles interpretation &lt;i&gt;versus&lt;/i&gt;
compilation, and even topics such as cross-compilation and
just-in-time or memoised compilation.
&lt;/p&gt;

&lt;p&gt;
It's impossible to read this book without thinking of &lt;a href="/2024/01/27/structure-and-interpretation-of-computer-programs/"&gt;SICP&lt;/a&gt;, and
indeed I think in many ways it's a direct precursor. (It's
referenced a couple of times in SICP.) It has that same
combination of high-level, semantics-driven programming combined
with descriptions of underlying mechanisms. Where I think it
mainly differs is that it mixes representations, using a more
semantics-driven notation and explicit assembler instructions
rather than sticking with Lisp variants for &lt;i&gt;everything&lt;/i&gt;. It's
only when you see the two approaches side by side that you realise
how &lt;i&gt;clear&lt;/i&gt; Lisp can be in radically different contexts..
&lt;/p&gt;

&lt;p&gt;
Another important book was published in 1978: Kernighan and
Ritchie's &lt;i&gt;&lt;a href="https://en.wikipedia.org/wiki/The_C_Programming_Language"&gt;The C programming language&lt;/a&gt;&lt;/i&gt;. The two books share a
certain low-level focus, but come to very different conclusions
about the correct approach to dynamic storage, as the following
footnote by Allen (slightly edited for clarity) illustrates:
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
Experiments have been performed in which Lisp programmers were
allowed to return "garbage" to the free-space list themselves. The
results were disastrous: list structure thought to be garbage was
returned to the free-space list even though the structure was
still being used by other computations.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
C, of course, accepts this "disaster" as a natural consequence of
manual allocation management. It encapsulates the different
attitudes of the two contemporary language communities, though:
one wanting a machine in which to think (and willing to use
computing power to simplify tasks), and those wanting raw
performance from limited hardware (and willing to complicate the
programming task to get it).
&lt;/p&gt;

&lt;p&gt;
Overall, Allen's book is a great attempt at an end-to-end
discussion of Lisp all the way down to the metal. Many of the
techniques are still relevant, at least as exemplars against
later, more efficient, techniques should be judged.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>implementation-techiques</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/06/anatomy-of-lisp/</guid><pubDate>Wed, 06 Mar 2024 18:38:17 GMT</pubDate></item></channel></rss>