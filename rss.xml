<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson</title><link>https://simondobson.org/</link><description>Aut tace aut loquere meliora silentio</description><atom:link href="https://simondobson.org/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Tue, 23 Jul 2024 08:18:50 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The art of the metaobject protocol</title><link>https://simondobson.org/2024/07/23/the-art-of-the-metaobject-protocol/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org7c8dd92" class="outline-2"&gt;
&lt;h2 id="org7c8dd92"&gt;The art of the metaobject protocol&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7c8dd92"&gt;
&lt;p&gt;
Gregor Kiczales, Jim des Rivières, and Daniel Bobrow.  &lt;i&gt;The Art of the
Metaobject Protocol&lt;/i&gt;. MIT Press. 1991.
&lt;/p&gt;


&lt;p&gt;
What &lt;i&gt;is&lt;/i&gt; a meta-object protocol? – or indeed a meta-object? This
book is perhaps the clearest exposition of these ideas.
&lt;/p&gt;

&lt;p&gt;
In most modern object-oriented languages an object is an instance
of a class. In keeping with using objects throughout, classes are
often also objects (or can be thought of as such), but are more
informatively thought of as &lt;b&gt;meta-objects&lt;/b&gt; that to facilitate the
construction of "real" objects. The methods on classes can also be
thought of as meta-objects defining the code executed by the
objects when invoked.
&lt;/p&gt;

&lt;p&gt;
The defining feature of CLOS is that these meta-objects are all
just Lisp objects, but objects that exist "off-stage" (to use this
book's very intuitive metaphor) and largely invisible to a basic
user. But they're as available to a power user as any other
objects: the "meta"-ness is a matter of design, not of
implementation. The interactions between objects and meta-objects,
for example which methods are called when invoked on a particular
object, are defined by the meta-object protocol (MOP), which is
itself defined in terms of methods on the meta-objects that shadow
the objects themselves.
&lt;/p&gt;

&lt;p&gt;
(Meta-object &lt;i&gt;protocol&lt;/i&gt; uses a term common in a lot of the earlier
object-oriented literature to mean a collection of functions:
meta-object &lt;i&gt;API&lt;/i&gt; would be a more modern rendering, although the
protocol includes the sequencing of API calls and their
relationships.)
&lt;/p&gt;

&lt;p&gt;
The goal of MOP programming is to let the programmer extend the
programming language towards to application domain, by automating
a lot of boilerplate code and providing the structures needed to
re-structure or analyse the code the programmer actually needs to
write. In this sense it's a continuation of the idea of macros as
powerful and potentially very domain-specific language and
compiler extensions. It's also a continuation of reifying
underlying language mechanisms in the language itself where they
can be re-specified and re-mixed.
&lt;/p&gt;

&lt;p&gt;
The first part of the book explains MOPs by defining a slightly
simplified version of CLOS ("Closette"). It assumes the reader
knows some CLOS, for example from &lt;a href="/2024/07/23/object-oriented-programming-on-common-lisp-a-programmer1s-guide-to-clos/"&gt;Object-oriented
programming on Common Lisp: A programmer's guide to CLOS&lt;/a&gt; (or
there's a stand-alone introduction in Appendix A), but it &lt;i&gt;only&lt;/i&gt;
assumes the knowledge level of a relative newcomer – and the
features then defined in Closette are just those parts of CLOS
that such a user would actually know and be comfortable with,
which is a brilliant piece of pedagogy that simplifies without
trivialising. It's really noticeable that Closette doesn't need
any extensions to Common Lisp: it's defined directly in the
language itself, which shows how powerful the underlying language
is. (Full CLOS requires a bit of language support too, at least
for efficiency.)
&lt;/p&gt;

&lt;p&gt;
Next come several examples of MOP usage, for example to re-define
how classes store their slots, or how to add attributes to slots
that can store metadata about their use or could be used to
provide higher-level operations. There's also a long discussion
about protocol design and how this has a massive impact on how
easy a system is to use for the programmer.
&lt;/p&gt;

&lt;p&gt;
The second part is a manual for the CLOS MOP, which is thorough
and useful, but perhaps less exciting than the first part. The
Common Lisp package &lt;a href="https://github.com/pcostanza/closer-mop"&gt;closer-mop&lt;/a&gt; provides this API as a
portable compatibility layer for use in real programs.
&lt;/p&gt;

&lt;p&gt;
There's also a discussion of practicalities like where awkward
circularities occur and how to break them, which is actually a
great example how to do good protocol/API design. In an example of
&lt;a href="/2024/07/23/the-roots-of-lisp/"&gt;Paul Graham's dictum&lt;/a&gt; that modern languages evolve by mixing Lisp
concepts into a different base, MOP ideas appear in lots of other
languages, either for real (Smalltalk, at to a lesser extent
&lt;a href="https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/"&gt;Python&lt;/a&gt;) or just for introspection (Java). Even someone not
planning on writing Lisp would benefit from reading this book just
to see the ideas in their full generality.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>oo</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/23/the-art-of-the-metaobject-protocol/</guid><pubDate>Tue, 23 Jul 2024 08:13:16 GMT</pubDate></item><item><title>Object-oriented programming on Common Lisp: A programmer's guide to CLOS</title><link>https://simondobson.org/2024/07/23/object-oriented-programming-on-common-lisp-a-programmer1s-guide-to-clos/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org1c558c9" class="outline-2"&gt;
&lt;h2 id="org1c558c9"&gt;Object-oriented programming on Common Lisp: A programmer's guide to CLOS&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1c558c9"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/41/584da1-ef33-41dd-8091-43c3999f6451/clos.jpg" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Sonja Keene.  &lt;i&gt;Object-Oriented Programming in Common Lisp: A
Programmer’s Guide to CLOS&lt;/i&gt;. Addison-Wesley. ISBN 0-201-17589-4. 1989.
&lt;/p&gt;

&lt;p&gt;
The definitive practical guide to using the Common Lisp Object
System (CLOS). It's written from a similar perspective to other
object-oriented tutorials, which makes it very accessible for
those who've had experience with something like Java or Python.
However, CLOS &lt;i&gt;isn't&lt;/i&gt; just objects in Lisp, and &lt;i&gt;isn't&lt;/i&gt; in any sense
just an object-oriented extension. It can take some time to change
mindset enough to use it properly, and this book is a great guide
to the core differences.
&lt;/p&gt;

&lt;p&gt;
Firstly, it follows a completely different model of how to
associate functions with data. Instead CLOS uses "generic"
functions, where the exact code called is dispatched dynamically
based on the types of any or all parameters: so it's perfectly
possible to have several definitions of the &lt;i&gt;same&lt;/i&gt; generic function
operating on objects of the &lt;i&gt;same&lt;/i&gt; class, but taking arguments of
&lt;i&gt;different&lt;/i&gt; types. This &lt;i&gt;multiple dispatch&lt;/i&gt; is a lot more flexible.
&lt;/p&gt;

&lt;p&gt;
The second point actually follows from this. CLOS' generic
functions can be defined to &lt;i&gt;any&lt;/i&gt; Lisp types: in fact they're not
statically associated with classes at all, and can operate on &lt;i&gt;any&lt;/i&gt;
types (classes or not) across the type hierarchy. This makes it
closer to Haskell's type classes than to Smalltalk's (or Java's)
virtual methods, which are strongly bound to classes.
&lt;/p&gt;

&lt;p&gt;
Thirdly, CLOS methods can be combined in a range of interesting
ways, not simply by overriding previous definitions – and indeed
you can define your own if you need to. And like Smalltalk
(but unlike Java) CLOS classes have "metaclasses" that can
re-define their basic functions. &lt;a href="/2024/07/23/the-art-of-the-metaobject-protocol"&gt;The art of the metaobject protocol&lt;/a&gt;
is a better source for this level of detail.
&lt;/p&gt;

&lt;p&gt;
The examples in the book delve into these features by means of
sensibly-sized challenges that can be used to illustrate both
basic design and implementation. and more advanced ideas like
re-defining classes on the fly.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>oo</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/23/object-oriented-programming-on-common-lisp-a-programmer1s-guide-to-clos/</guid><pubDate>Tue, 23 Jul 2024 08:03:11 GMT</pubDate></item><item><title>The roots of Lisp</title><link>https://simondobson.org/2024/07/23/the-roots-of-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org0318c4d" class="outline-2"&gt;
&lt;h2 id="org0318c4d"&gt;The roots of Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0318c4d"&gt;
&lt;p&gt;
&lt;a href="http://www.paulgraham.com/rootsoflisp.html"&gt;http://www.paulgraham.com/rootsoflisp.html&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
(Only has an PostScript version, but a PDF is available
&lt;a href="https://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf"&gt;here&lt;/a&gt;.)
&lt;/p&gt;

&lt;p&gt;
Re-visits McCarthy's discoveries (or inventions, depending on
your point of view), translating the &lt;a href="/2024/03/07/recursive-functions-of-symbolic-expressions-and-their-computation-by-machine-part-i/"&gt;earliest work&lt;/a&gt; into modern
Lisp notation.
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
It's worth understanding what McCarthy discovered, not just as a
landmark in the history of computers, but as a model for what
programming is tending to become in our own time. It seems to me that
there have been two really clean, consistent models of programming so
far: the C model and the Lisp model. These two seem points of high
ground, with swampy lowlands between them. As computers have grown
more powerful, the new languages being developed have been moving
steadily toward the Lisp model. A popular recipe for new programming
languages in the past 20 years has been to take the C model of
computing and add to it, piecemeal, parts taken from the Lisp model,
like runtime typing and garbage collection.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
Does a great job of making the central insights accessible,
including re-phrasing the meta-circular Lisp interpreter so as to
be executable in modern Common Lisp.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/23/the-roots-of-lisp/</guid><pubDate>Tue, 23 Jul 2024 08:00:41 GMT</pubDate></item><item><title>TIL: The most powerful one-line program in the world</title><link>https://simondobson.org/2024/07/17/til-the-most-powerful-one-line-program-in-the-world/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge9df00b" class="outline-2"&gt;
&lt;h2 id="orge9df00b"&gt;TIL: The most powerful one-line program in the world&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge9df00b"&gt;
&lt;p&gt;
Well, the most powerful I've found so far, anyway.
&lt;/p&gt;

&lt;p&gt;
Given my current obsession with &lt;a href="/categories/lisp/"&gt;Lisp&lt;/a&gt; you might reasonably expect it
to be in that language. But it isn't: it's in &lt;a href="https://en.wikipedia.org/wiki/APL_(programming_language)"&gt;APL&lt;/a&gt;, and it performs
one complete generation of &lt;a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life"&gt;Conway' Game of Life&lt;/a&gt; in one line of code:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  Life←{↑↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
…and does so inexplicably to anyone who doesn't know APL,
obviously, but the &lt;a href="https://aplwiki.com/wiki/John_Scholes%27_Conway%27s_Game_of_Life"&gt;basic algorithm&lt;/a&gt; is simple:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Take an array with 1 in each occupied cell and 0 elsewhere&lt;/li&gt;
&lt;li&gt;Build four new arrays by exchanging each element with its
neighbour up, down, left, and right&lt;/li&gt;
&lt;li&gt;Sum these arrays, which places the number of neighbours into each cell&lt;/li&gt;
&lt;li&gt;Cut-off these values to be 1 if the cell has a value of 3 or 4,
and 0 otherwise&lt;/li&gt;
&lt;li&gt;Re-format the arrays back into the starting configuration&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
I checked it out using &lt;a href="https://www.gnu.org/software/apl/"&gt;GNU APL&lt;/a&gt; and it works fine.
&lt;/p&gt;

&lt;p&gt;
I discovered this gem by accident, actually implemented &lt;a href="https://github.com/chmykh/apl-life"&gt;in APL in
Forth&lt;/a&gt; where someone has developed APL as an embedded DSL within
&lt;a href="https://en.wikipedia.org/wiki/Forth_(programming_language)"&gt;Forth&lt;/a&gt; (another language with which I have history). After a bit of
digging I found a similar APL in Lisp, &lt;a href="https://github.com/phantomics/april"&gt;April&lt;/a&gt;, which clearly needs
exploring.
&lt;/p&gt;

&lt;p&gt;
In many ways APL and Lisp are parallel tracks within programming
language evolution, taking a single data structure (lists or arrays)
and providing powerful ways to manipulate them. Lisp of course has
been extended with other data structures, including arrays, which
makes the fusion of array- and list-based programming rather
attractive.
&lt;/p&gt;

&lt;p&gt;
I can't help asking myself what would have happened if APL hadn't
fallen by the wayside. (I think this was inevitable, incidentally,
once the syntax became fixed: any language that requires its own
character set was always going to struggle.) We now have huge
applications for array processing, from graphics to machine
learning, and GPUs are from one perspective just APL accelerator
co-processors. The ideas are still massively relevant.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>apl</category><category>programming</category><category>til</category><guid>https://simondobson.org/2024/07/17/til-the-most-powerful-one-line-program-in-the-world/</guid><pubDate>Wed, 17 Jul 2024 09:20:53 GMT</pubDate></item><item><title>A New Kind of Science</title><link>https://simondobson.org/goodreads/a-new-kind-of-science/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1386925097l/238558._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Stephen Wolfram
	  (1997)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      I have very mixed feelings about this book. On the one hand it's a triumph of computational experimental technique, taking an idea that was well-known (cellular automata) and subjecting it to rigorous exploration. This uncovers a lot of new science, not least showing that complex systems can arise from even the simplest set of rules, but also that this complexity falls into classes that show graded complexity depending purely on the fine structure of the initial conditions. That's a massively important discovery.&lt;br&gt;&lt;br&gt;On the other hand.... It's hard to describe this as a "new kind" of science. "New science," yes, but not indicative of a new paradigm or &lt;i&gt;way&lt;/i&gt; of doing science, other than by emphasising the structured use of simulation. Wolfram completely over-sells what he's achieved, making claims he can't substantiate to aggrandise his own contributions. And that's a shame, not least because it's so &lt;i&gt;unnecessary&lt;/i&gt;: Wolfram has made some important discoveries, both here and to several other branches of physics and computer science, as well as popularising computational methods and tools. It's tragic that he doesn't seem to be able to appreciate himself as being sufficient.&lt;br&gt;&lt;br&gt;The book is also quite terribly written, being almost half-composed of footnotes, meaning a reader is constantly skipping forwards and back: difficult in print, and I suspect impossible in a digital edition unless it's been very carefully hyperlinked. And the footnotes are often important! – indeed, they often provide evidence to back-up a claim in the main text that's entirely unsupportable from what's been presented. So it can be seen as both excessively long and insufficiently detailed, which is quite an achievement.
      &lt;/p&gt;&lt;p&gt;
	3/5.
	  Finished Sunday 7 July, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/4934435584?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/a-new-kind-of-science/</guid><pubDate>Sun, 07 Jul 2024 00:00:00 GMT</pubDate></item><item><title>Shikasta: Canopus Dans Argos: Archives</title><link>https://simondobson.org/goodreads/shikasta-canopus-dans-argos-archives/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1516764001l/38189412._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Doris Lessing
	  (1979)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      Why is modern civilisation so self-destructive and complicated? The answer from this alternative history is that a previously time of happiness and long lives was subverted by a change in the universal forces to induce the current malaise.&lt;br&gt;&lt;br&gt;I did enjoy this book, but it does live up to its sub-title: &lt;i&gt;Personal, psychological, historical documents relating to visit by Johor (George Sherban) Emissary (Grade 9) 87th of the Period of the Last Days&lt;/i&gt;. It's told in a very disjointed form using purported reports and other documents, much of the time from the diary of a young girl who doesn't really know what's going on, and so can't really advance the plot very effectively. That makes it hard work, even though the writing and the overall premise are excellent.
      &lt;/p&gt;&lt;p&gt;
	2/5.
	  Finished Sunday 7 July, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/5723914316?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/shikasta-canopus-dans-argos-archives/</guid><pubDate>Sun, 07 Jul 2024 00:00:00 GMT</pubDate></item><item><title>Let over Lambda</title><link>https://simondobson.org/2024/07/05/let-over-lambda/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgfbf54c4" class="outline-2"&gt;
&lt;h2 id="orgfbf54c4"&gt;Let over Lambda&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfbf54c4"&gt;
&lt;p&gt;
Doug Hoyte.  &lt;i&gt;&lt;a href="http://letoverlambda.com"&gt;Let over Lambda&lt;/a&gt;&lt;/i&gt;. HCSW and Hoytech. ISBN
978-1-4357-1275-1. 2008.
&lt;/p&gt;

&lt;p&gt;
A gloriously opinionated (in the best way) take on Lisp macro
programming. The author treats Lisp – one of the first languages
– as the ultimate, &lt;i&gt;final&lt;/i&gt; language to which all others can (and
should) be translated, since they're simply special cases of Lisp
forms. And he makes a surprisingly compelling case.
&lt;/p&gt;

&lt;p&gt;
The material builds extensively on &lt;a href="/2024/07/05/on-lisp/"&gt;On Lisp&lt;/a&gt;, re-presenting the
idea of &lt;i&gt;anaphoric&lt;/i&gt; macros (those that bind lexical variables for
use in their bodies) and extending them with &lt;i&gt;pandoric&lt;/i&gt; macros
that allow introspection into an otherwise closed lexical
environment. A lot of these examples feel contrived as presented,
but the techniques are anything but: powerful ways to build
abstractions.
&lt;/p&gt;

&lt;p&gt;
The finale is the implementation of Forth in Lisp, and then a
reflection to allow Forth programs to define Lisp functions –
converting a (transparent) threaded-interpreted structure into an
(opaque) code block. It's a slightly non-standard Forth, but it's
true to the basics and exposes issues like the implementations of
interpretation, compilation, and tail recursion really well. It's
only another step to explore Lisp &lt;i&gt;implemented&lt;/i&gt; in Forth through
the medium of macro programming, which deserves a book itself.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/05/let-over-lambda/</guid><pubDate>Fri, 05 Jul 2024 10:19:07 GMT</pubDate></item><item><title>On Lisp</title><link>https://simondobson.org/2024/07/05/on-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgaac5f5f" class="outline-2"&gt;
&lt;h2 id="orgaac5f5f"&gt;On Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgaac5f5f"&gt;
&lt;p&gt;
Paul Graham.  &lt;i&gt;&lt;a href="http://www.paulgraham.com/onlisp.html"&gt;On Lisp: Advanced Techniques for Common Lisp&lt;/a&gt;&lt;/i&gt;. Prentice
Hall. ISBN 0-13-030552-9. 1993.
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
An ideal world is left as an exercise to the reader.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
One of the most famous advanced treatments of Lisp. Essentially
it's a book in two parts. The first deals with the traditional
advanced topics of functional programming such as identifying
patterns that can be factored-out into higher-order functions and
re-used. But the second, better-known, part deals with macro
programming in extraordinary detail and with enormous creativity,
including developing macros for continuations and several embedded
languages.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/05/on-lisp/</guid><pubDate>Fri, 05 Jul 2024 10:16:34 GMT</pubDate></item><item><title>Debugging Lisp</title><link>https://simondobson.org/2024/07/05/debugging-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgb9a4deb" class="outline-2"&gt;
&lt;h2 id="orgb9a4deb"&gt;Debugging Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb9a4deb"&gt;
&lt;p&gt;
&lt;a href="https://malisper.me/debugging-lisp-part-1-recompilation/"&gt;Debugging Lisp&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A four-part blog post series on debugging Lisp, covering:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Live recompilation of code from inside a debugging session,
together with re-executing changed code from within a running
stack trace&lt;/li&gt;
&lt;li&gt;Inspecting objects and interacting with traces of function calls&lt;/li&gt;
&lt;li&gt;Redefining classes, and how to ensure that existing instances
are upgraded to be compatible with the new definition&lt;/li&gt;
&lt;li&gt;Restarts, the neglected part of the condition system that
controls how programs continue after encountering errors&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
The first two are essential, and show how &lt;i&gt;different&lt;/i&gt; Lisp
programming is from using other languages. In fact it requires a
considerable mental shift to re-acquire the right reflexes for
dealing with errors and debugging in a fully interactive
environment: well, it did for me, anyway. We're not used to
interactivity in large development environments. There is seldom
any need to close down a running Lisp session and start again, as
everything can usually be changed and adapted within a session.
This is very unlike the usual compile-edit-debug cycles we've
become accustomed to.
&lt;/p&gt;

&lt;p&gt;
The third post – on redefining classes – shows how one can
upgrade a program that simply &lt;i&gt;has&lt;/i&gt; to keep running, because its
live state upgrade can be programmed too.
&lt;/p&gt;

&lt;p&gt;
The most significant part of the mental shift is to realise that
the debugger is written in Lisp itself, and makes use of restarts
and other features to provide the interface. This is a consequence
of the degree of exposure of the Lisp run-time structures into to
language itself, where they can be examined and manipulated using
the full power of the language – and then be re-started or
discarded as required.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/05/debugging-lisp/</guid><pubDate>Fri, 05 Jul 2024 10:14:22 GMT</pubDate></item><item><title>Ultra-Processed People: The Science Behind Food That Isn't Food</title><link>https://simondobson.org/goodreads/ultra-processed-people-the-science-behind-food-that-isnt-food/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1679715862l/62586003._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Chris van Tulleken
	  (2023)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      Food &lt;i&gt;versus&lt;/i&gt; food-shaped industrial products.&lt;br&gt;&lt;br&gt;Ultra-processed food (UPF) is pervasive in modern diets, and with it comes a litany of actual, conjectured, and supposed harms. UPF itself is a strange beast, taking food crops and turning them into pure components that can then be re-mixed to construct new products. This has some perverse consequences, such as flavours being removed from purified and "modified" oils and starches in order to make them more broadly usable – and then having &lt;i&gt;those same flavours&lt;/i&gt; re-introduced later in the process, again in "modified" form. That sounds insane – how can it be cheaper than using the original oil? – but in fact it makes perfet commercial sense for companies wanting fungible raw materials to produce unvarying, known-ahead-of-time tastes and textures. &lt;br&gt;&lt;br&gt;The resulting products (I'm now reluctant to call them foods), being created in labs, can be re-worked in pursuit of particular commercial goals, for example by adding powdered soya when looking to create a "high-protein" snack. They can also be re-engineered to be far more pleasurable and addictive for consumers, for example by hacking the body's responses to food (which are themselves coming to be understood as far more subtle and complicated than we used to think).&lt;br&gt;&lt;br&gt;van Tulleken has a science background, and it shows in the writing: most of the claims are carefully framed and evidenced. His background also saves him from falling for the industry's faux-refutations about there not being definitive causal links to specific harms: randomised controlled trials &lt;i&gt;aren't&lt;/i&gt; the "scientific gold standard" in situations where they're impossible to conduct in the real world, and epidemiological evidence coupled with some knowledge of the possible harm pathways can provide sufficient evidence. Having said that, he does sometimes deviate from this careful path, and there are a few instances of words like "may" and "could" doing a lot of heavy lifting.&lt;br&gt;&lt;br&gt;One of the most powerful elements of the book is that it simultaneously doesn't preach or prescribe, but does offer suggestions for ways forward. UPF is very difficult to precisely define, and is therefore difficult to legislate for or avoid. Does a single stabiliser in a product render it UPF? – because if so literally &lt;i&gt;anything in a packet&lt;/i&gt; would be included. van Tulleken also takes aim at some of the wider social drivers of UPF, notably its cheapness and ease of preparation compared to "real" food, reinforcing poor diet as a consequence of poverty. He also suggests some interesting policy options, while also taking aim at a policy infrastructure that's heavily co-opted by the UPF industry. Regulators and the food industry are &lt;i&gt;not&lt;/i&gt; partners and have goals that are mutually irreconcilable within the current framework of pre-eminent shareholder value.
      &lt;/p&gt;&lt;p&gt;
	5/5.
	  Finished Thursday 4 July, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6565805510?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>bonanza</category><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/ultra-processed-people-the-science-behind-food-that-isnt-food/</guid><pubDate>Thu, 04 Jul 2024 00:00:00 GMT</pubDate></item></channel></rss>