<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson</title><link>https://simondobson.org/</link><description>Aut tace aut loquere meliora silentio</description><atom:link href="https://simondobson.org/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Thu, 05 Sep 2024 14:48:04 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Guard methods on CLOS generic functions</title><link>https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgdad2bf2" class="outline-2"&gt;
&lt;h2 id="orgdad2bf2"&gt;Guard methods on CLOS generic functions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdad2bf2"&gt;
&lt;p&gt;
There are times when one wants to be able to guard a method's
execution. A typical case is for callbacks, where we only want the
callback to run under certain circumstances – but it's easier to
write the callbacks themselves as though they'll &lt;i&gt;always&lt;/i&gt; be called.
&lt;/p&gt;

&lt;p&gt;
Object-oriented programs typically use a pattern for this: they
split the function into two methods, one for the guard and one for
the action being guarded. A sub-class can then override the guard
independently of the action, and some sub-classes may override
both guard and action.
&lt;/p&gt;

&lt;p&gt;
This splitting seems a little awkward, though, and there are times
when I'd prefer to have everything (guard and action) defined as
part of the one method. Fortunately there's a Lisp-ier solution
involving defining a new method combination to get exactly this
behaviour.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc6422b3" class="outline-3"&gt;
&lt;h3 id="orgc6422b3"&gt;Standard method combination&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc6422b3"&gt;
&lt;p&gt;
CLOS, unlike most languages, allows a programmer to control how
methods are combined in terms of overriding. The "standard"
combination allows for &lt;code&gt;:before&lt;/code&gt;, &lt;code&gt;:after&lt;/code&gt;, and &lt;code&gt;:around&lt;/code&gt; methods as
well as undecorated "primary" methods.
&lt;/p&gt;

&lt;p&gt;
When a generic function is called, the list of applicable primary
methods is determined based on the types of arguments. most
specific method first&lt;sup&gt;&lt;a id="fnr.most-specific-first" class="footref" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fn.most-specific-first" role="doc-backlink"&gt;1&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;p&gt;
The same process is performed for all applicable &lt;code&gt;:before&lt;/code&gt; methods,
and then again for applicable &lt;code&gt;:after&lt;/code&gt; methods, and then &lt;i&gt;again&lt;/i&gt; for
&lt;code&gt;:around&lt;/code&gt; methods. The &lt;code&gt;:after&lt;/code&gt; and &lt;code&gt;:around&lt;/code&gt; are always ordered most
specific first, while the &lt;code&gt;:before&lt;/code&gt; methods are always ordered
least-specific first.
&lt;/p&gt;

&lt;p&gt;
Once these lists have been constructed, the "effective" method
that results is called. If there are &lt;code&gt;:around&lt;/code&gt; methods, they are
called in order. An &lt;code&gt;:around&lt;/code&gt; method may, as part of its body, call
&lt;code&gt;call-next-method&lt;/code&gt; to invoke the next-most-specific &lt;code&gt;:around&lt;/code&gt; method
– or may not.
&lt;/p&gt;

&lt;p&gt;
If a call to &lt;code&gt;call-next-method&lt;/code&gt; has no more &lt;code&gt;:around&lt;/code&gt; methods to call
– or of there were no &lt;code&gt;:around&lt;/code&gt; methods defined – all the &lt;code&gt;:before&lt;/code&gt;
methods are run and their return values discarded. Then the
primary methods are run in the same manner as &lt;code&gt;:around&lt;/code&gt; methods,
with any calls to &lt;code&gt;call-next-method&lt;/code&gt; calling the next primary
method. After the primary methods have returned, all the &lt;code&gt;:after&lt;/code&gt;
methods are run and their return values discarded. The result of
the method call is the result returned from the primary methods.
The process is roughly like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;prog1&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In this code, &lt;code&gt;call-method&lt;/code&gt; calls its first method argument, and
any call to &lt;code&gt;call-next-method&lt;/code&gt; calls the next method in the list.
&lt;code&gt;call-methods&lt;/code&gt; calls all the methods in a list of methods,
discarding their return values.
&lt;/p&gt;

&lt;p&gt;
Contrast that with Java or Python, where methods on more-specific
classes override those on less-specific, and have the option to
call up to the superclass method. Essentially this makes all
methods similar to &lt;code&gt;:around&lt;/code&gt;, and there's no real equivalent of
&lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga578c83" class="outline-3"&gt;
&lt;h3 id="orga578c83"&gt;Other method combinations&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga578c83"&gt;
&lt;p&gt;
The above is referred to as &lt;i&gt;standard method combination&lt;/i&gt;, implying
the existence of &lt;i&gt;non-standard&lt;/i&gt; combination. CLOS lets the
programmer define new combinations, and indeed defines a few
itself. For our purposes the most important alternative method
combination is &lt;code&gt;and&lt;/code&gt;, which runs all primary methods within an &lt;code&gt;and&lt;/code&gt;
form treating all methods as predicates. There are only primary
methods allowed.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org85cc730" class="outline-3"&gt;
&lt;h3 id="org85cc730"&gt;Guards as method combination&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org85cc730"&gt;
&lt;p&gt;
For our use case, we want to be able to return values from primary
methods, and allow &lt;code&gt;:around&lt;/code&gt;, &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt; methods. However, we
&lt;i&gt;also&lt;/i&gt; want to have some methods act as predicates that guard the
execution of the effective method thus formed. We want to be able
to add guard methods that are always run first, regardless of their
specificity, and then run the effective method only if &lt;i&gt;all&lt;/i&gt; the guards
are satisfied. The net result is that all parts of the generic
function are provided as methods on it, but some can now be boolean
guards that act as gatekeepers on the rest of the methods.
Naturally we want the guards to be selected for specificity
alongside the other methods, letting the CLOS machinery pick &lt;i&gt;all&lt;/i&gt;
the functionality that's appropriate to a particular method call.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2b8a7b0" class="outline-3"&gt;
&lt;h3 id="org2b8a7b0"&gt;Why this isn't just &lt;code&gt;:around&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2b8a7b0"&gt;
&lt;p&gt;
It might sound like we can get this behaviour using &lt;code&gt;:around&lt;/code&gt;
methods that perform guarding. But we can't – quite.
&lt;/p&gt;

&lt;p&gt;
Suppose we define a primary method:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
We can write a guard quite happily as an &lt;code&gt;:around&lt;/code&gt; method:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-next-method&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This method will only allow the method to proceed when the
condition holds, otherwise it returns &lt;code&gt;nil&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
(52 NIL)
&lt;/p&gt;

&lt;p&gt;
So far so good.
&lt;/p&gt;

&lt;p&gt;
However, the problem is that CLOS orders the &lt;code&gt;:around&lt;/code&gt; methods
most specific first. Suppose we have another &lt;code&gt;:around&lt;/code&gt; method
specialised against a more specific type:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-next-method&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When this method is called with an integer this method gets run
before the previous guard:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
6
&lt;/p&gt;

&lt;p&gt;
and we get a non-nil result, despite the guard method indicating
that we shouldn't. If we provide an argument that doesn't trigger
the first &lt;code&gt;:around&lt;/code&gt; method, then we can get caught by the guard:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
NIL
&lt;/p&gt;

&lt;p&gt;
This is of course perfectly sensible behaviour in many cases.
However, it does mean that the "guards" we're supplying are
executed as &lt;i&gt;part&lt;/i&gt; of the effective method rather than &lt;i&gt;before&lt;/i&gt; it,
and therefore can't guarantee that the method is properly guarded
by &lt;i&gt;all&lt;/i&gt; the guards, regardless of their specialisation. Another
way of looking at this is that a later, more specialised, "guard"
can override one set by an earlier, less specialised, method,
which again may not be what's desired.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org88504e4" class="outline-3"&gt;
&lt;h3 id="org88504e4"&gt;A &lt;code&gt;guarded&lt;/code&gt; method combination&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org88504e4"&gt;
&lt;p&gt;
Fortunately we can get the behaviour we want by defining a new
method combination, &lt;code&gt;guarded&lt;/code&gt;. A &lt;code&gt;guarded&lt;/code&gt; generic function accepts
five method qualifiers:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;undecorated primary methods;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt; methods that run before and after the
primary methods;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:around&lt;/code&gt; methods that run around the &lt;code&gt;:before&lt;/code&gt;-primary-&lt;code&gt;:after&lt;/code&gt;
combination; and&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:if&lt;/code&gt; methods that act as guards, running before any &lt;code&gt;:around&lt;/code&gt;
methods to determine whether &lt;i&gt;any&lt;/i&gt; of the "functional" methods
are run or not&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
We first need a helper function&lt;sup&gt;&lt;a id="fnr.call-methods" class="footref" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fn.call-methods" role="doc-backlink"&gt;2&lt;/a&gt;&lt;/sup&gt; to construct the
code to run the chain of &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt; methods while
discarding their return values.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;methods&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;"Return `call-method' forms for all METHODS."&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mapcar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="nv"&gt;methods&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
We can then use the macro &lt;code&gt;define-method-combination&lt;/code&gt; to define our
new method combination.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;define-method-combination&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&amp;amp;optional&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:most-specific-first&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;ifs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:if&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:before&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:required&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:after&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;before-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;after-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;primary-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;core-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;prog1&lt;/span&gt;
&lt;span class="w"&gt;                                  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
&lt;span class="w"&gt;                                    &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="nv"&gt;before-form&lt;/span&gt;
&lt;span class="w"&gt;                                    &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;primary-form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                                &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="nv"&gt;after-form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;around-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;
&lt;span class="w"&gt;                               &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                                             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                                              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;core-form&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;                               &lt;/span&gt;&lt;span class="nv"&gt;core-form&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ifs&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ifs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;around-form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="nv"&gt;around-form&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The macro is described in detail in the &lt;a href="https://novaspec.org/cl/f_define-method-combination"&gt;hyperspec&lt;/a&gt;, but its
behaviour is quite simple. The list of forms (&lt;code&gt;arounds&lt;/code&gt; and so on)
define variables that extract the methods that have the given
decorations – so &lt;code&gt;arounds&lt;/code&gt; gets a list of &lt;code&gt;:around&lt;/code&gt; methods,
&lt;code&gt;primaries&lt;/code&gt; gets the undecorated (primary) methods, and so on. In
particular, &lt;code&gt;ifs&lt;/code&gt; gets any methods decorated with &lt;code&gt;:if&lt;/code&gt;: these are
the guards.
&lt;/p&gt;

&lt;p&gt;
The body of the macro constructs the code needed to build the
methods' behaviours. The &lt;code&gt;let*&lt;/code&gt; defines the code for the different
parts. &lt;code&gt;core-form&lt;/code&gt; is slightly optimised in the case when there is
only one primary method; otherwise it runs the &lt;code&gt;:before&lt;/code&gt; methods
and then the primary method, captures the result of the latter,
then runs the &lt;code&gt;:after&lt;/code&gt; methods, and then returns its result. (This
is the first time I've ever used &lt;code&gt;prog1&lt;/code&gt; for real: now I know why
it exists.) If there are &lt;code&gt;:around&lt;/code&gt; methods, &lt;code&gt;around-form&lt;/code&gt; wraps up a
list consisting of the &lt;code&gt;:around&lt;/code&gt; methods and a method constructed
from &lt;code&gt;core-form&lt;/code&gt;, letting it be run as the result of the final
&lt;code&gt;call-next-method&lt;/code&gt; call.
&lt;/p&gt;

&lt;p&gt;
The body of the &lt;code&gt;let*&lt;/code&gt; wraps-up &lt;code&gt;around-form&lt;/code&gt; within an &lt;code&gt;if&lt;/code&gt; whose
condition is the conjunction of all the &lt;code&gt;:if&lt;/code&gt; methods. Only if all
these methods return true (well, not &lt;code&gt;nil&lt;/code&gt; in the usual Lisp style)
will the code of &lt;code&gt;around-form&lt;/code&gt; be executed. Again the code is
optimised for the case where there are no guards, in which case
we just get &lt;code&gt;around-form&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Notice that &lt;code&gt;define-method-combination&lt;/code&gt; returns &lt;i&gt;code&lt;/i&gt;, like all
macros: it doesn't execute the methods itself. This is a hint as
to what happens off-stage: CLOS uses the method combination at
compile time to construct effective methods which can then be
cached to minimise the performance hit from all the flexibility
provided by method combination.
&lt;/p&gt;

&lt;p&gt;
Now we can re-do our example from above:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;;; a generic function defined to use our new method combination&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defgeneric&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:method-combination&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;;; the functionality, split into two methods&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-next-method&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;;; this guard used to be :around and is now :if&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
(52 NIL NIL)
&lt;/p&gt;

&lt;p&gt;
The guard now stops execution of the effective method if its
condition isn't met – and if it &lt;i&gt;is&lt;/i&gt; met, passes control through
to the complete method stack. This happens regardless of where
the guard is specialised in terms of the class hierarchy: the
guards run before any "functional" code. (That &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt;
methods work too, and multiple guards, and that the combination
works when applied to class hierarchies, are left as exercises to
the reader.)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org53c5ffd" class="outline-3"&gt;
&lt;h3 id="org53c5ffd"&gt;Critique&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org53c5ffd"&gt;
&lt;p&gt;
You may object to this solution on the grounds that it introduces
a weird asymmetry into methods: some as functional and some as
guards, with different return types. Maybe you prefer to keep
guards in separate methods using the usual object-oriented
pattern. That's entirely reasonable. But I think there are
sufficient cases where this kind of guarding makes sense to have
it as a pattern, especially as it has no effect unless explicitly
selected for a generic function.
&lt;/p&gt;

&lt;p&gt;
I have to say I'm amazed how &lt;i&gt;little&lt;/i&gt; code is needed: around 30
lines, including the helper function. It shows off the power of
CLOS, and how it's possible to change even the basic underlying
structures of the object system with relative ease. But it also
shows how Lisp opens-up the space of programming styles, things
that benefit from being policies that can be changed, rather than
hard-coding one particular choice.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;h2 class="footnotes"&gt;Footnotes: &lt;/h2&gt;
&lt;div id="text-footnotes"&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.most-specific-first" class="footnum" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fnr.most-specific-first" role="doc-backlink"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara" role="doc-footnote"&gt;&lt;p class="footpara"&gt;
This is also programmable when required, for
example to run methods least-specific-first.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.call-methods" class="footnum" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fnr.call-methods" role="doc-backlink"&gt;2&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara" role="doc-footnote"&gt;&lt;p class="footpara"&gt;
I got the idea for this function from
&lt;a href="https://github.com/sellout/method-combination-utilities"&gt;method-combination-utilities&lt;/a&gt;, and included it literally to avoid
creating another dependency.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>programming</category><guid>https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/</guid><pubDate>Thu, 05 Sep 2024 14:36:23 GMT</pubDate></item><item><title>The Himmler Brothers: A German Family History</title><link>https://simondobson.org/goodreads/the-himmler-brothers-a-german-family-history/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1328831850l/1629056._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Katrin Himmler
	  (2005)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      The family history of Heinrich Himmler and his two brothers Gebhard and Ernst, as told by his great-niece.&lt;br&gt;&lt;br&gt;There's a lot of fascinating backstory in this book, and it explains a lot. It portrays Heinrich Himmler as very much the product of a middle-class, socially ambitious family who pushed him relentlessly to succeed and only seemed really to embrace him after he achiveed visible success as a Reichstag deputy and then later as Reichsführer-SS. The author, Katrin, has access to lots of family papers and photographs that have never been explored before, as well as being able to talk informally to Heinrich's brothers' children about their experiences. This makes this a profoundly personal exploration of Heinrich's rise and fall.&lt;br&gt;&lt;br&gt;That's also its weakness, of course, of which Katrin herself is well aware: it was cleaerly not an easy book to write, and one led her to realise how much families re-write their own histories – understandbaly so in the light of what happened. It also means the the book as a whole concentrates on the domestic side of Heinrich's life, which can be jarring: the period from him being a secretary to leading the SS is covered in less than a page. Overall, though, there's a lot of keen insight provided into the making of a monster.
      &lt;/p&gt;&lt;p&gt;
	4/5.
	  Finished Thursday 22 August, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6782101538?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/the-himmler-brothers-a-german-family-history/</guid><pubDate>Thu, 22 Aug 2024 00:00:00 GMT</pubDate></item><item><title>Prophet Song</title><link>https://simondobson.org/goodreads/prophet-song/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1706935399l/175740709._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Paul    Lynch
	  (2023)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      A timely and troubling consideration of social breakdown.&lt;br&gt;&lt;br&gt;The most notable thing about this novel is that it happens in Ireland: not "far away", but in a European country that is nevertheless seen as collapsing through (it is hinted) a shift to the right taken by fully democrtic means, and a subsequent descent into authoritarianism. That's a perfectly believable scenario for many countries.&lt;br&gt;&lt;br&gt;Lynch writes in a stream-of-consciousness style that manages to be comprehensible while still retaining the slightly bewildered feeling of someone caught-up in event they don't fully understand and can't quite keep up with. There's enough Irish vernacular and geographical detail to make the story hard-hitting for anyone who knows Dublin.&lt;br&gt;&lt;br&gt;Some people desperately cling to processes that no longer have any meaning; there are huge numbers of forms to fill out despite them serving no purpose; there's lots of bureaucracy used to drum people into compliance; and there's lots of venality hiding behind the continuation of these processes to convert them into vehicles for personal gain. Rules tighten as order breaks down, and the same cast of chancers and bandits and people-smugglers emerge in Ireland as in other countries that have gone through this kind of trauma. And that I think is the main message of the book. The themes and characters emerging from social breakdown are universal, and a European country would go the same way as anywhere else.
      &lt;/p&gt;&lt;p&gt;
	5/5.
	  Finished Tuesday 20 August, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6042005187?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/prophet-song/</guid><pubDate>Tue, 20 Aug 2024 00:00:00 GMT</pubDate></item><item><title>Fancy Bear Goes Phishing: The Dark History of the Information Age, in Five Extraordinary Hacks</title><link>https://simondobson.org/goodreads/fancy-bear-goes-phishing-the-dark-history-of-the-information-age-in-five-extraordinary-hacks/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1678753650l/62039276._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Scott J. Shapiro
	  (2023)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      A lawyer's take on hacking. That's both a compliment and a limitation.&lt;br&gt;&lt;br&gt;The book presents itself as being a history of hacking. It kind of is, and covers some famous incidents in varying degrees of detail. It spends a lot of time making the underlying technology understandable to a non-technical reader, which is a major contribution. One could argue that it's mis-named, in that it spends more time on the hacking of Paris Hilton's cellphone and the evolution of the Mirai botnet than on Fancy Bear's attack on the US Democrats., but it does place these attacks into a wider and useful context.&lt;br&gt;&lt;br&gt;But the wider context is als0 a problem. Shapiro is a legal philosopher – and it shows. Firstly he annoyingly introduces terminology to distinguish between computer code ("downcode") and social norms and the law ("upcode"), with "metacode" sitting in between. Is this distinction useful? – I don't think so, since the whole point about "upcode" is that it's &lt;i&gt;not&lt;/i&gt; code but a set of political choices and norms. Secondly, he tries to draw a distinction between criminal use of computers and espionage, arguing that the former is illegal but that the latter is not – and from this tries to argue that US responses to state-directed hacking are hypocritical. Well, yes: is that a point worth making, and does it have any significance beyond the purely philosophical?&lt;br&gt;&lt;br&gt;Thirdly, the book also has a somewhat rosy view of US behaviour which is (in my opinion) contradicted by the facts and by the arguments of other books – for example &lt;a href="https://www.goodreads.com/book/show/49247043.This_Is_How_They_Tell_Me_the_World_Ends_The_Cyberweapons_Arms_Race" title="This Is How They Tell Me the World Ends The Cyberweapons Arms Race by Nicole Perlroth" rel="nofollow noopener"&gt;This Is How They Tell Me the World Ends: The Cyberweapons Arms Race&lt;/a&gt;, which deals with the origins of cyberweapons.&lt;br&gt;&lt;br&gt;There are also some annoying wild claims. Turing's results absolutely &lt;i&gt;don't&lt;/i&gt; say that finding bugs in code is undecidible; this &lt;i&gt;doesn't&lt;/i&gt; stop us from radically improving our technological approaches to malware; we &lt;i&gt;don't&lt;/i&gt; think that problems are decidable because they're all that we see; and a belief in the fundamental comprehensibility of the universe is &lt;i&gt;not&lt;/i&gt; absurd. These weaken the presentation and detract from its undounbted strong points.
      &lt;/p&gt;&lt;p&gt;
	3/5.
	  Finished Monday 19 August, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/5560128183?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/fancy-bear-goes-phishing-the-dark-history-of-the-information-age-in-five-extraordinary-hacks/</guid><pubDate>Mon, 19 Aug 2024 00:00:00 GMT</pubDate></item><item><title>The World According to Colour</title><link>https://simondobson.org/goodreads/the-world-according-to-colour/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1623144261l/56155215._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	James     Fox
	  (2022)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      A book using colour as a way to access a range of other topics, without ever losing focus.&lt;br&gt;&lt;br&gt;Some of the choices will probably be controversial, such as the emergence of "whiteness" as a racial classification, even though supported plentifully by evidence. There are plenty of other less challenging anecdotes, though. Why do we usually consider there that there are &lt;i&gt;seven&lt;/i&gt; colours? – at least in part because of Newton's religious and alchemical ideas that led him to want to tie colour to the notes on the musical scale&lt;br&gt;&lt;br&gt;I most enjoyed the chapter on purple, mainly because it focused on the significant technological change that synthetic aniline dyes brought into culture, changing the relative abundances of various colours and changing the ways in which they were perceived as signifiers of wealth and status.
      &lt;/p&gt;&lt;p&gt;
	4/5.
	  Finished Sunday 11 August, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6565806725?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>bonanza</category><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/the-world-according-to-colour/</guid><pubDate>Sun, 11 Aug 2024 00:00:00 GMT</pubDate></item><item><title>Build: An Unorthodox Guide to Making Things Worth Making</title><link>https://simondobson.org/goodreads/build-an-unorthodox-guide-to-making-things-worth-making/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1652120231l/59696349._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Tony Fadell
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      Twenty-five years ago, more or less, I ran a start-up company. I wish books like this had existed back then to help me understand what start-ups need to do.&lt;br&gt;&lt;br&gt;Fadell has perhaps the best pedigree imaginable, including being involved both in massive successes (the iPod, the iPhone, the Nest thermostat) and crashing failures (General Magic), and the best thing about this book is his willingness to share them, warts and all. He's clearly come to a place in his life where he regards everything as a learning opportunity and a teaching opportunity, rather than needing to project a particular image of himself.&lt;br&gt;&lt;br&gt;The business advice is fascinating, even for someone who doesn't intend to start a company: there's plenty to learn about organisation structures and politics. I suspect it'd be absolute gold for anyone thinking of making hardware devices for the modern software-dominated world, though. Fadell has a clear understanding of what's needed to make a physical product succeed, and his emphases on story-telling and understanding the customer's journey as a route to success are compelling. &lt;br&gt;&lt;br&gt;There's also a lot of insight into some of the major companies and personalities he's met along the way. He's positive about Apple, clear-eyed about Steve Jobs' strengths and weaknesses – and clearly quite shell-shocked by his exposure to Google as not what he was expecting them to be.
      &lt;/p&gt;&lt;p&gt;
	5/5.
	  Finished Saturday 3 August, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6567722144?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/build-an-unorthodox-guide-to-making-things-worth-making/</guid><pubDate>Sat, 03 Aug 2024 00:00:00 GMT</pubDate></item><item><title>SS-GB</title><link>https://simondobson.org/goodreads/ss-gb/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div&gt;
    &lt;div&gt;
      &lt;img src="https://i.gr-assets.com/images/S/compressed.photo.goodreads.com/books/1689536758l/63326204._SX98_.jpg" style="float: left; margin-right: 10px"&gt;
      &lt;h2&gt;
	Len Deighton
	  (1979)
      &lt;/h2&gt;
    &lt;/div&gt;
    &lt;p&gt;
      An alternative history that has aged well. The premise is quite common: what if Nazi Germany had invaded Britain in the Spring of 1941, and succeeded? The plot revolves around rescuing the King and retrieving atomic secrets, both to be sent to America.&lt;br&gt;&lt;br&gt;But it's the politics of a Nazi occupation that clearly most fascinated Deighton, because he build a labyrinth of plots and counter-plots between Army, SS, British Resistance, and American isolationism. These internecine struggles are actually quite familiar from the actual history of Nazi occupations, so it's quite fascinating to see them transplanted to a fictional Britain. It's so well done that it's a shame it isn't part of a series (of which Deighton wrote several).
      &lt;/p&gt;&lt;p&gt;
	4/5.
	  Finished Saturday 3 August, 2024.
	&lt;/p&gt;&lt;p&gt;
	  (Originally published on &lt;a href="https://www.goodreads.com/review/show/6432286432?utm_medium=api&amp;amp;utm_source=rss"&gt;Goodreads&lt;/a&gt;.)
  &lt;/p&gt;&lt;/div&gt;</description><category>books</category><category>reviews</category><guid>https://simondobson.org/goodreads/ss-gb/</guid><pubDate>Sat, 03 Aug 2024 00:00:00 GMT</pubDate></item><item><title>Metacircular Semantics for Common Lisp Special Forms</title><link>https://simondobson.org/2024/08/02/metacircular-semantics-for-common-lisp-special-forms/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org003e69b" class="outline-2"&gt;
&lt;h2 id="org003e69b"&gt;Metacircular Semantics for Common Lisp Special Forms&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org003e69b"&gt;
&lt;p&gt;
Henry G. Baker. &lt;i&gt;&lt;a href="https://doi.org/10.1145/382126.382662"&gt;Metacircular Semantics for Common Lisp Special Forms&lt;/a&gt;&lt;/i&gt;.
ACM SIGPLAN Lisp Pointers &lt;b&gt;V&lt;/b&gt;, pp.11–20. 1992.
&lt;/p&gt;

&lt;p&gt;
A response to the criticisms of McCarthy's semantics for Common
Lisp that it didn't specify the behaviours of special forms, and
of the standardisation process of adopting prose definitions that
are too "lawyerly" for engineering.
&lt;/p&gt;

&lt;p&gt;
The approach is to define the special forms in terms of other
constructions, for example &lt;code&gt;if&lt;/code&gt; in terms of nested lambda
abstractions to prevent execution of the unwanted branch. This is
both useful for understanding and a way of minimising the number
of under-defined special forms.
&lt;/p&gt;

&lt;p&gt;
It suggests treating &lt;code&gt;catch&lt;/code&gt; / &lt;code&gt;throw&lt;/code&gt; as basic, both because other
control-transfer forms can be expressed sing them and because it
emphasises the interactions that preclude Common Lisp having
continuations like Scheme's. However there's also an argument
pursued that some other structures (like &lt;code&gt;values&lt;/code&gt;) provide extra
information that can be useful for compilers looking to optimise.
It's a deep exploration of the underpinnings of the language from
both theoretical and practical perspectives.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><category>semantics</category><guid>https://simondobson.org/2024/08/02/metacircular-semantics-for-common-lisp-special-forms/</guid><pubDate>Fri, 02 Aug 2024 10:29:45 GMT</pubDate></item><item><title>Casting SPELs in Lisp</title><link>https://simondobson.org/2024/08/02/casting-spels-in-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org8bdeee5" class="outline-2"&gt;
&lt;h2 id="org8bdeee5"&gt;Casting SPELs in Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8bdeee5"&gt;
&lt;p&gt;
&lt;a href="https://www.lisperati.com/casting.html"&gt;https://www.lisperati.com/casting.html&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A tongue-in-cheek – but still excellent – comicbook-style
introduction to Lisp programming. (There's also a version
&lt;a href="https://www.lisperati.com/casting-spels-emacs/html/casting-spels-emacs-1.html"&gt;specifically for Emacs Lisp&lt;/a&gt;.) It's structured around building an
adventure-style game, which as well as being a classic also offers
lots of opportunities for exploring different data structures and
algorithms: one can easily imagine expanding it to include (for
example) an AI second player or autonomous non-player characters
and gradually building a really complicated application from a
standing start.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/08/02/casting-spels-in-lisp/</guid><pubDate>Fri, 02 Aug 2024 10:25:53 GMT</pubDate></item><item><title>My mental model of setf was wrong</title><link>https://simondobson.org/2024/07/27/my-mental-model-of-setf-was-wrong/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org304e782" class="outline-2"&gt;
&lt;h2 id="org304e782"&gt;My mental model of setf was wrong&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org304e782"&gt;
&lt;p&gt;
I realised recently that I've been thinking about &lt;code&gt;setf&lt;/code&gt; all wrong.
&lt;/p&gt;

&lt;p&gt;
Lisp lets programs define new &lt;code&gt;setf&lt;/code&gt; forms for assignment. The most
common example is from CLOS, where a class like this:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defclass&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ss"&gt;:accessor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a-var&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
will give rise to a class and two functions, &lt;code&gt;a-var&lt;/code&gt; to read the
value of the &lt;code&gt;var&lt;/code&gt; slot on an instance of &lt;code&gt;A&lt;/code&gt;, and a &lt;code&gt;setf&lt;/code&gt; target used
as &lt;code&gt;(setf (a-var instance) 24)&lt;/code&gt; to set the &lt;code&gt;var&lt;/code&gt; slot of &lt;code&gt;instance&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
It's natural to read that like as executing &lt;code&gt;(a-var instance)&lt;/code&gt; to
retrieve a location, and &lt;code&gt;setf&lt;/code&gt; using this location to assign to.
The documentation reinforces this view, talking about
"generalised places" as the targets for &lt;code&gt;setf&lt;/code&gt; to store things. My
mental model was strengthened by idioms like &lt;code&gt;(setf (car pair) 23)&lt;/code&gt;
to set the car of a pair or list, and &lt;code&gt;(setf (cdr pair) '(1 2 3)&lt;/code&gt;
to set the cdr. The first argument is a &lt;i&gt;locator&lt;/i&gt; expression
returning the place to update, and the second argument is the &lt;i&gt;new
value&lt;/i&gt; to put there.
&lt;/p&gt;

&lt;p&gt;
Natural. But wrong.
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
The thing I missed is that &lt;code&gt;setf&lt;/code&gt; is a &lt;i&gt;macro&lt;/i&gt;: it can access the
&lt;i&gt;structure&lt;/i&gt; of its arguments but not their &lt;i&gt;values&lt;/i&gt;. You can't write
code like this:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;h&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;h&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
and expect the &lt;code&gt;car&lt;/code&gt; of &lt;code&gt;l&lt;/code&gt; to be updated, which would make sense if
&lt;code&gt;setf&lt;/code&gt; were working on a location, because &lt;code&gt;h&lt;/code&gt; would be that
location. But it isn't.
&lt;/p&gt;

&lt;p&gt;
What actually happens is that the &lt;code&gt;setf&lt;/code&gt; macro looks, at compile
time, at the structure of its first (locator) argument, and uses
that to dispatch to a method. Using the slot accessor above, the
&lt;code&gt;setf&lt;/code&gt; form expands to something like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a-var&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;slot-value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'a-var&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This is a method with two pieces of selection: specialised on the
type of an argument (&lt;code&gt;A&lt;/code&gt;), and named with the &lt;i&gt;selector&lt;/i&gt; used to
within the locator (&lt;code&gt;a-var&lt;/code&gt;). It's definition expands to &lt;i&gt;another&lt;/i&gt;
&lt;code&gt;setf&lt;/code&gt;, this time specialised against &lt;code&gt;slot-value&lt;/code&gt; and an instance of
&lt;code&gt;standard-object&lt;/code&gt;. Specialising on the selector explains why we
need that selector to be present syntactically at compile time.
&lt;/p&gt;

&lt;p&gt;
My mistake was thinking that the similarity between access form
and &lt;code&gt;setf&lt;/code&gt; form was necessary and functional – and it isn't
either. This has some interesting consequences.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org598a20d" class="outline-3"&gt;
&lt;h3 id="org598a20d"&gt;The selector is entirely arbitrary&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org598a20d"&gt;
&lt;p&gt;
If we don't like using &lt;code&gt;car&lt;/code&gt; to indicate the head of a list – and
some people don't – we could in principle define a new
specialisation such as:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rplaca&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
and use it as &lt;code&gt;(setf (head l) 45)&lt;/code&gt; &lt;i&gt;even though &lt;code&gt;head&lt;/code&gt; isn't a
defined function&lt;/i&gt;. All we need is a selector symbol.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd341b0f" class="outline-3"&gt;
&lt;h3 id="orgd341b0f"&gt;There can be more arguments&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd341b0f"&gt;
&lt;p&gt;
Ever since I first encountered them I wondered why the lambda
lists for new &lt;code&gt;setf&lt;/code&gt; specialisations was so strange: the new value
and &lt;i&gt;then&lt;/i&gt; the arguments – but not the selector – of the place to
be updated? Once you get a better mental model, the reason
becomes obvious: there can be &lt;i&gt;multiple&lt;/i&gt; arguments to the &lt;code&gt;setf&lt;/code&gt;
locator, possibly actually a variable number, alongside the
selector, so we need to be able to find the new value reliably.
The easiest way is to put it at the front of the lambda list.
&lt;/p&gt;

&lt;p&gt;
There's actually a common example of this sitting in plain sight
that I'd missed. You access the elements of a Lisp array using
the &lt;code&gt;aref&lt;/code&gt; function, which takes the array and the index, such as
(&lt;code&gt;aref a 23)&lt;/code&gt;. The corresponding &lt;code&gt;setf&lt;/code&gt; form looks like &lt;code&gt;(setf (aref
     a 23) 0)&lt;/code&gt;, with the locator taking several arguments like the
function. &lt;i&gt;But it isn't calling the function&lt;/i&gt;: it's decomposing a
pattern that &lt;i&gt;looks exactly like&lt;/i&gt; the function call for
convenience, and which passes several arguments to the
specialised method that will look something like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;aref&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The new value is reliably in the first argument position, with
the rest of the locator arguments after it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd7988ba" class="outline-3"&gt;
&lt;h3 id="orgd7988ba"&gt;You can specialise by value too&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd7988ba"&gt;
&lt;p&gt;
Since the &lt;code&gt;setf&lt;/code&gt; forms are just methods, you could if you wanted to
specialise them on the type of the new value as well as on the
locator. As a trivial example:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;assign-head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"Assigned an integer ~s"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;assign-head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"Assigned a string ~s"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;assign-head&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"zero"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Assigned a string "zero"
&lt;/pre&gt;


&lt;p&gt;
Obviously there are better ways to do this, but it's a good
example of the flexibility that comes from &lt;code&gt;setf&lt;/code&gt; not really being
all that special a form at all: just a creative use of the power
of generic functions.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb382c77" class="outline-3"&gt;
&lt;h3 id="orgb382c77"&gt;Can we build our own &lt;code&gt;setf&lt;/code&gt;-like macros?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb382c77"&gt;
&lt;p&gt;
Yes: &lt;code&gt;setf&lt;/code&gt; is entirely constructable within "ordinary" Lisp.
&lt;/p&gt;

&lt;p&gt;
There are two parts to the construction. Firstly, we need the
name of the method that underlies a particular selector.
&lt;/p&gt;

&lt;p&gt;
We can build our own functions with names like this, although not
using &lt;code&gt;defun&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defvar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;*weird-name*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"(1 2 3)"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;*weird-name*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"We did *weird-name* on ~s"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;*weird-name*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"a string"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;

"We did *weird-name* on \"a string\""
&lt;/pre&gt;


&lt;p&gt;
For &lt;code&gt;setf&lt;/code&gt;, the style of name used for the methods implementing the
different choices is &lt;code&gt;(setf selector)&lt;/code&gt; – a function named by a
list – where &lt;i&gt;selector&lt;/i&gt; is the symbol at the head of locator list.
(Some Lisps construct a symbol from the list elements, rather
than using it directly. I'm not sure what, if anything, the
Common Lisp language definition says about how this should work.)
&lt;/p&gt;

&lt;p&gt;
For the second part of the construction, &lt;code&gt;setf&lt;/code&gt; takes the locator,
synthesises the function name symbol using the selector, and
calls a generic function with this name, passing the new value
and the rest of the locator as arguments.
&lt;/p&gt;

&lt;p&gt;
So to define a new construct &lt;code&gt;our-setf&lt;/code&gt; we might do something like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmacro&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;our-setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;locator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;new-value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;selector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;locator&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;our-setf-function-name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"(our-setf ~a)"&lt;/span&gt;
&lt;span class="w"&gt;                                                           &lt;/span&gt;&lt;span class="nv"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;our-setf-function-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;new-value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;locator&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When called as something like &lt;code&gt;(our-setf (head '(1 2 3)) 0)&lt;/code&gt; the
macro will code to call a method &lt;code&gt;(our-setf head)&lt;/code&gt; (as a symbol),
passing it (&lt;code&gt;0 '(1 2 3))&lt;/code&gt; as arguments and allowing the machinery of
generic functions to determine which method is actually called.
We define these methods of the form &lt;code&gt;(our-setf head)&lt;/code&gt; and specialise
them as required.
&lt;/p&gt;

&lt;p&gt;
(It's actually a bit more complicated than this because we need
to define a generic function for &lt;code&gt;(our-setf head)&lt;/code&gt;. We have to go
backstage and programmatically define the generic function. But
the idea remains the same.)
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
After all this, my mental model of &lt;code&gt;setf&lt;/code&gt; is a lot clearer – and,
I hope, closer the reality at least. It combines a highly
structured use of macros, synthesised function names, and generic
functions – and no special machinery at all.
&lt;/p&gt;

&lt;p&gt;
However, there's some subtlety at play too, not obvious at first
acquaintance. We don't want our synthesised function names to
accidentally capture the names of user-supplied code. It's
possible that using a naming style like &lt;code&gt;setf-car&lt;/code&gt; would do just
this, and a program happens to define a function with this name.
But the names &lt;code&gt;setf&lt;/code&gt; synthesises are &lt;i&gt;lists&lt;/i&gt;, unlikely to be captured
accidentally, which lets us define the specialised methods "as
normal" even though some of the other parts of the process have
to happen backstage.
&lt;/p&gt;

&lt;p&gt;
This shows the power of macros and generic functions. It also
shows how deeply the latter are embedded into Lisp. They're
usually thought of as part of CLOS, but they actually have little
explicit relationship to class and objects at all, and have been
woven all through Lisp to build flexible code structures.
&lt;/p&gt;

&lt;p&gt;
UPDATED 2023-07-30: I incorrectly said originally that one
couldn't use forms like &lt;code&gt;(defun (setf abc) ...)&lt;/code&gt;: you can, just as
with &lt;code&gt;defmethod&lt;/code&gt; and &lt;code&gt;defgeneric&lt;/code&gt;, and name a function using a list.
Thanks to Hacker News contributor &lt;a href="https://phoe.github.io"&gt;phoe-krk&lt;/a&gt; for correcting me. I
was also slightly loose in my use of &lt;i&gt;specialisation&lt;/i&gt;, which I've
tightened up.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>macroprogramming</category><category>programming</category><guid>https://simondobson.org/2024/07/27/my-mental-model-of-setf-was-wrong/</guid><pubDate>Sat, 27 Jul 2024 13:29:18 GMT</pubDate></item></channel></rss>