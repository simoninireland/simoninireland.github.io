<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson (Posts about programming)</title><link>https://simondobson.org/</link><description></description><atom:link href="https://simondobson.org/categories/programming.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Tue, 01 Oct 2024 07:54:22 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The different energy footprints of different programming languages</title><link>https://simondobson.org/2024/09/27/the-different-energy-footprints-of-different-programming-languages/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org37bf54e" class="outline-2"&gt;
&lt;h2 id="org37bf54e"&gt;The different energy footprints of different programming languages&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org37bf54e"&gt;
&lt;p&gt;
I've recently been thinking about low-power computing, from AI and
data centres down to sensors, as part of a new initiative the
University is considering. It's easy to forget the resource
footprint of our computing systems – especially those that are "out
of sight, out of mind" in the cloud – but there's growing evidence
that their growth threatens the renewable energy transition. Some of
the figures for AI electricity and water usage are astonishing.
&lt;/p&gt;

&lt;p&gt;
One aspect of this is the effect of choice of programming language.
I can across some work from 2017 on this:
&lt;/p&gt;

&lt;p&gt;
Rui Pereira, Marco Couto, Francisco Ribeiro, Rui Rua, Cunha Jácome,
João Paulo Fernandes, and João Saraiva. &lt;i&gt;&lt;a href="https://doi.org/10.1145/3136014.3136031"&gt;Energy Efficiency across
Programming Languages: How Do Energy, Time, and Memory Relate?&lt;/a&gt;&lt;/i&gt; In
&lt;i&gt;Proceedings of the 10th ACM SIGPLAN International Conference on
Software Language Engineering&lt;/i&gt;. 2017.
&lt;/p&gt;

&lt;p&gt;
The authors compare 13 benchmarks run in 27 different languages,
with the benchmarks being chosen widely to avoid being biased by
numeric performance. I was expecting some patterns: compiled
languages doing better on performance, memory, and energy usage, for
example. But I wasn't expecting exactly &lt;i&gt;how&lt;/i&gt; widely the figures
diverged, or some of the details.
&lt;/p&gt;

&lt;p&gt;
The following table is from the paper, annotated by me. The figures
are normalised against the best result in each category (so the top
language has value 1, and so on).
&lt;/p&gt;

&lt;p width="80%" align="center"&gt;
&lt;img src="https://simondobson.org/attachments/fb/debea0-0913-41c2-90bc-726153de8d28/pl-energy.png" alt="pl-energy.png"&gt;
&lt;/p&gt;

&lt;p&gt;
The two most-used languages for web application, Python and
JavaScript, perform uniformly pretty badly: 75 times C's energy
usage, in Python's case. But although JavaScript does substantially
better on energy (only a factor of 4), TypeScript – which is
usually thought of as JavaScript with type pre-processing –
requires 21 times C's energy, or 5 times JavaScript's. Why is that?
– I can't think of a reason.
&lt;/p&gt;

&lt;p&gt;
But the real surprise was that "research" languages like Haskell and
Lisp both hold up well: twice C's energy, in Lisp's case. I don't
think that would surprise modern Lisp programmers, who are used to
their compilers' efficiencies – but it would surprise someone used
only to the "hearsay" about Lisp. The same for Haskell, actually,
whose modern compilers really leverage the extra structure. When you
consider that both those languages are pretty much dependent on
garbage collection and so are doing substantially &lt;i&gt;more&lt;/i&gt; work than the
equivalent C program, it's impressive.
&lt;/p&gt;

&lt;p&gt;
(Also look in the table for Racket, consistently lower than Lisp
despite their close similarities. I suspect this is a compiler
optimisation issue more than anything else.)
&lt;/p&gt;

&lt;p&gt;
This work clearly isn't complete or definitive. Clojure is entirely
missing, as is Scala, and there will have been compiler improvements
since 2017 for the languages with the most active developer
communities. But it's still quite sobering that the differences are
&lt;i&gt;so&lt;/i&gt; wide, and that we've chosen to push languages that exacerbate
energy usage rather than managing it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>haskell</category><category>javascript</category><category>lisp</category><category>low power</category><category>programming</category><category>python</category><guid>https://simondobson.org/2024/09/27/the-different-energy-footprints-of-different-programming-languages/</guid><pubDate>Fri, 27 Sep 2024 15:15:23 GMT</pubDate></item><item><title>Guard methods on CLOS generic functions</title><link>https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgdad2bf2" class="outline-2"&gt;
&lt;h2 id="orgdad2bf2"&gt;Guard methods on CLOS generic functions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdad2bf2"&gt;
&lt;p&gt;
There are times when one wants to be able to guard a method's
execution. A typical case is for callbacks, where we only want the
callback to run under certain circumstances – but it's easier to
write the callbacks themselves as though they'll &lt;i&gt;always&lt;/i&gt; be called.
&lt;/p&gt;

&lt;p&gt;
Object-oriented programs typically use a pattern for this: they
split the function into two methods, one for the guard and one for
the action being guarded. A sub-class can then override the guard
independently of the action, and some sub-classes may override
both guard and action.
&lt;/p&gt;

&lt;p&gt;
This splitting seems a little awkward, though, and there are times
when I'd prefer to have everything (guard and action) defined as
part of the one method. Fortunately there's a Lisp-ier solution
involving defining a new method combination to get exactly this
behaviour.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc6422b3" class="outline-3"&gt;
&lt;h3 id="orgc6422b3"&gt;Standard method combination&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc6422b3"&gt;
&lt;p&gt;
CLOS, unlike most languages, allows a programmer to control how
methods are combined in terms of overriding. The "standard"
combination allows for &lt;code&gt;:before&lt;/code&gt;, &lt;code&gt;:after&lt;/code&gt;, and &lt;code&gt;:around&lt;/code&gt; methods as
well as undecorated "primary" methods.
&lt;/p&gt;

&lt;p&gt;
When a generic function is called, the list of applicable primary
methods is determined based on the types of arguments. most
specific method first&lt;sup&gt;&lt;a id="fnr.most-specific-first" class="footref" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fn.most-specific-first" role="doc-backlink"&gt;1&lt;/a&gt;&lt;/sup&gt;.
&lt;/p&gt;

&lt;p&gt;
The same process is performed for all applicable &lt;code&gt;:before&lt;/code&gt; methods,
and then again for applicable &lt;code&gt;:after&lt;/code&gt; methods, and then &lt;i&gt;again&lt;/i&gt; for
&lt;code&gt;:around&lt;/code&gt; methods. The &lt;code&gt;:after&lt;/code&gt; and &lt;code&gt;:around&lt;/code&gt; are always ordered most
specific first, while the &lt;code&gt;:before&lt;/code&gt; methods are always ordered
least-specific first.
&lt;/p&gt;

&lt;p&gt;
Once these lists have been constructed, the "effective" method
that results is called. If there are &lt;code&gt;:around&lt;/code&gt; methods, they are
called in order. An &lt;code&gt;:around&lt;/code&gt; method may, as part of its body, call
&lt;code&gt;call-next-method&lt;/code&gt; to invoke the next-most-specific &lt;code&gt;:around&lt;/code&gt; method
– or may not.
&lt;/p&gt;

&lt;p&gt;
If a call to &lt;code&gt;call-next-method&lt;/code&gt; has no more &lt;code&gt;:around&lt;/code&gt; methods to call
– or of there were no &lt;code&gt;:around&lt;/code&gt; methods defined – all the &lt;code&gt;:before&lt;/code&gt;
methods are run and their return values discarded. Then the
primary methods are run in the same manner as &lt;code&gt;:around&lt;/code&gt; methods,
with any calls to &lt;code&gt;call-next-method&lt;/code&gt; calling the next primary
method. After the primary methods have returned, all the &lt;code&gt;:after&lt;/code&gt;
methods are run and their return values discarded. The result of
the method call is the result returned from the primary methods.
The process is roughly like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;prog1&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In this code, &lt;code&gt;call-method&lt;/code&gt; calls its first method argument, and
any call to &lt;code&gt;call-next-method&lt;/code&gt; calls the next method in the list.
&lt;code&gt;call-methods&lt;/code&gt; calls all the methods in a list of methods,
discarding their return values.
&lt;/p&gt;

&lt;p&gt;
Contrast that with Java or Python, where methods on more-specific
classes override those on less-specific, and have the option to
call up to the superclass method. Essentially this makes all
methods similar to &lt;code&gt;:around&lt;/code&gt;, and there's no real equivalent of
&lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga578c83" class="outline-3"&gt;
&lt;h3 id="orga578c83"&gt;Other method combinations&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga578c83"&gt;
&lt;p&gt;
The above is referred to as &lt;i&gt;standard method combination&lt;/i&gt;, implying
the existence of &lt;i&gt;non-standard&lt;/i&gt; combination. CLOS lets the
programmer define new combinations, and indeed defines a few
itself. For our purposes the most important alternative method
combination is &lt;code&gt;and&lt;/code&gt;, which runs all primary methods within an &lt;code&gt;and&lt;/code&gt;
form treating all methods as predicates. There are only primary
methods allowed.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org85cc730" class="outline-3"&gt;
&lt;h3 id="org85cc730"&gt;Guards as method combination&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org85cc730"&gt;
&lt;p&gt;
For our use case, we want to be able to return values from primary
methods, and allow &lt;code&gt;:around&lt;/code&gt;, &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt; methods. However, we
&lt;i&gt;also&lt;/i&gt; want to have some methods act as predicates that guard the
execution of the effective method thus formed. We want to be able
to add guard methods that are always run first, regardless of their
specificity, and then run the effective method only if &lt;i&gt;all&lt;/i&gt; the guards
are satisfied. The net result is that all parts of the generic
function are provided as methods on it, but some can now be boolean
guards that act as gatekeepers on the rest of the methods.
Naturally we want the guards to be selected for specificity
alongside the other methods, letting the CLOS machinery pick &lt;i&gt;all&lt;/i&gt;
the functionality that's appropriate to a particular method call.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2b8a7b0" class="outline-3"&gt;
&lt;h3 id="org2b8a7b0"&gt;Why this isn't just &lt;code&gt;:around&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2b8a7b0"&gt;
&lt;p&gt;
It might sound like we can get this behaviour using &lt;code&gt;:around&lt;/code&gt;
methods that perform guarding. But we can't – quite.
&lt;/p&gt;

&lt;p&gt;
Suppose we define a primary method:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
We can write a guard quite happily as an &lt;code&gt;:around&lt;/code&gt; method:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-next-method&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This method will only allow the method to proceed when the
condition holds, otherwise it returns &lt;code&gt;nil&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
(52 NIL)
&lt;/p&gt;

&lt;p&gt;
So far so good.
&lt;/p&gt;

&lt;p&gt;
However, the problem is that CLOS orders the &lt;code&gt;:around&lt;/code&gt; methods
most specific first. Suppose we have another &lt;code&gt;:around&lt;/code&gt; method
specialised against a more specific type:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-next-method&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When this method is called with an integer this method gets run
before the previous guard:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
6
&lt;/p&gt;

&lt;p&gt;
and we get a non-nil result, despite the guard method indicating
that we shouldn't. If we provide an argument that doesn't trigger
the first &lt;code&gt;:around&lt;/code&gt; method, then we can get caught by the guard:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
NIL
&lt;/p&gt;

&lt;p&gt;
This is of course perfectly sensible behaviour in many cases.
However, it does mean that the "guards" we're supplying are
executed as &lt;i&gt;part&lt;/i&gt; of the effective method rather than &lt;i&gt;before&lt;/i&gt; it,
and therefore can't guarantee that the method is properly guarded
by &lt;i&gt;all&lt;/i&gt; the guards, regardless of their specialisation. Another
way of looking at this is that a later, more specialised, "guard"
can override one set by an earlier, less specialised, method,
which again may not be what's desired.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org88504e4" class="outline-3"&gt;
&lt;h3 id="org88504e4"&gt;A &lt;code&gt;guarded&lt;/code&gt; method combination&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org88504e4"&gt;
&lt;p&gt;
Fortunately we can get the behaviour we want by defining a new
method combination, &lt;code&gt;guarded&lt;/code&gt;. A &lt;code&gt;guarded&lt;/code&gt; generic function accepts
five method qualifiers:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;undecorated primary methods;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt; methods that run before and after the
primary methods;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:around&lt;/code&gt; methods that run around the &lt;code&gt;:before&lt;/code&gt;-primary-&lt;code&gt;:after&lt;/code&gt;
combination; and&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:if&lt;/code&gt; methods that act as guards, running before any &lt;code&gt;:around&lt;/code&gt;
methods to determine whether &lt;i&gt;any&lt;/i&gt; of the "functional" methods
are run or not&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
We first need a helper function&lt;sup&gt;&lt;a id="fnr.call-methods" class="footref" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fn.call-methods" role="doc-backlink"&gt;2&lt;/a&gt;&lt;/sup&gt; to construct the
code to run the chain of &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt; methods while
discarding their return values.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;methods&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;"Return `call-method' forms for all METHODS."&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;mapcar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="nv"&gt;methods&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
We can then use the macro &lt;code&gt;define-method-combination&lt;/code&gt; to define our
new method combination.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;define-method-combination&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&amp;amp;optional&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:most-specific-first&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;ifs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:if&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:before&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;order&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:required&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:after&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;before-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;after-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;primary-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;core-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;befores&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;afters&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;prog1&lt;/span&gt;
&lt;span class="w"&gt;                                  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
&lt;span class="w"&gt;                                    &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="nv"&gt;before-form&lt;/span&gt;
&lt;span class="w"&gt;                                    &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;primary-form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                                &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="nv"&gt;after-form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;primaries&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;around-form&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;
&lt;span class="w"&gt;                               &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                                             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;arounds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                                              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-method&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;core-form&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;                               &lt;/span&gt;&lt;span class="nv"&gt;core-form&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ifs&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;call-methods&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;ifs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;around-form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="nv"&gt;around-form&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The macro is described in detail in the &lt;a href="https://novaspec.org/cl/f_define-method-combination"&gt;hyperspec&lt;/a&gt;, but its
behaviour is quite simple. The list of forms (&lt;code&gt;arounds&lt;/code&gt; and so on)
define variables that extract the methods that have the given
decorations – so &lt;code&gt;arounds&lt;/code&gt; gets a list of &lt;code&gt;:around&lt;/code&gt; methods,
&lt;code&gt;primaries&lt;/code&gt; gets the undecorated (primary) methods, and so on. In
particular, &lt;code&gt;ifs&lt;/code&gt; gets any methods decorated with &lt;code&gt;:if&lt;/code&gt;: these are
the guards.
&lt;/p&gt;

&lt;p&gt;
The body of the macro constructs the code needed to build the
methods' behaviours. The &lt;code&gt;let*&lt;/code&gt; defines the code for the different
parts. &lt;code&gt;core-form&lt;/code&gt; is slightly optimised in the case when there is
only one primary method; otherwise it runs the &lt;code&gt;:before&lt;/code&gt; methods
and then the primary method, captures the result of the latter,
then runs the &lt;code&gt;:after&lt;/code&gt; methods, and then returns its result. (This
is the first time I've ever used &lt;code&gt;prog1&lt;/code&gt; for real: now I know why
it exists.) If there are &lt;code&gt;:around&lt;/code&gt; methods, &lt;code&gt;around-form&lt;/code&gt; wraps up a
list consisting of the &lt;code&gt;:around&lt;/code&gt; methods and a method constructed
from &lt;code&gt;core-form&lt;/code&gt;, letting it be run as the result of the final
&lt;code&gt;call-next-method&lt;/code&gt; call.
&lt;/p&gt;

&lt;p&gt;
The body of the &lt;code&gt;let*&lt;/code&gt; wraps-up &lt;code&gt;around-form&lt;/code&gt; within an &lt;code&gt;if&lt;/code&gt; whose
condition is the conjunction of all the &lt;code&gt;:if&lt;/code&gt; methods. Only if all
these methods return true (well, not &lt;code&gt;nil&lt;/code&gt; in the usual Lisp style)
will the code of &lt;code&gt;around-form&lt;/code&gt; be executed. Again the code is
optimised for the case where there are no guards, in which case
we just get &lt;code&gt;around-form&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
Notice that &lt;code&gt;define-method-combination&lt;/code&gt; returns &lt;i&gt;code&lt;/i&gt;, like all
macros: it doesn't execute the methods itself. This is a hint as
to what happens off-stage: CLOS uses the method combination at
compile time to construct effective methods which can then be
cached to minimise the performance hit from all the flexibility
provided by method combination.
&lt;/p&gt;

&lt;p&gt;
Now we can re-do our example from above:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;;; a generic function defined to use our new method combination&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defgeneric&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:method-combination&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;;; the functionality, split into two methods&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:around&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;call-next-method&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;;; this guard used to be :around and is now :if&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;guarded-example&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
(52 NIL NIL)
&lt;/p&gt;

&lt;p&gt;
The guard now stops execution of the effective method if its
condition isn't met – and if it &lt;i&gt;is&lt;/i&gt; met, passes control through
to the complete method stack. This happens regardless of where
the guard is specialised in terms of the class hierarchy: the
guards run before any "functional" code. (That &lt;code&gt;:before&lt;/code&gt; and &lt;code&gt;:after&lt;/code&gt;
methods work too, and multiple guards, and that the combination
works when applied to class hierarchies, are left as exercises to
the reader.)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org53c5ffd" class="outline-3"&gt;
&lt;h3 id="org53c5ffd"&gt;Critique&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org53c5ffd"&gt;
&lt;p&gt;
You may object to this solution on the grounds that it introduces
a weird asymmetry into methods: some as functional and some as
guards, with different return types. Maybe you prefer to keep
guards in separate methods using the usual object-oriented
pattern. That's entirely reasonable. But I think there are
sufficient cases where this kind of guarding makes sense to have
it as a pattern, especially as it has no effect unless explicitly
selected for a generic function.
&lt;/p&gt;

&lt;p&gt;
I have to say I'm amazed how &lt;i&gt;little&lt;/i&gt; code is needed: around 30
lines, including the helper function. It shows off the power of
CLOS, and how it's possible to change even the basic underlying
structures of the object system with relative ease. But it also
shows how Lisp opens-up the space of programming styles, things
that benefit from being policies that can be changed, rather than
hard-coding one particular choice.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;h2 class="footnotes"&gt;Footnotes: &lt;/h2&gt;
&lt;div id="text-footnotes"&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.most-specific-first" class="footnum" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fnr.most-specific-first" role="doc-backlink"&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara" role="doc-footnote"&gt;&lt;p class="footpara"&gt;
This is also programmable when required, for
example to run methods least-specific-first.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="footdef"&gt;&lt;sup&gt;&lt;a id="fn.call-methods" class="footnum" href="https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/#fnr.call-methods" role="doc-backlink"&gt;2&lt;/a&gt;&lt;/sup&gt; &lt;div class="footpara" role="doc-footnote"&gt;&lt;p class="footpara"&gt;
I got the idea for this function from
&lt;a href="https://github.com/sellout/method-combination-utilities"&gt;method-combination-utilities&lt;/a&gt;, and included it literally to avoid
creating another dependency.
&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>programming</category><guid>https://simondobson.org/2024/09/05/guard-methods-on-clos-generic-functions/</guid><pubDate>Thu, 05 Sep 2024 14:36:23 GMT</pubDate></item><item><title>My mental model of setf was wrong</title><link>https://simondobson.org/2024/07/27/my-mental-model-of-setf-was-wrong/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org304e782" class="outline-2"&gt;
&lt;h2 id="org304e782"&gt;My mental model of setf was wrong&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org304e782"&gt;
&lt;p&gt;
I realised recently that I've been thinking about &lt;code&gt;setf&lt;/code&gt; all wrong.
&lt;/p&gt;

&lt;p&gt;
Lisp lets programs define new &lt;code&gt;setf&lt;/code&gt; forms for assignment. The most
common example is from CLOS, where a class like this:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defclass&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ss"&gt;:accessor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a-var&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
will give rise to a class and two functions, &lt;code&gt;a-var&lt;/code&gt; to read the
value of the &lt;code&gt;var&lt;/code&gt; slot on an instance of &lt;code&gt;A&lt;/code&gt;, and a &lt;code&gt;setf&lt;/code&gt; target used
as &lt;code&gt;(setf (a-var instance) 24)&lt;/code&gt; to set the &lt;code&gt;var&lt;/code&gt; slot of &lt;code&gt;instance&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
It's natural to read that like as executing &lt;code&gt;(a-var instance)&lt;/code&gt; to
retrieve a location, and &lt;code&gt;setf&lt;/code&gt; using this location to assign to.
The documentation reinforces this view, talking about
"generalised places" as the targets for &lt;code&gt;setf&lt;/code&gt; to store things. My
mental model was strengthened by idioms like &lt;code&gt;(setf (car pair) 23)&lt;/code&gt;
to set the car of a pair or list, and &lt;code&gt;(setf (cdr pair) '(1 2 3)&lt;/code&gt;
to set the cdr. The first argument is a &lt;i&gt;locator&lt;/i&gt; expression
returning the place to update, and the second argument is the &lt;i&gt;new
value&lt;/i&gt; to put there.
&lt;/p&gt;

&lt;p&gt;
Natural. But wrong.
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
The thing I missed is that &lt;code&gt;setf&lt;/code&gt; is a &lt;i&gt;macro&lt;/i&gt;: it can access the
&lt;i&gt;structure&lt;/i&gt; of its arguments but not their &lt;i&gt;values&lt;/i&gt;. You can't write
code like this:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;h&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;h&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
and expect the &lt;code&gt;car&lt;/code&gt; of &lt;code&gt;l&lt;/code&gt; to be updated, which would make sense if
&lt;code&gt;setf&lt;/code&gt; were working on a location, because &lt;code&gt;h&lt;/code&gt; would be that
location. But it isn't.
&lt;/p&gt;

&lt;p&gt;
What actually happens is that the &lt;code&gt;setf&lt;/code&gt; macro looks, at compile
time, at the structure of its first (locator) argument, and uses
that to dispatch to a method. Using the slot accessor above, the
&lt;code&gt;setf&lt;/code&gt; form expands to something like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a-var&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;slot-value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'a-var&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This is a method with two pieces of selection: specialised on the
type of an argument (&lt;code&gt;A&lt;/code&gt;), and named with the &lt;i&gt;selector&lt;/i&gt; used to
within the locator (&lt;code&gt;a-var&lt;/code&gt;). It's definition expands to &lt;i&gt;another&lt;/i&gt;
&lt;code&gt;setf&lt;/code&gt;, this time specialised against &lt;code&gt;slot-value&lt;/code&gt; and an instance of
&lt;code&gt;standard-object&lt;/code&gt;. Specialising on the selector explains why we
need that selector to be present syntactically at compile time.
&lt;/p&gt;

&lt;p&gt;
My mistake was thinking that the similarity between access form
and &lt;code&gt;setf&lt;/code&gt; form was necessary and functional – and it isn't
either. This has some interesting consequences.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org598a20d" class="outline-3"&gt;
&lt;h3 id="org598a20d"&gt;The selector is entirely arbitrary&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org598a20d"&gt;
&lt;p&gt;
If we don't like using &lt;code&gt;car&lt;/code&gt; to indicate the head of a list – and
some people don't – we could in principle define a new
specialisation such as:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;rplaca&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
and use it as &lt;code&gt;(setf (head l) 45)&lt;/code&gt; &lt;i&gt;even though &lt;code&gt;head&lt;/code&gt; isn't a
defined function&lt;/i&gt;. All we need is a selector symbol.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd341b0f" class="outline-3"&gt;
&lt;h3 id="orgd341b0f"&gt;There can be more arguments&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd341b0f"&gt;
&lt;p&gt;
Ever since I first encountered them I wondered why the lambda
lists for new &lt;code&gt;setf&lt;/code&gt; specialisations was so strange: the new value
and &lt;i&gt;then&lt;/i&gt; the arguments – but not the selector – of the place to
be updated? Once you get a better mental model, the reason
becomes obvious: there can be &lt;i&gt;multiple&lt;/i&gt; arguments to the &lt;code&gt;setf&lt;/code&gt;
locator, possibly actually a variable number, alongside the
selector, so we need to be able to find the new value reliably.
The easiest way is to put it at the front of the lambda list.
&lt;/p&gt;

&lt;p&gt;
There's actually a common example of this sitting in plain sight
that I'd missed. You access the elements of a Lisp array using
the &lt;code&gt;aref&lt;/code&gt; function, which takes the array and the index, such as
(&lt;code&gt;aref a 23)&lt;/code&gt;. The corresponding &lt;code&gt;setf&lt;/code&gt; form looks like &lt;code&gt;(setf (aref
     a 23) 0)&lt;/code&gt;, with the locator taking several arguments like the
function. &lt;i&gt;But it isn't calling the function&lt;/i&gt;: it's decomposing a
pattern that &lt;i&gt;looks exactly like&lt;/i&gt; the function call for
convenience, and which passes several arguments to the
specialised method that will look something like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;aref&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The new value is reliably in the first argument position, with
the rest of the locator arguments after it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd7988ba" class="outline-3"&gt;
&lt;h3 id="orgd7988ba"&gt;You can specialise by value too&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd7988ba"&gt;
&lt;p&gt;
Since the &lt;code&gt;setf&lt;/code&gt; forms are just methods, you could if you wanted to
specialise them on the type of the new value as well as on the
locator. As a trivial example:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;assign-head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"Assigned an integer ~s"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;assign-head&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"Assigned a string ~s"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;assign-head&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"zero"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Assigned a string "zero"
&lt;/pre&gt;


&lt;p&gt;
Obviously there are better ways to do this, but it's a good
example of the flexibility that comes from &lt;code&gt;setf&lt;/code&gt; not really being
all that special a form at all: just a creative use of the power
of generic functions.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb382c77" class="outline-3"&gt;
&lt;h3 id="orgb382c77"&gt;Can we build our own &lt;code&gt;setf&lt;/code&gt;-like macros?&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb382c77"&gt;
&lt;p&gt;
Yes: &lt;code&gt;setf&lt;/code&gt; is entirely constructable within "ordinary" Lisp.
&lt;/p&gt;

&lt;p&gt;
There are two parts to the construction. Firstly, we need the
name of the method that underlies a particular selector.
&lt;/p&gt;

&lt;p&gt;
We can build our own functions with names like this, although not
using &lt;code&gt;defun&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defvar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;*weird-name*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"(1 2 3)"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;*weird-name*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"We did *weird-name* on ~s"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;*weird-name*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"a string"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;

"We did *weird-name* on \"a string\""
&lt;/pre&gt;


&lt;p&gt;
For &lt;code&gt;setf&lt;/code&gt;, the style of name used for the methods implementing the
different choices is &lt;code&gt;(setf selector)&lt;/code&gt; – a function named by a
list – where &lt;i&gt;selector&lt;/i&gt; is the symbol at the head of locator list.
(Some Lisps construct a symbol from the list elements, rather
than using it directly. I'm not sure what, if anything, the
Common Lisp language definition says about how this should work.)
&lt;/p&gt;

&lt;p&gt;
For the second part of the construction, &lt;code&gt;setf&lt;/code&gt; takes the locator,
synthesises the function name symbol using the selector, and
calls a generic function with this name, passing the new value
and the rest of the locator as arguments.
&lt;/p&gt;

&lt;p&gt;
So to define a new construct &lt;code&gt;our-setf&lt;/code&gt; we might do something like:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmacro&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;our-setf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;locator&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;new-value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;selector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;car&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;locator&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;our-setf-function-name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-symbol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;format&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"(our-setf ~a)"&lt;/span&gt;
&lt;span class="w"&gt;                                                           &lt;/span&gt;&lt;span class="nv"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;apply&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;our-setf-function-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;new-value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;,@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cdr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;locator&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
When called as something like &lt;code&gt;(our-setf (head '(1 2 3)) 0)&lt;/code&gt; the
macro will code to call a method &lt;code&gt;(our-setf head)&lt;/code&gt; (as a symbol),
passing it (&lt;code&gt;0 '(1 2 3))&lt;/code&gt; as arguments and allowing the machinery of
generic functions to determine which method is actually called.
We define these methods of the form &lt;code&gt;(our-setf head)&lt;/code&gt; and specialise
them as required.
&lt;/p&gt;

&lt;p&gt;
(It's actually a bit more complicated than this because we need
to define a generic function for &lt;code&gt;(our-setf head)&lt;/code&gt;. We have to go
backstage and programmatically define the generic function. But
the idea remains the same.)
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
After all this, my mental model of &lt;code&gt;setf&lt;/code&gt; is a lot clearer – and,
I hope, closer the reality at least. It combines a highly
structured use of macros, synthesised function names, and generic
functions – and no special machinery at all.
&lt;/p&gt;

&lt;p&gt;
However, there's some subtlety at play too, not obvious at first
acquaintance. We don't want our synthesised function names to
accidentally capture the names of user-supplied code. It's
possible that using a naming style like &lt;code&gt;setf-car&lt;/code&gt; would do just
this, and a program happens to define a function with this name.
But the names &lt;code&gt;setf&lt;/code&gt; synthesises are &lt;i&gt;lists&lt;/i&gt;, unlikely to be captured
accidentally, which lets us define the specialised methods "as
normal" even though some of the other parts of the process have
to happen backstage.
&lt;/p&gt;

&lt;p&gt;
This shows the power of macros and generic functions. It also
shows how deeply the latter are embedded into Lisp. They're
usually thought of as part of CLOS, but they actually have little
explicit relationship to class and objects at all, and have been
woven all through Lisp to build flexible code structures.
&lt;/p&gt;

&lt;p&gt;
UPDATED 2023-07-30: I incorrectly said originally that one
couldn't use forms like &lt;code&gt;(defun (setf abc) ...)&lt;/code&gt;: you can, just as
with &lt;code&gt;defmethod&lt;/code&gt; and &lt;code&gt;defgeneric&lt;/code&gt;, and name a function using a list.
Thanks to Hacker News contributor &lt;a href="https://phoe.github.io"&gt;phoe-krk&lt;/a&gt; for correcting me. I
was also slightly loose in my use of &lt;i&gt;specialisation&lt;/i&gt;, which I've
tightened up.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>macroprogramming</category><category>programming</category><guid>https://simondobson.org/2024/07/27/my-mental-model-of-setf-was-wrong/</guid><pubDate>Sat, 27 Jul 2024 13:29:18 GMT</pubDate></item><item><title>TIL: The most powerful one-line program in the world</title><link>https://simondobson.org/2024/07/17/til-the-most-powerful-one-line-program-in-the-world/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge9df00b" class="outline-2"&gt;
&lt;h2 id="orge9df00b"&gt;TIL: The most powerful one-line program in the world&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge9df00b"&gt;
&lt;p&gt;
Well, the most powerful I've found so far, anyway.
&lt;/p&gt;

&lt;p&gt;
Given my current obsession with &lt;a href="/categories/lisp/"&gt;Lisp&lt;/a&gt; you might reasonably expect it
to be in that language. But it isn't: it's in &lt;a href="https://en.wikipedia.org/wiki/APL_(programming_language)"&gt;APL&lt;/a&gt;, and it performs
one complete generation of &lt;a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life"&gt;Conway' Game of Life&lt;/a&gt; in one line of code:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  Life←{↑↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
…and does so inexplicably to anyone who doesn't know APL,
obviously, but the &lt;a href="https://aplwiki.com/wiki/John_Scholes%27_Conway%27s_Game_of_Life"&gt;basic algorithm&lt;/a&gt; is simple:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Take an array with 1 in each occupied cell and 0 elsewhere&lt;/li&gt;
&lt;li&gt;Build four new arrays by exchanging each element with its
neighbour up, down, left, and right&lt;/li&gt;
&lt;li&gt;Sum these arrays, which places the number of neighbours into each cell&lt;/li&gt;
&lt;li&gt;Cut-off these values to be 1 if the cell has a value of 3 or 4,
and 0 otherwise&lt;/li&gt;
&lt;li&gt;Re-format the arrays back into the starting configuration&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
I checked it out using &lt;a href="https://www.gnu.org/software/apl/"&gt;GNU APL&lt;/a&gt; and it works fine.
&lt;/p&gt;

&lt;p&gt;
I discovered this gem by accident, actually implemented &lt;a href="https://github.com/chmykh/apl-life"&gt;in APL in
Forth&lt;/a&gt; where someone has developed APL as an embedded DSL within
&lt;a href="https://en.wikipedia.org/wiki/Forth_(programming_language)"&gt;Forth&lt;/a&gt; (another language with which I have history). After a bit of
digging I found a similar APL in Lisp, &lt;a href="https://github.com/phantomics/april"&gt;April&lt;/a&gt;, which clearly needs
exploring.
&lt;/p&gt;

&lt;p&gt;
In many ways APL and Lisp are parallel tracks within programming
language evolution, taking a single data structure (lists or arrays)
and providing powerful ways to manipulate them. Lisp of course has
been extended with other data structures, including arrays, which
makes the fusion of array- and list-based programming rather
attractive.
&lt;/p&gt;

&lt;p&gt;
I can't help asking myself what would have happened if APL hadn't
fallen by the wayside. (I think this was inevitable, incidentally,
once the syntax became fixed: any language that requires its own
character set was always going to struggle.) We now have huge
applications for array processing, from graphics to machine
learning, and GPUs are from one perspective just APL accelerator
co-processors. The ideas are still massively relevant.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>apl</category><category>programming</category><category>til</category><guid>https://simondobson.org/2024/07/17/til-the-most-powerful-one-line-program-in-the-world/</guid><pubDate>Wed, 17 Jul 2024 09:20:53 GMT</pubDate></item><item><title>Class slots that work with classes and instances in CLOS</title><link>https://simondobson.org/2024/06/28/class-slots-that-work-with-classes-and-instances-in-clos/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgf8dcbd0" class="outline-2"&gt;
&lt;h2 id="orgf8dcbd0"&gt;Class slots that work with classes and instances in CLOS&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf8dcbd0"&gt;
&lt;p&gt;
I recently had a use case where I wanted to associate a constant
value with a class &lt;i&gt;and&lt;/i&gt; its instances – but I needed to be able to
get the value without having an instance to hand. This turns out
to be solvable in CLOS.
&lt;/p&gt;

&lt;p&gt;
In languages like Java you can associate class variables with
classes, which can then be accessed without having an instance of
the class. CLOS also has class-allocated slots, for example:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defclass&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;instance-slot&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ss"&gt;:initform&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;class-slot&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ss"&gt;:allocation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:class&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="ss"&gt;:initform&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:documentation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"A class with instance- and class-allocated slots."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
An instance of &lt;code&gt;A&lt;/code&gt; has two slots: &lt;code&gt;instance-slot&lt;/code&gt; stored per-instance,
and &lt;code&gt;class-slot&lt;/code&gt; stored only once and shared amongst all instances.
This is close to Java's notion of class variables, but one still
needs an instance against which to call the method. (Seibel makes
this point in &lt;a href="https://gigamonkeys.com/book/object-reorientation-classes"&gt;chapter 17 of "Practical Common Lisp"&lt;/a&gt;.)
&lt;/p&gt;

&lt;p&gt;
One could just create a basic object and retrieve the slot:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;slot-value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;make-instance&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'class-slot&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
but that's inelegant and could potentially trigger a lot of
unnecessary execution (and errors) if there are constructors
(overridden &lt;code&gt;initialize-instance&lt;/code&gt; methods) for &lt;code&gt;A&lt;/code&gt;. One could use the
metaobject protocol to introspect on the slot, but that's quite
involved and still allows the slot to be changed, which isn't part
of this use case.
&lt;/p&gt;

&lt;p&gt;
What I really want is to be able to define a generic function such
as &lt;code&gt;class-slot&lt;/code&gt; – but specialised against the &lt;i&gt;class&lt;/i&gt; &lt;code&gt;A&lt;/code&gt; rather than
against the &lt;i&gt;instances&lt;/i&gt; of &lt;code&gt;A&lt;/code&gt;. I thought this would need a metaclass
to define the method on, but it turned out that generic functions
are powerful enough on their own.
&lt;/p&gt;

&lt;p&gt;
The trick is to first define a generic method:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defgeneric&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;class-slot&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;classname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="s"&gt;"Access the class slot on class."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
As the argument name suggests, we're planning on passing a class
name to this method, not an instance. To set the value for &lt;code&gt;A&lt;/code&gt;, we
specialise the method as working on exactly the class A:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;class-slot&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;classname&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;eql&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'A&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The &lt;code&gt;eql&lt;/code&gt; specialiser selects this method only when exactly this
object is passed in – that is to say, the name of &lt;code&gt;A&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
But what if we have an &lt;i&gt;instance&lt;/i&gt; of &lt;code&gt;A&lt;/code&gt;? The same generic function
can still be used, but instead we specialise it against objects
of class &lt;code&gt;A&lt;/code&gt; in the usual way:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;class-slot&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;class-slot&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;class-name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;class-of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
If we now pass an instance of &lt;code&gt;A&lt;/code&gt;, we extract its class name and then
re-call the &lt;i&gt;same&lt;/i&gt; generic function, passing it the class name
instead of the object itself (which it doesn't need, because the
slot value is independent of the actual object). This will select
the correct specialisation and return the slot value.
&lt;/p&gt;

&lt;p&gt;
This approach works if we generate sub-classes of &lt;code&gt;A&lt;/code&gt;: we just use
&lt;code&gt;eql&lt;/code&gt; to specialise the generic function to the class we're
interested in. It also works fine with packages, since the
undecorated symbol passed to the specialiser will be expanded
correctly according to what symbols are in scope. However, the
value is &lt;i&gt;only&lt;/i&gt; associated with a single class, and isn't inherited.
That's not a massive limitation for my current use case, but would
be in general, I think.
&lt;/p&gt;

&lt;p&gt;
This approach critically relies on an easily-forgotten property of
Lisp: &lt;i&gt;values&lt;/i&gt; have types, but &lt;i&gt;variables&lt;/i&gt; don't, and we can
specialise the &lt;i&gt;same&lt;/i&gt; generic function against &lt;i&gt;any&lt;/i&gt; value &lt;i&gt;or&lt;/i&gt; type.
The pattern makes use of this to avoid actually storing the value
of &lt;code&gt;class-slot&lt;/code&gt; anywhere, which as a side effect avoids the problem
of someone accidentally assigning a new value to it. It's an
example of how powerful generic functions are: more so than the
method tables and messages found in most O-O languages. And it's
sufficiently structured that it's crying-out for a couple of
macros to define these kinds of class slots.
&lt;/p&gt;

&lt;p&gt;
UPDATED 2024-06-29: Fixed the typo in the class definition to use
&lt;code&gt;:initform&lt;/code&gt; and not &lt;code&gt;:initarg&lt;/code&gt;. Thanks to &lt;a href="https://framapiaf.org/@vindarel"&gt;@vindarel&lt;/a&gt; for pointing this
out to me.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>programming</category><guid>https://simondobson.org/2024/06/28/class-slots-that-work-with-classes-and-instances-in-clos/</guid><pubDate>Fri, 28 Jun 2024 16:17:41 GMT</pubDate></item><item><title>C++ template macroprogramming versus Lisp macros</title><link>https://simondobson.org/2024/06/21/c%2B%2B-template-macroprogramming-versus-lisp-macros/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org1aec963" class="outline-2"&gt;
&lt;h2 id="org1aec963"&gt;C++ template macroprogramming &lt;i&gt;versus&lt;/i&gt; Lisp macros&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1aec963"&gt;
&lt;p&gt;
Following on from &lt;a href="/2024/06/14/lisp-macros-versus-rust-macros/"&gt;Lisp macros versus Rust macros&lt;/a&gt;, I also want to
compare C++ templates to Lisp macros.
&lt;/p&gt;

&lt;p&gt;
Templates in C++ were designed as a way of generating typed versions
of classes. The template declares some type variables that can be
used as placeholders within a class declaration. When the template
is instanciated and provided with actual type names, these are
substituted for the type variables and the class is expanded. (It
used to literally happen like this, so each use generated a
completely new class. Modern compilers are smart enough to avoid the
code repetition.) A classic example is a typed singly-linked list:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
However, the template system also allows values to be used in
templates instead of (or as well as) type names. When these are
encountered they are expanded at compile-time, and may cause further
templates to be expanded. A classic example of this is to
pre-compute some factorials:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;factorial&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
In this code the first clause defines a template that defines the
usual recursive factorial calculation. The second clause bottoms-out
this recursion by defining a specialised template that directly
provides the factorial of zero. This can then be used in code such
as:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;factorial&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
5040
&lt;/pre&gt;


&lt;p&gt;
which outputs the factorial of 7 as one might expect – but with the
factorial having been computed at compile-time and inserted into the
code as a literal, so the calculation introduces no run-time calculation.
&lt;/p&gt;

&lt;p&gt;
There are some stringent limitations on the ways in which templates
can be expanded. They can't have mutable variables for a start
(that's why we needed to use the recursive factorial algorithm).
Weirdly this makes the template language a &lt;i&gt;functional programming
sub-set&lt;/i&gt; of C++. Having said that, as with Lisp macros, it allows
calculations that can be statically performed forward to be brought
forward to compile-time. This makes it useful for building read-only
tables, unrolling loops, and the like.
&lt;/p&gt;

&lt;p&gt;
It's &lt;a href="https://en.wikipedia.org/wiki/Template_metaprogramming#Benefits_and_drawbacks_of_template_metaprogramming"&gt;claimed&lt;/a&gt; that templates are now so akin to "normal" C++ that
they incur less of a readability penalty. That's a subjective
statement that may be true. But the template language &lt;i&gt;isn't&lt;/i&gt; C++.
While one &lt;i&gt;can&lt;/i&gt; write programs in it, they're &lt;i&gt;nothing like&lt;/i&gt; the C++ one
would normally write. The template language is Turing complete, but
that just means one can encode any &lt;i&gt;computation&lt;/i&gt;, not that one can
encode any &lt;i&gt;particular program&lt;/i&gt; – and most template programs will
require massive re-writing from the code one would write normally
for execution at run-time. Template macroprogramming is therefore a
non-trivial programming task to undertake.
&lt;/p&gt;

&lt;p&gt;
Again as with Rust &lt;i&gt;versus&lt;/i&gt; Lisp, C++ templates are an extension to
the language rather than a core part of it, although they're now
used quite extensively in the standard library for generic typing.
Also as with Rust, use of templates is semantically and
syntactically distinct from "normal" C++ code or syntax, and it's
this that causes the programming load.
&lt;/p&gt;

&lt;p&gt;
A Lisp macro for the factorial computation, by contrast, looks
&lt;i&gt;almost exactly&lt;/i&gt; like a normal factorial function that can access the
entire language, both when defined and when used:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmacro&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;factorial&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;labels&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;fact&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="w"&gt;                   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fact&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;1-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;`,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fact&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;princ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;factorial&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
5040
&lt;/pre&gt;


&lt;p&gt;
The choice of macro or function (&lt;code&gt;defmacro&lt;/code&gt; or &lt;code&gt;defun&lt;/code&gt;) has no further
&lt;i&gt;syntactic&lt;/i&gt; implications for the rest of the program, and no
restrictions on the code that can be used within the definition; we
could re-write the to use iteration, mutable variables, or any other
code, and it would simply be executed at compile-time. The whole
language is there, all the time. We can show this by taking a
factorial function written in "normal" Lisp and macro-ifying it to
be computed at compile-time:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fact&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s"&gt;"Compute the factorial of M."&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fact&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;1-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defmacro&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;factorial&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;`,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fact&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;princ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;factorial&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
5040
&lt;/pre&gt;


&lt;p&gt;
More importantly, Lisp (and indeed Rust) macro can abstract over
syntax as well as classes and values, and so allow the language to
be extended with new first-class-at-compile-time structures.
Templates are restricted to instanciating templates written with
a fixed syntax; in Lisp the syntax has to be "Lisp-like", although
that's a very light restriction; and in Rust a macro can use any
syntax that Rust can tokenise.
&lt;/p&gt;

&lt;p&gt;
While C++ templates are sometimes described as macroprogramming (or
metaprogramming), they're addressing a substantially different use
case to that addressed by Lisp or Rust macros, and doing so within a
more restricted computational and syntactic envelope.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>c++</category><category>lisp</category><category>macroprogramming</category><category>programming</category><guid>https://simondobson.org/2024/06/21/c%2B%2B-template-macroprogramming-versus-lisp-macros/</guid><pubDate>Fri, 21 Jun 2024 10:22:54 GMT</pubDate></item><item><title>Lisp macros versus Rust macros</title><link>https://simondobson.org/2024/06/14/lisp-macros-versus-rust-macros/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgf513c0d" class="outline-2"&gt;
&lt;h2 id="orgf513c0d"&gt;Lisp macros &lt;i&gt;versus&lt;/i&gt; Rust macros&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf513c0d"&gt;
&lt;p&gt;
I was talking with one of my colleagues the other day about
programming languages, and we ended up comparing macros in Rust and
Lisp.
&lt;/p&gt;

&lt;p&gt;
Rust has a couple of &lt;a href="https://doc.rust-lang.org/reference/procedural-macros.html"&gt;couple of different kinds&lt;/a&gt; of macros:
&lt;b&gt;declarative&lt;/b&gt; macros that pattern-match on arguments to emit code; and
&lt;b&gt;procedural&lt;/b&gt; macros that perform more general code-to-code
transformations. Lisp has only one kind that operates from code to
code.
&lt;/p&gt;

&lt;p&gt;
Both approaches are &lt;i&gt;far&lt;/i&gt; more powerful than the macros in C and C++,
which are basically just string expanders. Indeed, one definition of
macroprogramming is that it's writing code that returns code, and
there's a reasonable argument that C's "macros" are programs that
return &lt;i&gt;strings&lt;/i&gt; and therefore aren't macros at all. But that's just
bring pedantic.
&lt;/p&gt;

&lt;p&gt;
The Rust operations seem quite awkward, at least from a Lisp
perspective. They're invoked in a way that's syntactically different
to ordinary code, so it's always possible to see in the source code
where procedural code generation is occurring. Perhaps that's not an
entirely bad thing, as it makes it obvious when compile-time
computation occurs – although one might also argue that a true
language extension or DSL should be so seamless that you don't &lt;i&gt;need&lt;/i&gt;
to see it.
&lt;/p&gt;

&lt;p&gt;
I think a more basic difference is in how Rust needs to handle
code-type arguments. A macro is a function from code to code, so it
needs to represent its code arguments in a way that the macros
(which is also code) can manipulate. Lisp's &lt;a href="https://en.wikipedia.org/wiki/Homoiconicity"&gt;homoiconicity&lt;/a&gt; makes this
trivial: code is a list, just like non-code, and can ba manipulated
as such. Rust doesn't have this, so code needs to be passed to
macros as a token stream that's been parsed from the program text.
That's a reasonable solution to the problem, but it does mean that
to write macros you need to understand how Rust is tokenised. You
also get a token stream, not an abstract syntax tree (AST), which
means that manipulating complex code is more difficult: essentially
you need to re-create as much of the AST as you need and traverse it
within the macro body. There's a standard library that does this for
Rust's own syntax, which simplifies matters somewhat but still means
that writing macros exposes the programmer to the underlying
representations. Hopefully they won't change, as that would break a
lot of macros.
&lt;/p&gt;

&lt;p&gt;
By contrast, Lisp macros only require an understanding of Lisp
itself, not of its internals, and can operate on the entire detailed
structure of the code arguments. It's a striking example of the
power of homoiconicity.
&lt;/p&gt;

&lt;p&gt;
An approach closer to that of Rust is also available, in Common Lisp
anyway, in the form of &lt;b&gt;reader macros&lt;/b&gt; that modify the Lisp reader to
allow access to the character stream as the source code is being
read. I think I've only ever encountered read macros for providing
new styles of literals, or variants of strings that benefit from
being treated slightly differently at read-time: they're an unusual
use case, anyway, and Lisp makes the more usual case of macros
manipulating Lisp code a lot simpler, without exposing the
programmer to parsing.
&lt;/p&gt;

&lt;p&gt;
I suspect the main difference between the two languages' approaches
is that macros are &lt;b&gt;additional&lt;/b&gt; to Rust but &lt;b&gt;inherent&lt;/b&gt; to Lisp. None of
the core of Rust uses macros: they're for extensions. By contrast,
even common operations like &lt;code&gt;defun&lt;/code&gt; in Lisp are actually macros that
expand to the simpler core operations. This perhaps explains the
Rust designers' decision to make macros syntactically distinct.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>macroprogramming</category><category>programming</category><category>rust</category><guid>https://simondobson.org/2024/06/14/lisp-macros-versus-rust-macros/</guid><pubDate>Fri, 14 Jun 2024 13:23:46 GMT</pubDate></item><item><title>TIL: The loudest Lisp program in the world</title><link>https://simondobson.org/2024/05/03/til-the-loudest-lisp-program-in-the-world/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org69b2fff" class="outline-2"&gt;
&lt;h2 id="org69b2fff"&gt;TIL: The loudest Lisp program in the world&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org69b2fff"&gt;
&lt;p&gt;
Today I learned about a program that generates the sounds that help
people navigate as they exit long tunnels when an emergency such as
a fire has destroyed the visibility.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://blog.funcall.org//lisp%20psychoacoustics/2024/05/01/worlds-loudest-lisp-program/"&gt;The World's Loudest Lisp Program to the Rescue&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
This describes the challenges of building a software system that has
to work unmonitored once deployed, for years, as well as
withstanding a fairly rugged environment where, for example, the
installedc hardware will be periodically sprayed with a
high-pressure hose as the walls get cleaned. Overall the system is
soft real-time, but has to cope with component failure, network
partitions, consensus, and all the usual distributed systems
challenges, while be guaranteed to work when needed.
&lt;/p&gt;

&lt;p&gt;
The developers built the system in Common Lisp, which wouldn't be
the normal go-to choice for an embedded system. But their argument
was that they could better handle complex and changing requirements
by retaining a high level of abstraction, and that development was
overall far faster than using C. Modern Common Lisp compilers are so
efficient that there's no significant performance hit at deployment.
They made use of complicated components like planners (for which
Lisp is an ideal choice), and built a set of macros to wrap-up the
handling of industrial control and robust communications.
&lt;/p&gt;

&lt;p&gt;
It's a great read.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>programming</category><category>til</category><guid>https://simondobson.org/2024/05/03/til-the-loudest-lisp-program-in-the-world/</guid><pubDate>Fri, 03 May 2024 08:50:16 GMT</pubDate></item><item><title>Trying to refute some criticisms of Lisp</title><link>https://simondobson.org/2024/02/10/some-criticisms-of-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgdde4712" class="outline-2"&gt;
&lt;h2 id="orgdde4712"&gt;Trying to refute some criticisms of Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdde4712"&gt;
&lt;p&gt;
I recently had a discussion with someone on Mastodon about Lisp and
its perceived (by them) deficiencies as a language. There were some
interesting points, but I felt I had to try to refute them, at least
partially.
&lt;/p&gt;

&lt;p&gt;
I should say from the start the I'm not blind to Lisp's many
inadequacies and anachronisms, merely pointing out that it has a
context like everything else.
&lt;/p&gt;

&lt;p&gt;
There seemed to be two main issues:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Poor design decisions throughout, and especially a lack of static
typing&lt;/li&gt;
&lt;li&gt;The shadows of really early machines in &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cadr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
These points are tied together, but let's try to unpack them.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org56a728c" class="outline-3"&gt;
&lt;h3 id="org56a728c"&gt;Design&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org56a728c"&gt;
&lt;p&gt;
Let's start with design. Lisp is over half a century old. I'd argue
it was exceptionally well-designed – when it was designed. It
lacks most modern advances in types because … well, they didn't
exist, many of them arose as solutions to perceived problems in
Lisp (and Fortran), and many of those "solutions" still aren't
universally accepted, such as static typing itself.
&lt;/p&gt;

&lt;p&gt;
What we've actually learned is that many aspects of programming
lack any really universal solutions. If static typing were such an
obvious and unarguable route to efficiency and quality, all new
software would be being written in Haskell.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgfd9b92c" class="outline-3"&gt;
&lt;h3 id="orgfd9b92c"&gt;Typing and features&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfd9b92c"&gt;
&lt;p&gt;
And the lack of modern types isn't really as clear-cut as it
appears. The argument about the &lt;i&gt;lack&lt;/i&gt; of features in Lisp also
ignores the &lt;i&gt;presence&lt;/i&gt; of other features that are absent from
almost all other languages.
&lt;/p&gt;

&lt;p&gt;
Lisp's numeric types are surprisingly flexible. Indeed, Common Lisp
is still, in the 21st century, just about the only language in
which one can write modern crypto algorithms like Diffie-Hellman
key exchange without recourse to additional libraries, because it
has arbitrary-precision integer arithmetic built-in to the standard
operators. It also has rational numbers, so no loss of precision on
division either.
&lt;/p&gt;

&lt;p&gt;
The Common Lisp Object System (CLOS) is vastly more flexible than
&lt;i&gt;any&lt;/i&gt; modern object-oriented language. Sub-class methods can
specify their relationship with the methods they override, such as
being called after or just filtering the return values. Methods
themselves are multiple-dispatch and so can be selected based on
the types of their arguments as well as their target. The basic
mechanisms can be overridden or extended using a meta-object
protocol.
&lt;/p&gt;

&lt;p&gt;
Then there are macros. It's easy to underestimate these: after all,
C has macros, doesn't it? Well, yes – and no. A C macro is a
function from strings to strings that can do literal string
substitution of its arguments. A Lisp macro is a function from code
to code that can perform arbitrary computation. They're really not
the same things at all, and it's misleading that the same word is
used for both. (C++ templates are a closer analogy, but still
limited in comparison.)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgc66afe3" class="outline-3"&gt;
&lt;h3 id="orgc66afe3"&gt;The persistence of hardware 1: Stupid operation names&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc66afe3"&gt;
&lt;p&gt;
The complaints about &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are long established: they
were originally derived from &lt;a href="https://en.wikipedia.org/wiki/CAR_and_CDR"&gt;machine-language instructions on the
IBM 704&lt;/a&gt; that was used for the first Lisp implementations. They're
a terrible hold-over from that terrible decision … aren't they?
&lt;/p&gt;

&lt;p&gt;
Well, yes – and no. Of course they're terrible in one sense. But
&lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are basically nouns as far as Lisp programmers are
concerned. One could replace them with more modern usages like
&lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; (and indeed many Lisps define these using
macros).
&lt;/p&gt;

&lt;p&gt;
But it's important to remember that even "head" and "tail" are
analogies, sanctified by familiarity in the computer science
literature but still inexplicable to anyone outside. (If you doubt
that, try explaining to someone who isn't a programmer that a
shopping list has a "head" consisting of the first entry, and a
"tail" consisting of another, shorter, shopping list, is "in fact"
a recursive type, and you have to acquire each item of shopping
sequentially by working your way down the list from the head.)
&lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are artificial nouns, and &lt;code&gt;cons&lt;/code&gt; is an artificial
verb – but really no more artificial that &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;tail&lt;/code&gt;, and
&lt;code&gt;append&lt;/code&gt;, their rough equivalents in other languages.
&lt;/p&gt;

&lt;p&gt;
One can argue that the persistence of &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; drives the
persistence of compounds like &lt;code&gt;caaddr&lt;/code&gt;. But those are unnecessary
and seldom used: barely anyone would mind if they were removed.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org876f83b" class="outline-3"&gt;
&lt;h3 id="org876f83b"&gt;The persistence of hardware 2: It happens a lot&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org876f83b"&gt;
&lt;p&gt;
The suggestion that Lisp has hardware holdovers that should be
removed also neglects these holdovers in other languages.
&lt;/p&gt;

&lt;p&gt;
As an example, check the definition of &lt;code&gt;std::memcpy&lt;/code&gt; in C++. It
doesn't work with overlapping memory areas. Why is that? – why is
it so fast, but so dangerous? Does it relate to underlying machine
features, such as machine code move instructions on particular
machines with particular restrictions? Doesn't this introduce the
risk of security flaws like buffer overruns?
&lt;/p&gt;

&lt;p&gt;
Languages with more abstracted machine models don't have these
issues. I struggle to think of how one could even introduce the
&lt;i&gt;concept&lt;/i&gt; of a buffer overrun into Lisp, other than by using some
external raw-memory-access library: the language itself is immune,
as far as I know.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb28ab00" class="outline-3"&gt;
&lt;h3 id="orgb28ab00"&gt;The different choices&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb28ab00"&gt;
&lt;p&gt;
For the sake of argument, let's turn the argument around and ask:
give that early Lisps had proper macros, arbitrary-precision
integers, and so on, why did these features disappear from what we
now consider to be "the mainstream" of programming language design?
&lt;/p&gt;

&lt;p&gt;
Lisp's designers had a goal of building a powerful machine in which
to think: indeed, they intended it to eventually have its own
hardware designed specifically for it to run on. They therefore
didn't buy into the necessity of immediate performance, and as
their applications were largely symbolic AI they didn't need
numerical performance at all. They chose instead to create high-level
constructs even if these couldn't be compiled efficiently, and
explored using these to create more code as they identified more
and more abstract patterns whose details could be automated away.
(Paul Graham has &lt;a href="https://paulgraham.com/diff.html"&gt;a great essay&lt;/a&gt; on this.)
&lt;/p&gt;

&lt;p&gt;
Other language designers had other priorities. Often they needed to
do numerical simulation, and needed both performance and scale. So
they chose a different design pathway, emphasising efficient
compilation to the hardware they had available, and made the
compromises needed to get it. These have persisted, and that's why
we have languages with fixed-width integers scaled to fit into a
single machine register, and compilers that generate – but don't
directly execute – the code of programs, which limits our ability
to abstract and automate code generation without recourse to
complicated external tools.
&lt;/p&gt;

&lt;p&gt;
It's interesting to explore these choices. They're at one level
"just" historical: accidents that shaped the present. But at
another level they're still very much present in the hardware and
software landscape we inhabit. I think it's important that we
remind ourselves, continuously, that &lt;i&gt;much of that landscape is a
choice&lt;/i&gt;, not a given, and one we can question and change as we wish.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>programming</category><guid>https://simondobson.org/2024/02/10/some-criticisms-of-lisp/</guid><pubDate>Sat, 10 Feb 2024 17:07:48 GMT</pubDate></item><item><title>Locally overriding a function throughout a dynamic extent</title><link>https://simondobson.org/2024/01/22/locally-overriding-a-function-throughout-a-dynamic-extent/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge3e69f6" class="outline-2"&gt;
&lt;h2 id="orge3e69f6"&gt;Locally overriding a function throughout a dynamic extent&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge3e69f6"&gt;
&lt;p&gt;
A horribly dangerous but occasionally useful Lisp technique.
&lt;/p&gt;

&lt;p&gt;
My use case is as follows. &lt;code&gt;ebib&lt;/code&gt; has a command to copy a
formatted reference to the kill ring, using
&lt;code&gt;citar-citeproc-format-reference&lt;/code&gt; to actually do the formatting.
This means it's easy to change the style of the formatted
reference. However, &lt;code&gt;citar-citeproc-format-reference&lt;/code&gt;  itself uses
&lt;code&gt;citar-render-bib&lt;/code&gt; with a plain-text formatter. This is a sensible
default, but since I'm almost always copying references into
org-more documents, it loses a lot of information: it'd be better
to use the org formatter, but there's no argument to specify it.
&lt;/p&gt;

&lt;p&gt;
Clearly the correct solution is to change
&lt;code&gt;citar-citeproc-format-reference&lt;/code&gt; to take a key or optional
argument to specify the formatter, but that involves changing
someone else's code. The hacker solution is to change the call
&lt;code&gt;(citeproc-render-bib proc 'plain)&lt;/code&gt; to &lt;code&gt;(citeproc-render-bib proc
  'org)&lt;/code&gt;, but without re-writing the entire surrounding function to
keep the change just to the case where I need it.
&lt;/p&gt;

&lt;p&gt;
One way to do this would be to define a variant
&lt;code&gt;citeproc-render-bib&lt;/code&gt; that ignores its second argument (the
formatter) and always uses &lt;code&gt;'org&lt;/code&gt; instead, and then substitute
this variant for the original – but &lt;i&gt;only&lt;/i&gt; in the dynamic extent
of a &lt;i&gt;particular&lt;/i&gt; call to &lt;code&gt;citar-citeproc-format-reference&lt;/code&gt;. In
most languages this would be impossible – but not in Emacs Lisp.
&lt;/p&gt;

&lt;p&gt;
The solution is to use &lt;code&gt;cl-letf&lt;/code&gt;, which overrides the values of
general places for the duration of its body forms and restores the
original value on exit (normal or otherwise). The important point
is that the change occurs across the &lt;i&gt;extent&lt;/i&gt; of the body – the
body and all the code called from the body – and not merely in
the &lt;i&gt;scope&lt;/i&gt; of the body, which would only affect calls made there
directly.
&lt;/p&gt;

&lt;p&gt;
For example, consider in the following:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Which when called gives:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
36
&lt;/pre&gt;


&lt;p&gt;
If we want to override the default value (10) that's passed to &lt;code&gt;f&lt;/code&gt;
and instead use 25, we can define a new version that ignores the
second argument and uses our preferred default, and then
temporarily override the definition of &lt;code&gt;f&lt;/code&gt; in the calling
environment. If we want to use the original in the overriding
definition we need to grab it first. This gives:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cl-letf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;				    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
51
&lt;/pre&gt;


&lt;p&gt;
What's going on? The &lt;code&gt;cl-letf&lt;/code&gt; macro is like &lt;code&gt;let&lt;/code&gt; but works with
general places (as in &lt;code&gt;setf&lt;/code&gt;). It sets the places in its argument
list for the duration of its body, and then restores them on exit,
regardless of whether that exit is normal or &lt;i&gt;via&lt;/i&gt; a condition.
&lt;/p&gt;

&lt;p&gt;
The &lt;code&gt;(symbol-function 'f)&lt;/code&gt; form returns the place that stores the
function associated with symbol &lt;code&gt;f&lt;/code&gt;. We use it twice: once to
capture this function so we can use it later, and once to identify
the place where we store our new variant function. This new binding
is then used for all calls made from the body of the &lt;code&gt;cl-letf&lt;/code&gt;,
regardless of depth, so the call to &lt;code&gt;first&lt;/code&gt; makes use of our variant
definition of &lt;code&gt;f&lt;/code&gt; rather than the original – but with the original
then being used in the variant in our case!
&lt;/p&gt;

&lt;p&gt;
If we'd used &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;cl-flet&lt;/code&gt; instead of &lt;code&gt;cl-letf&lt;/code&gt; we wouldn't
have got the behaviour we're looking for:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cl-flet&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;	      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
36
&lt;/pre&gt;


&lt;p&gt;
Why? Because &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;cl-flet&lt;/code&gt; work over the &lt;i&gt;scope&lt;/i&gt; of the body,
so only calls to &lt;code&gt;f&lt;/code&gt; directly from the body of the assignment are
affected – not calls from calls. This is a great illustration of
the difference between the closely-related concepts of (static,
lexical) scope and (dynamic, run-time) extent, incidentally.
&lt;/p&gt;

&lt;p&gt;
I did say it was horrible :-). It's basically like adding
temporary &lt;code&gt;:around&lt;/code&gt; advice, and could probably benefit from a
macro to wrap it up. It's also inconceivable that it's thread- or
co-routine-safe, although I haven't checked.
&lt;/p&gt;

&lt;p&gt;
Part of the horribleness comes from the fact that the redefinition
is made for the entire dynamic extent of the body forms, which
means &lt;i&gt;all&lt;/i&gt; instances of the overridden function will use the
overridden value. There might be more than you think! But for
well-understood code it's sometimes useful, avoiding duplicating
code to make tiny changes.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>emacs</category><category>lisp</category><category>programming</category><guid>https://simondobson.org/2024/01/22/locally-overriding-a-function-throughout-a-dynamic-extent/</guid><pubDate>Mon, 22 Jan 2024 10:34:45 GMT</pubDate></item></channel></rss>