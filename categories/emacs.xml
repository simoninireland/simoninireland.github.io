<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson (Posts about emacs)</title><link>https://simondobson.org/</link><description></description><atom:link href="https://simondobson.org/categories/emacs.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Wed, 06 Mar 2024 19:17:45 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Local email from Office365 using OAUTH2 with mbsync</title><link>https://simondobson.org/2024/02/03/getting-email/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org7647c89" class="outline-2"&gt;
&lt;h2 id="org7647c89"&gt;Local email from Office365 using OAUTH2 with &lt;code&gt;mbsync&lt;/code&gt;&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7647c89"&gt;
&lt;p&gt;
I decided recently I wanted to have a more controlled email setup,
with a local archive rather than relying on remote servers
to keep everything. The point of this is twofold:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;To have a local archive of email, separate from the corporate
servers in case I need to change provider etc&lt;/li&gt;
&lt;li&gt;To use different MUAs locally, rather than being stuck with only
a few that will work with all the providers and that are clunky
and not well-integrated with my workflow&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
There's a lot of outdated information on the web about how to set
this up and it took some time for me to get a working setup, so I
thought I'd share my experience. Specifically this involves
interfacing command-line email receiving and sending to a Microsoft
Office365 server using IMAP and SMTP with corporate-grade OAUTH2 2FA
authentication: it's the last part that's tricky. As a bonus the
same approach also works for OAUTH2 and Gmail, dispensing with
insecure application passwords.
&lt;/p&gt;

&lt;p&gt;
In case it's not obvious by now, this is a hacker set-up that
requires quite a lot of technical manual configuration.
&lt;/p&gt;
&lt;/div&gt;


&lt;div id="outline-container-org04f0fec" class="outline-3"&gt;
&lt;h3 id="org04f0fec"&gt;How the internet email architecture works&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org04f0fec"&gt;
&lt;p&gt;
The old-school approach to email involves several elements, each
potentially provided by a different tool:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;a client program or &lt;i&gt;mail user agent&lt;/i&gt; (MUA) that presents email
to you and lets you search, delete, store, etc;&lt;/li&gt;
&lt;li&gt;a retrieval program or &lt;i&gt;mail delivery agent&lt;/i&gt; (MDA) that retrieves
mail from the providers and manages local email directories&lt;/li&gt;
&lt;li&gt;a sending program or &lt;i&gt;mail transfer agent&lt;/i&gt; (MTA) that takes; and
locally-created messages and transfer them to their intended
recipients.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
Modern GUI email clients like Thunderbird typically wrap-up all
three services into one program that's easier to deploy and manage,
but that therefore forces certain choices on the user. By reverting
to the older architecture we regain flexibility and choice, at the
expense of making our lives harder.
&lt;/p&gt;

&lt;p&gt;
All these tools need to authenticate against other services.
Traditionally this used usernames and passwords, which are clearly
inadequate for the modern web. Instead we need a system based
around stronger encryption.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://en.wikipedia.org/wiki/OAuth"&gt;OAUTH2&lt;/a&gt; is a an authorisation delegation protocol that lets a site
grant access to someone who's authenticated against another,
without getting sight of their credentials. The typical use case is
for a web site to allow users to sign-in using social media
services like Facebook or Google, which reduces the number of
passwords a user needs to remember or manage – and, totally
incidentally I'm sure, improves the social media services' ability
to track users' activities across the web.
&lt;/p&gt;

&lt;p&gt;
In our case, the OAUTH2 "flow" interacts with the authentication
provider and acquires a bearer token that can then be presented to
authorise access to the various email services.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org419d96b" class="outline-3"&gt;
&lt;h3 id="org419d96b"&gt;Outline solution&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org419d96b"&gt;
&lt;p&gt;
In outline the solution is as follows:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Install &lt;code&gt;mbsync&lt;/code&gt; as MDA&lt;/li&gt;
&lt;li&gt;Set up OAUTH2 authentication for Office365&lt;/li&gt;
&lt;li&gt;Use the to authenticate &lt;code&gt;mbsync&lt;/code&gt; against Office365 to allow
retrieval&lt;/li&gt;
&lt;li&gt;Install &lt;code&gt;msmtp&lt;/code&gt; as MTA, using the same authentication scheme&lt;/li&gt;
&lt;li&gt;Install &lt;code&gt;mu4e&lt;/code&gt; as MUA, since I want to read my email from inside
Emacs&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgad3a534" class="outline-3"&gt;
&lt;h3 id="orgad3a534"&gt;Packages&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgad3a534"&gt;
&lt;p&gt;
Under Arch Linux we need the &lt;code&gt;isync&lt;/code&gt; package for synchronisation
and the &lt;code&gt;cyrus-sasl-xoauth2&lt;/code&gt; provider for OAUTH authentication.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   sudo pacman -S isync
   yay -S cyrus-sasl-xoauth2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The same packages are available for other distros under similar
names. Note that the actual synchronisation tool is called
&lt;code&gt;mbsync&lt;/code&gt;, even though the package that contains it is called
&lt;code&gt;isync&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf0d5eb1" class="outline-3"&gt;
&lt;h3 id="orgf0d5eb1"&gt;OAUTH2 flow management&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf0d5eb1"&gt;
&lt;p&gt;
We want to use OAUTH2 to authenticate an IMAP transaction, so that
no additional passwords are needed. To this we need a script to
manage the OAUTH2 flow.
&lt;/p&gt;

&lt;p&gt;
Weirdly for an operation that's becoming so common on the web,
there doesn't seem to be a package that offers OAUTH2 from the
command line. However, there &lt;i&gt;is&lt;/i&gt; a script that does it that's
included as an example with the &lt;code&gt;mutt&lt;/code&gt; MUA, and we can use that. It
can be found (in Arch) in the &lt;code&gt;mutt&lt;/code&gt; package.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   sudo pacman -S mutt
   cp /usr/share/doc/mutt/samples/mutt_oauth2.py .
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This puts a copy of the script into the current directory, which we
can then edit in two ways:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;add the internal application identification and client secrets
for accessing Office365; and&lt;/li&gt;
&lt;li&gt;set up the security for the OAUTH2 access tokens when they're
downloaded and held locally.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
The client secret and app id need to be "proper", in the sense that
Office365 knows about them – but weirdly they &lt;i&gt;don't&lt;/i&gt; have to be
related to your email domain or cloud tenancy. It's perfectly fine
to use credentials available in the public domain, for example
those of Thunderbird:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="n"&gt;AppID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"08162f7c-0fd2-4200-a84a-f25a4db0b584"&lt;/span&gt;
   &lt;span class="n"&gt;ClientSecret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"TxRBilcHdC6WGBee]fs?QR:SJ8nI[g82"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
(I got these from &lt;a href="https://www.dcs.gla.ac.uk/~jacobd/posts/2022/03/configure-mutt-to-work-with-oauth-20/"&gt;here&lt;/a&gt;, but other than that have no idea where
they come from: they're &lt;i&gt;not&lt;/i&gt; the same as those in the
&lt;a href="https://hg.mozilla.org/comm-central/file/tip/mailnews/base/src/OAuth2Providers.jsm"&gt;Thunderbird source code&lt;/a&gt;, as far as I can tell.)
&lt;/p&gt;

&lt;p&gt;
The &lt;code&gt;mutt_oauth2.py&lt;/code&gt; script stores the tokens it manages in a
&lt;code&gt;gpg&lt;/code&gt;-encrypted file. You therefore need to provide your &lt;code&gt;gpg&lt;/code&gt;
keypair identification, and I'm assuming anyone wanting to get
local email has one of those! Mine is "simoninireland".
&lt;/p&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="n"&gt;GPGKey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"simoninireland"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
I edited the file to look like this, with some details elided:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="n"&gt;MSAppID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"08162f7c-0fd2-4200-a84a-f25a4db0b584"&lt;/span&gt;
   &lt;span class="n"&gt;MSClientSecret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"TxRBilcHdC6WGBee]fs?QR:SJ8nI[g82"&lt;/span&gt;
   &lt;span class="n"&gt;GPGKey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"simoninireland"&lt;/span&gt;

   &lt;span class="n"&gt;ENCRYPTION_PIPE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'gpg'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'--encrypt'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'--recipient'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GPGKey&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
   &lt;span class="n"&gt;DECRYPTION_PIPE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'gpg'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'--decrypt'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

   &lt;span class="n"&gt;registrations&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="s1"&gt;'google'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
           &lt;span class="o"&gt;...&lt;/span&gt;
           &lt;span class="s1"&gt;'client_id'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="s1"&gt;'client_secret'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;''&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
       &lt;span class="p"&gt;},&lt;/span&gt;
       &lt;span class="s1"&gt;'microsoft'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
           &lt;span class="o"&gt;...&lt;/span&gt;
           &lt;span class="s1"&gt;'client_id'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MSAppID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="s1"&gt;'client_secret'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MSClientSecret&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
       &lt;span class="p"&gt;},&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Put resulting script into &lt;code&gt;/usr/local/bin&lt;/code&gt; and make it executable.
Then run it in "authorisation" mode. The token file can go
anywhere: I put it in the directory used by &lt;code&gt;pass&lt;/code&gt; to allow for an
alternative access route:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   mutt_oauth2.py -t .password-store/email/work.gpg --authorize
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This will ask some questions:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;we want "microsoft" authentication&lt;/li&gt;
&lt;li&gt;and a "localhostauthcode" flow&lt;/li&gt;
&lt;li&gt;enter your email address (the actual user, not any alias)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
and it prints out a URL to copy into a browser to authenticate
against Office365's web interface. In my case this involved
interacting with the university's single sign-on and two-factor
authentication (2FA) system. Doing this successfully put the
necessary OAUTH2 tokens, encrypted, into the specified file.
Running:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   mutt_oauth2.py -t .password-store/email/work.gpg
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
will output the token, refreshing it automatically if it's
expired. This may ask for the GPG key's passphrase, if it has one,
and if it's not available from a local key agent.
&lt;/p&gt;

&lt;p&gt;
(All this security means that the bearer tokens are stored
encryoted at rest. It's a little inconvenient, though, as it means
you need to enter a &lt;code&gt;gpg&lt;/code&gt; passphrase periodically, and makes it
hard to run &lt;code&gt;mbsync&lt;/code&gt; in a &lt;code&gt;cron&lt;/code&gt; job. This is fine if, like me,
your level of security paranoia is such that you accept the minor
inconvenience in exchange for not having plain-text access tokens
lying around; on the other hand, you may decide that using, for
example, a machine with full-disc encryption is secure enough, in
which case you need to edit the &lt;code&gt;ENCRYPTION_PIPE&lt;/code&gt; and
&lt;code&gt;DECRYPTION_PIPE&lt;/code&gt; commands in the script to not do encryption: they
can basically just use &lt;code&gt;cat&lt;/code&gt; to store and retrieve the token information.)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org28857ec" class="outline-3"&gt;
&lt;h3 id="org28857ec"&gt;&lt;code&gt;mbsync&lt;/code&gt; for Office365&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org28857ec"&gt;
&lt;p&gt;
We now have OAUTH2 tokens for accessing Office365, which we can
integrate with our MDA. &lt;code&gt;mbsync&lt;/code&gt; has four main concepts:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Accounts, typically using IMAP&lt;/li&gt;
&lt;li&gt;IMAP message stores, which are remote&lt;/li&gt;
&lt;li&gt;Maildir stores, which are local&lt;/li&gt;
&lt;li&gt;Channels, which tie local and remote together&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
&lt;a href="https://en.wikipedia.org/wiki/Maildir"&gt;Maildir&lt;/a&gt; is a file format for storing email in a directory
structure, and is a long-running standard that's supported by lots
of tools. A maildir is typically presented in the MUA to a user as
a folder, and represented to the MDA as a directory.
&lt;/p&gt;

&lt;p&gt;
For Office365 we have:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   IMAPAccount work
   Host outlook.office365.com
   Port 993
   User &amp;lt;&amp;lt;work-email&amp;gt;&amp;gt;
   PassCmd "mutt_oauth2.py -t ~/.password-store/email/work.gpg"
   AuthMechs XOAUTH2
   SSLType IMAPS

   IMAPStore work-remote
   Account work

   MaildirStore work-local
   Subfolders Verbatim
   Path ~/Maildir/Work/
   Inbox ~/Maildir/Work/Inbox

   Channel Work
   Far :work-remote:
   Near :work-local:
   Patterns * !"Conversation History" !Calendar !Archive !Archives !Clutter !Drafts
   Create Both
   Expunge Both
   SyncState *
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
(See the &lt;code&gt;mbsync&lt;/code&gt; man pages for the details of its configuration.
&lt;code&gt;&amp;lt;&amp;lt;work-email&amp;gt;&amp;gt;&lt;/code&gt; should be a a proper username, not an alias.)
For our purposes the important line is the &lt;code&gt;PassCmd&lt;/code&gt; that calls our
edited script to retrieve the OAUTH2 bearer token. Email will be
downloaded into a maildir tree rooted at &lt;code&gt;~/Maildir/Work&lt;/code&gt;: you need
to create this before sync-ing.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   mkdir -p ~/Maildir/Work
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5fe8930" class="outline-3"&gt;
&lt;h3 id="org5fe8930"&gt;Sync'ing the email&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5fe8930"&gt;
&lt;p&gt;
For a full sync of all maildirs just run:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   mbsync -a
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
That can be time-consuming, as all the maildirs (&lt;i&gt;i.e.&lt;/i&gt;, folders)
have to be visited – and I have several hundred. A faster
option is to normally just look at (for example) the inbox:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   mbsync Work:INBOX
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This will ignore everything else, which means they'll drift – but
can be re-sync'ed periodically by running a full sync. One could
also set up a &lt;code&gt;cron&lt;/code&gt; job to do a full sync early every morning, for
example, as long as the access token was held unencrypted (see
above).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org978a264" class="outline-3"&gt;
&lt;h3 id="org978a264"&gt;Indexing email&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org978a264"&gt;
&lt;p&gt;
You'll almost certainly now want to index your newly-downloaded
trove of messages. There are two common tools for this &lt;code&gt;mu&lt;/code&gt; and
&lt;code&gt;notmuch&lt;/code&gt;. Both do basically the same job of maintaining a
structured and full-text index of messages that can be queried by
an appropriate MUA. I chose &lt;code&gt;mu&lt;/code&gt;, for no particular reason: some
people swear by &lt;code&gt;notmuch&lt;/code&gt;, which is based on extensive tagging of
messages and so might be more familiar to Gmail users.
&lt;/p&gt;

&lt;p&gt;
To install &lt;code&gt;mu&lt;/code&gt;, we first grab the package:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   pacman -S mu
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
We then initialise the index by running the indexer over the
maildir. If we also provide our own email address (or more than one) it knows to
index these differently.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   mu init -m ~/Maildir --my-address=&amp;lt;&amp;lt;work-email&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org098ee03" class="outline-3"&gt;
&lt;h3 id="org098ee03"&gt;Sending email&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org098ee03"&gt;
&lt;p&gt;
All of the above sets up the MDA to &lt;i&gt;get&lt;/i&gt; mail: we now need to be
able to &lt;i&gt;send&lt;/i&gt; mail. Fortunately we've already done most of the
hard work needed to get this working.
&lt;/p&gt;

&lt;p&gt;
We need a local MTA, for which I chose &lt;code&gt;msmtp&lt;/code&gt;. It understands
OAUTH2 natively. Installation in Arch is easy:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   sudo pacman -S msmtp
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
It needs to be pointed at the Office365 SMTP server and provided
with the OAUTH2 tokens, which are the same as we used above:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   defaults
   auth           on
   tls            on
   tls_starttls   on
   tls_trust_file /etc/ssl/certs/ca-certificates.crt
   logfile        ~/.msmtp.log

   account        work
   host           smtp.office365.com
   port           587
   auth           xoauth2
   user           &amp;lt;&amp;lt;work-email&amp;gt;&amp;gt;
   from           &amp;lt;&amp;lt;work-email&amp;gt;&amp;gt;
   passwordeval   "mutt_oauth2.py -t ~/.password-store/email/work.gpg"

   account default : work
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Again, see the &lt;code&gt;msmtp&lt;/code&gt; man pages for the details of this, and
replace &lt;code&gt;&amp;lt;&amp;lt;work-email&amp;gt;&amp;gt;&lt;/code&gt; as appropriate: the only interesting part
from our current perspective is that the &lt;code&gt;passwordeval&lt;/code&gt; line calls
exactly the same script as we used above.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org12cf7dd" class="outline-3"&gt;
&lt;h3 id="org12cf7dd"&gt;Reading and writing email&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org12cf7dd"&gt;
&lt;p&gt;
Finally we're ready to read email. I'll leave this to you: there
are lots of text-based email clients around, notably &lt;a href="http://www.mutt.org/"&gt;&lt;code&gt;mutt&lt;/code&gt;&lt;/a&gt; that we
encountered earlier. There's also &lt;a href="https://www.djcbsoftware.nl/code/mu/mu4e.html"&gt;&lt;code&gt;mu4e&lt;/code&gt;&lt;/a&gt; for reading email in
Emacs, making use of the &lt;code&gt;mu&lt;/code&gt; index; and &lt;a href="https://notmuch.readthedocs.io/en/latest/man1/notmuch.html"&gt;&lt;code&gt;notmuch&lt;/code&gt;&lt;/a&gt; also has &lt;a href="http://www.mutt.org/"&gt;an
Emacs interface&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
I use &lt;code&gt;mu4e&lt;/code&gt;. There's a lot of documentation on the web for setting
this up, all of which applies immediately to our new set-up: the
MUA is entirely independent of the MDA and MTA, and simply needs to
be pointed at the right directories and accounts.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org64bc918" class="outline-3"&gt;
&lt;h3 id="org64bc918"&gt;Accessing Gmail using OAUTH2&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org64bc918"&gt;
&lt;p&gt;
Gmail lets one use "app passwords" for accessing using IMAP, but
also supports OAUTH2, which is obviously more secure. The same
approach as above works for Gmail too. The initial credentials are:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   &lt;span class="n"&gt;GAppID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'406964657835-aq8lmia8j95dhl1a2bvharmfk3t1hgqj.apps.googleusercontent.com'&lt;/span&gt;
   &lt;span class="n"&gt;GClientSecret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'kSmqreRr0qwBWJgbf5Y-PjSU'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
(&lt;a href="https://www.dcs.gla.ac.uk/~jacobd/posts/2022/03/configure-mutt-to-work-with-oauth-20/"&gt;Same source&lt;/a&gt; as above.) Edit these into the script and change the
entries in the config files to call it to authenticate with an
appropriate store, for example:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;   mutt_oauth2.py -t .password-store/email/personal.gpg --authorize
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
and similarly in the configurations of &lt;code&gt;mbsync&lt;/code&gt; and &lt;code&gt;msmtp&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orged4f81e" class="outline-3"&gt;
&lt;h3 id="orged4f81e"&gt;Conclusion&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orged4f81e"&gt;
&lt;p&gt;
If you're still with me: congratulations, but you must &lt;i&gt;really&lt;/i&gt;
want to read your email old-school!
&lt;/p&gt;

&lt;p&gt;
For me, this has completely changed my relationship with email in
ways I didn't expect. Using Emacs means typically not having the
client visible all the time, which reduces the temptation to check
all the time. Instead I can adopt a more structured approach and
only check my email when I want to, which often means only three or
four times a day. It's also made email easier to manage, for
example by adding hyperlinks in my to-do list straight to messages
that need attention, and adding some integrations with org mode to
simplify email processing. Those are matters for another time,
though.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7160687" class="outline-3"&gt;
&lt;h3 id="org7160687"&gt;Resources&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7160687"&gt;
&lt;p&gt;
There are many resources on using &lt;code&gt;mbsync&lt;/code&gt;, &lt;code&gt;mu&lt;/code&gt;, &lt;code&gt;mu4e&lt;/code&gt;, and the
rest on the web. I found these covered all the topics in great
detail, with the exception of the OAUTH2 integration I've detailed
here. In particular I'd like to acknowledge the following:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://cvanelteren.github.io/post/mu4e/"&gt;Growing pains&lt;/a&gt;, Casper van Elteren's &lt;code&gt;mu4e&lt;/code&gt; setup that pointed me
in the right direction&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.macs.hw.ac.uk/~rs46/posts/2022-01-11-mu4e-oauth.html"&gt;Microsoft OAuth authentication with mu4e in Emacs&lt;/a&gt;, which uses
&lt;code&gt;offlineimap&lt;/code&gt;, a different MDA, and needs closer integration with
Microsoft Azure that often isn't possible for corporate email&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dcs.gla.ac.uk/~jacobd/posts/2022/03/configure-mutt-to-work-with-oauth-20/"&gt;Configure Mutt to work with OAuth 2.0&lt;/a&gt; that focuses on using
&lt;code&gt;mutt&lt;/code&gt; and Gmail&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>emacs</category><category>email</category><category>linux</category><category>sysadmin</category><guid>https://simondobson.org/2024/02/03/getting-email/</guid><pubDate>Sat, 03 Feb 2024 16:19:40 GMT</pubDate></item><item><title>Locally overriding a function throughout a dynamic extent</title><link>https://simondobson.org/2024/01/22/locally-overriding-a-function-throughout-a-dynamic-extent/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org5e8a8e5" class="outline-2"&gt;
&lt;h2 id="org5e8a8e5"&gt;Locally overriding a function throughout a dynamic extent&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5e8a8e5"&gt;
&lt;p&gt;
A horribly dangerous but occasionally useful Lisp technique.
&lt;/p&gt;

&lt;p&gt;
My use case is as follows. &lt;code&gt;ebib&lt;/code&gt; has a command to copy a
formatted reference to the kill ring, using
&lt;code&gt;citar-citeproc-format-reference&lt;/code&gt; to actually do the formatting.
This means it's easy to change the style of the formatted
reference. However, &lt;code&gt;citar-citeproc-format-reference&lt;/code&gt;  itself uses
&lt;code&gt;citar-render-bib&lt;/code&gt; with a plain-text formatter. This is a sensible
default, but since I'm almost always copying references into
org-more documents, it loses a lot of information: it'd be better
to use the org formatter, but there's no argument to specify it.
&lt;/p&gt;

&lt;p&gt;
Clearly the correct solution is to change
&lt;code&gt;citar-citeproc-format-reference&lt;/code&gt; to take a key or optional
argument to specify the formatter, but that involves changing
someone else's code. The hacker solution is to change the call
&lt;code&gt;(citeproc-render-bib proc 'plain)&lt;/code&gt; to &lt;code&gt;(citeproc-render-bib proc
  'org)&lt;/code&gt;, but without re-writing the entire surrounding function to
keep the change just to the case where I need it.
&lt;/p&gt;

&lt;p&gt;
One way to do this would be to define a variant
&lt;code&gt;citeproc-render-bib&lt;/code&gt; that ignores its second argument (the
formatter) and always uses &lt;code&gt;'org&lt;/code&gt; instead, and then substitute
this variant for the original – but &lt;i&gt;only&lt;/i&gt; in the dynamic extent
of a &lt;i&gt;particular&lt;/i&gt; call to &lt;code&gt;citar-citeproc-format-reference&lt;/code&gt;. In
most languages this would be impossible – but not in Emacs Lisp.
&lt;/p&gt;

&lt;p&gt;
The solution is to use &lt;code&gt;cl-letf&lt;/code&gt;, which overrides the values of
general places for the duration of its body forms and restores the
original value on exit (normal or otherwise). The important point
is that the change occurs across the &lt;i&gt;extent&lt;/i&gt; of the body – the
body and all the code called from the body – and not merely in
the &lt;i&gt;scope&lt;/i&gt; of the body, which would only affect calls made there
directly.
&lt;/p&gt;

&lt;p&gt;
For example, consider in the following:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Which when called gives:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
36
&lt;/pre&gt;


&lt;p&gt;
If we want to override the default value (10) that's passed to &lt;code&gt;f&lt;/code&gt;
and instead use 25, we can define a new version that ignores the
second argument and uses our preferred default, and then
temporarily override the definition of &lt;code&gt;f&lt;/code&gt; in the calling
environment. If we want to use the original in the overriding
definition we need to grab it first. This gives:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cl-letf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;				    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
51
&lt;/pre&gt;


&lt;p&gt;
What's going on? The &lt;code&gt;cl-letf&lt;/code&gt; macro is like &lt;code&gt;let&lt;/code&gt; but works with
general places (as in &lt;code&gt;setf&lt;/code&gt;). It sets the places in its argument
list for the duration of its body, and then restores them on exit,
regardless of whether that exit is normal or &lt;i&gt;via&lt;/i&gt; a condition.
&lt;/p&gt;

&lt;p&gt;
The &lt;code&gt;(symbol-function 'f)&lt;/code&gt; form returns the place that stores the
function associated with symbol &lt;code&gt;f&lt;/code&gt;. We use it twice: once to
capture this function so we can use it later, and once to identify
the place where we store our new variant function. This new binding
is then used for all calls made from the body of the &lt;code&gt;cl-letf&lt;/code&gt;,
regardless of depth, so the call to &lt;code&gt;first&lt;/code&gt; makes use of our variant
definition of &lt;code&gt;f&lt;/code&gt; rather than the original – but with the original
then being used in the variant in our case!
&lt;/p&gt;

&lt;p&gt;
If we'd used &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;cl-flet&lt;/code&gt; instead of &lt;code&gt;cl-letf&lt;/code&gt; we wouldn't
have got the behaviour we're looking for:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cl-flet&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;	      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
36
&lt;/pre&gt;


&lt;p&gt;
Why? Because &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;cl-flet&lt;/code&gt; work over the &lt;i&gt;scope&lt;/i&gt; of the body,
so only calls to &lt;code&gt;f&lt;/code&gt; directly from the body of the assignment are
affected – not calls from calls. This is a great illustration of
the difference between the closely-related concepts of (static,
lexical) scope and (dynamic, run-time) extent, incidentally.
&lt;/p&gt;

&lt;p&gt;
I did say it was horrible :-). It's basically like adding
temporary &lt;code&gt;:around&lt;/code&gt; advice, and could probably benefit from a
macro to wrap it up. It's also inconceivable that it's thread- or
co-routine-safe, although I haven't checked.
&lt;/p&gt;

&lt;p&gt;
Part of the horribleness comes from the fact that the redefinition
is made for the entire dynamic extent of the body forms, which
means &lt;i&gt;all&lt;/i&gt; instances of the overridden function will use the
overridden value. There might be more than you think! But for
well-understood code it's sometimes useful, avoiding duplicating
code to make tiny changes.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>emacs</category><category>lisp</category><category>programming</category><guid>https://simondobson.org/2024/01/22/locally-overriding-a-function-throughout-a-dynamic-extent/</guid><pubDate>Mon, 22 Jan 2024 10:34:45 GMT</pubDate></item><item><title>Making small changes to lots of files</title><link>https://simondobson.org/2024/01/01/making-small-changes-to-lots-of-files/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org6b6aab4" class="outline-2"&gt;
&lt;h2 id="org6b6aab4"&gt;Making small changes to lots of files&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6b6aab4"&gt;
&lt;p&gt;
I recently had to make tiny changes to a large number of files
spread nested through a directory structure. This turns out to be a
lot easier than I expected with Emacs.
&lt;/p&gt;

&lt;p&gt;
My use case was actually this blog. It's been on the go for a while
in several different formats, and over the years I've used tags to
drive different presentations – for example articles tagged 'news'
ended up on the front page. I no longer do this, which meant a lot
of redundant tags to be got rid of, mainly in Nikola's &lt;code&gt;.meta&lt;/code&gt;
metadata files but also embedded into &lt;code&gt;.md&lt;/code&gt; markdown and &lt;code&gt;.rst&lt;/code&gt;
restructured text..
&lt;/p&gt;

&lt;p&gt;
My plan was to use Emacs' &lt;code&gt;rgrep&lt;/code&gt; command to recursively traverse
the directory structure of posts to find the tags I wanted to
remove. This would give me a &lt;code&gt;grep&lt;/code&gt;-mode buffer that hyperlinks to
the files (and lines) needing changing, which I could then click
through to get to where each change needed to be made.
Straightforward, but time-consuming and error-prone when there were
about 150 files to be changed. Clearly a problem in need of a better
solution.
&lt;/p&gt;

&lt;p&gt;
I then discovered the &lt;a href="https://github.com/mhayashi1120/Emacs-wgrep/raw/master/wgrep.el"&gt;&lt;code&gt;wgrep&lt;/code&gt;&lt;/a&gt; ("writable &lt;code&gt;grep&lt;/code&gt;") package. This
makes the &lt;code&gt;grep&lt;/code&gt;-mode buffer editable, with changes being
written-back to the underlying files. &lt;i&gt;Exactly&lt;/i&gt; what I needed.
&lt;/p&gt;

&lt;p&gt;
Once I'd installed &lt;code&gt;wgrep&lt;/code&gt;, the workflow is ridiculously easy:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Using &lt;code&gt;rgrep&lt;/code&gt; gets a &lt;code&gt;grep&lt;/code&gt;-mode buffer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-c C-p&lt;/code&gt; makes the buffer editable&lt;/li&gt;
&lt;li&gt;Changing the lines. In my case I could use &lt;code&gt;string-replace&lt;/code&gt; to
remove the tags I wanted rid of. More complicated cases might
need &lt;code&gt;regexp-replace&lt;/code&gt; or even manual editing&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-x C-s&lt;/code&gt; writes the changes back out&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
(There are several other keybindings that &lt;code&gt;wgrep&lt;/code&gt; makes
available, notably &lt;code&gt;C-c C-k&lt;/code&gt; to discard all changes.)
&lt;/p&gt;

&lt;p&gt;
That's it! A job that I expected to take an hour took about 3
minutes.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>blogging</category><category>emacs</category><category>nikola</category><guid>https://simondobson.org/2024/01/01/making-small-changes-to-lots-of-files/</guid><pubDate>Mon, 01 Jan 2024 16:35:31 GMT</pubDate></item><item><title>Programmatically editing a file from Emacs Lisp</title><link>https://simondobson.org/2023/12/23/programmatically-editing-a-file-from-emacs-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge4baa1b" class="outline-2"&gt;
&lt;h2 id="orge4baa1b"&gt;Programmatically editing a file from Emacs Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge4baa1b"&gt;
&lt;p&gt;
This is something I frequently want to do: open a named file, work
on it programmatically using Lisp code, and save it back – all
without user intervention. Like a lot of things in Emacs, it's
easy once you know how.
&lt;/p&gt;

&lt;p&gt;
The trick is to create a new, named, buffer for the file to get
its contents. This is done with &lt;code&gt;find-file-noselect&lt;/code&gt; as opposed to
the more usual &lt;code&gt;find-file&lt;/code&gt; that's usually bound to &lt;code&gt;C-x C-f&lt;/code&gt;, and
as its name suggests finds (opens) the file without bringing it to
the user's attention. For example,
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;;; open the file in its own buffer&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;with-current-buffer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;find-file-noselect&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;;; work on it as required, as the current buffer&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"#+END_COMMENT"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;delete-region&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;newline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;;; save the results back&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;save-buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
(This example comes from my Emacs interface to the Nikola static
site builder used to maintain this site.) The code fragment
leaves the current buffer unchanged as far as the user (and the
rest of the code) is concerned, and so doesn't need to be
protected by &lt;code&gt;save-excursion&lt;/code&gt; or the like.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>emacs</category><category>lisp</category><guid>https://simondobson.org/2023/12/23/programmatically-editing-a-file-from-emacs-lisp/</guid><pubDate>Sat, 23 Dec 2023 17:16:42 GMT</pubDate></item><item><title>A quick function to delete whitespace in Lisp programs</title><link>https://simondobson.org/2023/01/13/a-quick-function-to-delete-whitespace-in-lisp-programs/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org8f9ef2e" class="outline-2"&gt;
&lt;h2 id="org8f9ef2e"&gt;A quick function to delete whitespace in Lisp programs&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8f9ef2e"&gt;
&lt;p&gt;
I've recently found myself constantly introducing – and then deleting –
whitespace when writing Lisp. A quick bit of Emacs hacking fixed it.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://simondobson.org/2023/01/13/a-quick-function-to-delete-whitespace-in-lisp-programs/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>lisp</category><guid>https://simondobson.org/2023/01/13/a-quick-function-to-delete-whitespace-in-lisp-programs/</guid><pubDate>Fri, 13 Jan 2023 15:32:37 GMT</pubDate></item><item><title>IDE convergence</title><link>https://simondobson.org/2021/02/23/ide-convergence/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;p&gt;I recently tried out a new development environment for my Python
development, and noticed an unexpected convergence in the designs of
the two tools.&lt;/p&gt;
&lt;!-- TASTER_END --&gt;

&lt;p&gt;I've been a long-time &lt;a href="https://emacs.org"&gt;Emacs&lt;/a&gt; user. I periodically
get a desire to try something new, something less old-school, just to
see whether there are advantages. There always &lt;em&gt;are&lt;/em&gt; advantages, of
course -- but often significant disadvantages as well, which often
keep me coming back to my comfort zone.&lt;/p&gt;
&lt;p&gt;My most recent excursion was to try Microsoft's &lt;a href="https://code.visualstudio.com/"&gt;VS
Code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Microsoft VS Code" src="https://simondobson.org/images/posts/20210223-vscode.png"&gt;&lt;/p&gt;
&lt;p&gt;This is handily cross-platform, being built in Javascript on top of
&lt;a href="https://www.electronjs.org/"&gt;Electron&lt;/a&gt;. It's got a lot of nice
features: a tree view of the project in the left-hand pane, syntax
colouring, code style linting, integrated debugging and unit test
running, integrated connection to git, and so on. Looking a little
closer there are all sorts of status markers around the code and in
the ribbons at the bottom of panes and the window overall to show
status that might be important.&lt;/p&gt;
&lt;p&gt;But it's so &lt;em&gt;slow&lt;/em&gt;. That's a feature of VS Code, not of Electron (as I
first suspected), because other Electron-based editors like
&lt;a href="https://atom.io/"&gt;Atom&lt;/a&gt; aren't as slow. And my development box isn't
the latest, but it also isn't &lt;em&gt;that&lt;/em&gt; old.&lt;/p&gt;
&lt;p&gt;So I reverted to Emacs, but upgraded it a little to more modern
standards. Specifically, I installed the
&lt;a href="https://elpy.readthedocs.io/en/latest/index.html"&gt;elpy&lt;/a&gt; Python IDE,
with assorted other packages suggested by various sites. The result is
this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Emacs with elpy" src="https://simondobson.org/images/posts/20210223-emacs.png"&gt;&lt;/p&gt;
&lt;p&gt;Now for anyone who's used Emacs for a while, it's definitely still
Emacs -- not least with the convoluted keystrokes and infinite
customisation you either love or hate. But it's striking how similar
the two IDEs now are, and striking how VS Code has inherited some
ideas from Emacs: resizeable panes, modelines in the ribbon, markers
in pane gutters, and so forth -- things that Emacs-based applications
have had for years, which have now migrated into "the mainstream".
Both the feature sets and the visuals of the two systems are very
similar indeed. Both are entirely cross-platform and extensible. For
VS Code you write extensions in Javascript; for Emacs you write them
in Lisp; and that's about it. And Emacs is a &lt;em&gt;lot&lt;/em&gt; faster on my
set-up. There are some limitations -- I've yet to get the hang of
using &lt;code&gt;pdb&lt;/code&gt; as a debugger, for example, especially for modules
and from within tests -- but the functionality is really quite comparable.&lt;/p&gt;
&lt;p&gt;I think it's safe to say there's been cross-fertilisation between VS
Code (and other IDEs) and Emacs over the years. A lot of the
developers of the former quite possibly used the latter. But I
strongly suspect that most of the traffic has gone &lt;em&gt;from&lt;/em&gt; Emacs &lt;em&gt;to&lt;/em&gt;
the other systems: the similarities are just too great to be
accidental. It's interesting to think that a system that emerged at
the dawn of the free-software movement has had -- and is still having
-- such an influence on modern development tools. And I'm happily back
in my comfort zone.&lt;/p&gt;</description><category>emacs</category><category>python</category><category>software engineering</category><category>vs code</category><guid>https://simondobson.org/2021/02/23/ide-convergence/</guid><pubDate>Tue, 23 Feb 2021 12:21:05 GMT</pubDate></item></channel></rss>