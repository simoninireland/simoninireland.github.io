<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson (Posts about emacs)</title><link>https://simondobson.org/</link><description></description><atom:link href="https://simondobson.org/categories/emacs.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Tue, 02 Jan 2024 10:24:07 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Making small changes to lots of files</title><link>https://simondobson.org/2024/01/01/making-small-changes-to-lots-of-files/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org7e5de6d" class="outline-2"&gt;
&lt;h2 id="org7e5de6d"&gt;Making small changes to lots of files&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7e5de6d"&gt;
&lt;p&gt;
I recently had to make tiny changes to a large number of files
spread nested through a directory structure. This turns out to be a
lot easier than I expected with Emacs.
&lt;/p&gt;

&lt;p&gt;
My use case was actually this blog. It's been on the go for a while
in several different formats, and over the years I've used tags to
drive different presentations – for example articles tagged 'news'
ended up on the front page. I no longer do this, which meant a lot
of redundant tags to be got rid of, mainly in Nikola's &lt;code&gt;.meta&lt;/code&gt;
metadata files but also embedded into &lt;code&gt;.md&lt;/code&gt; markdown and &lt;code&gt;.rst&lt;/code&gt;
restructured text..
&lt;/p&gt;

&lt;p&gt;
My plan was to use Emacs' &lt;code&gt;rgrep&lt;/code&gt; command to recursively traverse
the directory structure of posts to find the tags I wanted to
remove. This would give me a &lt;code&gt;grep&lt;/code&gt;-mode buffer that hyperlinks to
the files (and lines) needing changing, which I could then click
through to get to where each change needed to be made.
Straightforward, but time-consuming and error-prone when there were
about 150 files to be changed. Clearly a problem in need of a better
solution.
&lt;/p&gt;

&lt;p&gt;
I then discovered the &lt;a href="https://github.com/mhayashi1120/Emacs-wgrep/raw/master/wgrep.el"&gt;&lt;code&gt;wgrep&lt;/code&gt;&lt;/a&gt; ("writable &lt;code&gt;grep&lt;/code&gt;") package. This
makes the &lt;code&gt;grep&lt;/code&gt;-mode buffer editable, with changes being
written-back to the underlying files. &lt;i&gt;Exactly&lt;/i&gt; what I needed.
&lt;/p&gt;

&lt;p&gt;
Once I'd installed &lt;code&gt;wgrep&lt;/code&gt;, the workflow is ridiculously easy:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Using &lt;code&gt;rgrep&lt;/code&gt; gets a &lt;code&gt;grep&lt;/code&gt;-mode buffer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-c C-p&lt;/code&gt; makes the buffer editable&lt;/li&gt;
&lt;li&gt;Changing the lines. In my case I could use &lt;code&gt;string-replace&lt;/code&gt; to
remove the tags I wanted rid of. More complicated cases might
need &lt;code&gt;regexp-replace&lt;/code&gt; or even manual editing&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C-x C-x&lt;/code&gt; writes the changes back out&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
(There are several other keybindings that &lt;code&gt;wgrep&lt;/code&gt; makes
available, notably &lt;code&gt;C-c C-k&lt;/code&gt; to discard all changes.)
&lt;/p&gt;

&lt;p&gt;
That's it! A job that I expected to take an hour took about 3
minutes.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>blogging</category><category>emacs</category><category>nikola</category><guid>https://simondobson.org/2024/01/01/making-small-changes-to-lots-of-files/</guid><pubDate>Mon, 01 Jan 2024 16:35:31 GMT</pubDate></item><item><title>Programmatically editing a file from Emacs Lisp</title><link>https://simondobson.org/2023/12/23/programmatically-editing-a-file-from-emacs-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org746c351" class="outline-2"&gt;
&lt;h2 id="org746c351"&gt;Programmatically editing a file from Emacs Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org746c351"&gt;
&lt;p&gt;
This is something I frequently want to do: open a named file, work
on it programmatically using Lisp code, and save it back – all
without user intervention. Like a lot of things in Emacs, it's
easy once you know how.
&lt;/p&gt;

&lt;p&gt;
The trick is to create a new, named, buffer for the file to get
its contents. This is done with &lt;code&gt;find-file-noselect&lt;/code&gt; as opposed to
the more usual &lt;code&gt;find-file&lt;/code&gt; that's usually bound to &lt;code&gt;C-x C-f&lt;/code&gt;, and
as its name suggests finds (opens) the file without bringing it to
the user's attention. For example,
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;;; open the file in its own buffer&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;with-current-buffer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;find-file-noselect&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;;; work on it as required, as the current buffer&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"#+END_COMMENT"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;delete-region&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;newline&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;;; save the results back&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;save-buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
(This example comes from my Emacs interface to the Nikola static
site builder used to maintain this site.) The code fragment
leaves the current buffer unchanged as far as the user (and the
rest of the code) is concerned, and so doesn't need to be
protected by &lt;code&gt;save-excursion&lt;/code&gt; or the like.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>emacs</category><category>lisp</category><guid>https://simondobson.org/2023/12/23/programmatically-editing-a-file-from-emacs-lisp/</guid><pubDate>Sat, 23 Dec 2023 17:16:42 GMT</pubDate></item><item><title>A quick function to delete whitespace in Lisp programs</title><link>https://simondobson.org/2023/01/13/a-quick-function-to-delete-whitespace-in-lisp-programs/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgd0a15fe" class="outline-2"&gt;
&lt;h2 id="orgd0a15fe"&gt;A quick function to delete whitespace in Lisp programs&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd0a15fe"&gt;
&lt;p&gt;
I've recently found myself constantly introducing – and then deleting –
whitespace when writing Lisp. A quick bit of Emacs hacking fixed it.
&lt;/p&gt;

&lt;p&gt;&lt;a href="https://simondobson.org/2023/01/13/a-quick-function-to-delete-whitespace-in-lisp-programs/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><category>lisp</category><guid>https://simondobson.org/2023/01/13/a-quick-function-to-delete-whitespace-in-lisp-programs/</guid><pubDate>Fri, 13 Jan 2023 15:32:37 GMT</pubDate></item><item><title>IDE convergence</title><link>https://simondobson.org/2021/02/23/ide-convergence/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;p&gt;I recently tried out a new development environment for my Python
development, and noticed an unexpected convergence in the designs of
the two tools.&lt;/p&gt;
&lt;!-- TASTER_END --&gt;

&lt;p&gt;I've been a long-time &lt;a href="https://emacs.org"&gt;Emacs&lt;/a&gt; user. I periodically
get a desire to try something new, something less old-school, just to
see whether there are advantages. There always &lt;em&gt;are&lt;/em&gt; advantages, of
course -- but often significant disadvantages as well, which often
keep me coming back to my comfort zone.&lt;/p&gt;
&lt;p&gt;My most recent excursion was to try Microsoft's &lt;a href="https://code.visualstudio.com/"&gt;VS
Code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Microsoft VS Code" src="https://simondobson.org/images/posts/20210223-vscode.png"&gt;&lt;/p&gt;
&lt;p&gt;This is handily cross-platform, being built in Javascript on top of
&lt;a href="https://www.electronjs.org/"&gt;Electron&lt;/a&gt;. It's got a lot of nice
features: a tree view of the project in the left-hand pane, syntax
colouring, code style linting, integrated debugging and unit test
running, integrated connection to git, and so on. Looking a little
closer there are all sorts of status markers around the code and in
the ribbons at the bottom of panes and the window overall to show
status that might be important.&lt;/p&gt;
&lt;p&gt;But it's so &lt;em&gt;slow&lt;/em&gt;. That's a feature of VS Code, not of Electron (as I
first suspected), because other Electron-based editors like
&lt;a href="https://atom.io/"&gt;Atom&lt;/a&gt; aren't as slow. And my development box isn't
the latest, but it also isn't &lt;em&gt;that&lt;/em&gt; old.&lt;/p&gt;
&lt;p&gt;So I reverted to Emacs, but upgraded it a little to more modern
standards. Specifically, I installed the
&lt;a href="https://elpy.readthedocs.io/en/latest/index.html"&gt;elpy&lt;/a&gt; Python IDE,
with assorted other packages suggested by various sites. The result is
this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Emacs with elpy" src="https://simondobson.org/images/posts/20210223-emacs.png"&gt;&lt;/p&gt;
&lt;p&gt;Now for anyone who's used Emacs for a while, it's definitely still
Emacs -- not least with the convoluted keystrokes and infinite
customisation you either love or hate. But it's striking how similar
the two IDEs now are, and striking how VS Code has inherited some
ideas from Emacs: resizeable panes, modelines in the ribbon, markers
in pane gutters, and so forth -- things that Emacs-based applications
have had for years, which have now migrated into "the mainstream".
Both the feature sets and the visuals of the two systems are very
similar indeed. Both are entirely cross-platform and extensible. For
VS Code you write extensions in Javascript; for Emacs you write them
in Lisp; and that's about it. And Emacs is a &lt;em&gt;lot&lt;/em&gt; faster on my
set-up. There are some limitations -- I've yet to get the hang of
using &lt;code&gt;pdb&lt;/code&gt; as a debugger, for example, especially for modules
and from within tests -- but the functionality is really quite comparable.&lt;/p&gt;
&lt;p&gt;I think it's safe to say there's been cross-fertilisation between VS
Code (and other IDEs) and Emacs over the years. A lot of the
developers of the former quite possibly used the latter. But I
strongly suspect that most of the traffic has gone &lt;em&gt;from&lt;/em&gt; Emacs &lt;em&gt;to&lt;/em&gt;
the other systems: the similarities are just too great to be
accidental. It's interesting to think that a system that emerged at
the dawn of the free-software movement has had -- and is still having
-- such an influence on modern development tools. And I'm happily back
in my comfort zone.&lt;/p&gt;</description><category>emacs</category><category>python</category><category>software engineering</category><category>vs code</category><guid>https://simondobson.org/2021/02/23/ide-convergence/</guid><pubDate>Tue, 23 Feb 2021 12:21:05 GMT</pubDate></item></channel></rss>