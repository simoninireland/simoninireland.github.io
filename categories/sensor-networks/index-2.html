<!DOCTYPE html>
<html prefix="
	og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Posts about sensor networks (old posts, page 2) | Simon Dobson</title>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
<link rel="stylesheet" href="assets/css/normalize.css">
<link rel="stylesheet" href="assets/css/main.css">
<link href="../../assets/css/baguetteBox.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/fonts.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://simondobson.org/categories/sensor-networks/index-2.html">
<link rel="prev" href="index-3.html" type="text/html">
<link rel="next" href="index-1.html" type="text/html">
<!--[if lt IE 9]><script src="../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-10943215-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-10943215-1');
</script><link rel="alternate" type="application/rss+xml" title="RSS for tag sensor networks" hreflang="en" href="../sensor-networks.xml">
</head>
<body>
  <a href="#page-content" class="sr-only sr-only-focusable">
    Skip to main content
  </a>

  

  <section id="header"><a href="../../">
      <div class="logo">
	  <div id="nologoimage">
	    Simon Dobson
	  </div>
      </div>
    </a>
  </section><section id="socialNav"><!-- Navigation Menu - on top on small screens, down the left on larger --><div class="navlinks">
<!--
      <a href="/">
	<div id="titleauth">
	    by Simon Dobson
	</div>
      </a>
-->

      <!-- Navigation links (hidden by default) -->
      <div id="navmenuitems">
	      <a href="../../index.html" title="Home">
	<span class="menuitemtext">Home</span>
	<span class="menuitemicon"><i class="fa fa-home"></i></span>
      </a>
      <a href="../../personal/" title="About me">
	<span class="menuitemtext">About me</span>
	<span class="menuitemicon"><i class="fa fa-user"></i></span>
      </a>
      <a href="../../research/" title="Research">
	<span class="menuitemtext">Research</span>
	<span class="menuitemicon"><i class="fa fa-lightbulb"></i></span>
      </a>
      <a href="../../development/projects/" title="Software">
	<span class="menuitemtext">Software</span>
	<span class="menuitemicon"><i class="fa fa-cogs"></i></span>
      </a>
      <a href="../../writing/" title="Writing">
	<span class="menuitemtext">Writing</span>
	<span class="menuitemicon"><i class="fa fa-feather"></i></span>
      </a>
      <a href="../../personal/contact/" title="Contact">
	<span class="menuitemtext">Contact</span>
	<span class="menuitemicon"><i class="fa fa-info-circle"></i></span>
      </a>
      <a href="../../rss.xml" title="RSS">
	<span class="menuitemtext">RSS</span>
	<span class="menuitemicon"><i class="fa fa-rss"></i></span>
      </a>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
     <img alt="Creative Commons License CC-BY-NC-SA-4.0" style="border-width:0" src="../../images/cc-by-nc-sa-4.0.png"></a>
  
  

      </div>

      <!-- "Hamburger menu" / "Bar icon" to toggle the navigation links -->
      <a href="javascript:void(0);" id="hamburger" class="icon" onclick="toggleNav()">
	<i class="fa fa-bars">
	</i>
      </a>
    </div>
  </section><section class="page-content"><div class="content" rel="main">
    <header><h1>Posts about sensor networks (old posts, page 2)</h1>
        <div class="metadata">
                            <p class="feedlink">
                                    <a href="../sensor-networks.xml" hreflang="en" type="application/rss+xml">RSS feed</a>

                </p>

            
        </div>
    </header><div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../../2011/10/03/research-fellowship-sensor-networks/" class="u-url">Research fellowship in sensor networks</a></h1>

        
        <div class="metadata">
            <p class="dateline"><a href="../../2011/10/03/research-fellowship-sensor-networks/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2011-10-03T11:36:09+01:00" title="2011-10-03 11:36">2011-10-03 11:36</time></a></p>

                <p class="commentline"><i class="fa fa-comment"></i>         <a href="../../2011/10/03/research-fellowship-sensor-networks/#disqus_thread" data-disqus-identifier="cache/posts/2011/10/03/research-fellowship-sensor-networks.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <p></p>
<p>We have a three-year postdoc available immediately to work on programming languages and platforms for sensor networks.</p>
<!--more-->
<p></p>
<h3>Research Fellow – CD1060</h3>
School of Computer Science,  £32,751 - £35,788 per annum. Start: As soon as possible, Fixed Term 3 years
<p>We seek a  Research Fellow to design and implement an integrated software platform  based on mission specifications and evolution operators. The work will  be evaluated based on case study deployments in the context of  real-world large-scale WSANs.  You will specifically focus on generative programming techniques to  integrate the overall design, and will work with Professors Dearle and  Dobson.</p>
<p>The project involves re-architecting WSAN systems so that system-wide  behaviour is defined using explicit mission specifications. These allow  top-level constraints and trade-offs to be captured directly and used to  inform software deployment and evolution in a well-founded manner. We  compile mission-level components to collections of node-level components  connected using network overlays. We maintain both mission constraints  and management interfaces through to run-time where they can be  manipulated by evolution and recomposition operators.</p>
<p>You should have a good honours degree in Computer Science or a related  discipline, and preferably have, or be about to obtain, a PhD in  Computer Science. You will have strong software  development/OS/programming language skills. Experience in generative  programming, compilers, operating systems, component deployment and/or  sensor networks would be advantageous.  You should be a highly motivated  individual and be able to lead the day-to-day work.</p>
<p>This is a fixed-term post for 3 years, starting as soon as possible.</p>
<p>More information on the <a href="https://www.vacancies.st-andrews.ac.uk/ViewVacancy.aspx?enc=mEgrBL4XQK0+ld8aNkwYmO99IkxqH9eijvsCHvh08k+ze95XIC1eOev5uSd2OdKptmQ+WLedl2A+Qx1I/0DsdA==" target="_blank">university's job page</a>. You can also email <a href="mailto:alan.dearle@st-andrews.ac.uk">Al</a> or <a href="mailto:simon.dobson@st-andrews.ac.uk">myself</a> for more information.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../../2011/09/09/smart-grids/" class="u-url">An issue for smart grids</a></h1>

        
        <div class="metadata">
            <p class="dateline"><a href="../../2011/09/09/smart-grids/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2011-09-09T07:30:09+01:00" title="2011-09-09 07:30">2011-09-09 07:30</time></a></p>

                <p class="commentline"><i class="fa fa-comment"></i>         <a href="../../2011/09/09/smart-grids/#disqus_thread" data-disqus-identifier="cache/posts/2011/09/09/smart-grids.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <p></p>
<p>Unbeknown to her -- until she reads this, anyway -- the other day my mother trashed an idea that's been a cornerstone of a lot of research on smart grids.</p>
<!--more-->

<p>In the UK the fire services often send people around to check people's smoke alarms and the like. Not usually firemen <em>per se</em>, but information providers who might reasonably be described as the propaganda department of the fire service, intent on giving advice on how not to burn to death. They also change batteries. Pretty useful public service, all told.</p>
<p>Anyway, my mother lives in Cheshire, and recently had a visit from two such anti-fire propagandists.They did the usual useful things, but also got talking about the various risk factors one can avoid beyond the usual ones of having a smoke alarm and not searching for gas leaks with a cigarette lighter. The conversation turned to the subject of appliances, and they revealed that the most dangerous appliances from a fire-causing perspective are washing machines. In fact, they said, the Cheshire fire service gets called to more washing-machine fires than <em>any other kind</em> of domestic fire. (I don't know if that includes hoaxes, which are a major problem.) Since they have in common (a) lots of current and (b) water, I would guess that dishwashers are a similar problem.</p>
<p>So their advice was never to run a washing machine or dishwasher overnight or when in bed, as the chances of a fire are relatively high. "Relatively high" probably still means low on any meaningful  scale, but it makes sense to minimise even small hazards when the costs are potentially to catastrophic.</p>
<p>Mum related this to me to encourage me also not to run appliances at night. But of course this has research consequences as well.</p>
<p>Smart grids are the application of information technology to the provision and management of electricity and (to a lesser extent) gas. The idea is that the application of data science can provide better models of how people use their power, and can allow the grid operators and power generators to schedule and provision their supplies more accurately. It usually involves more detailed monitoring of electricity usage, for example using an internet-connected smart meter to log and return the power usage profile instead of just aggregated power usage for billing.</p>
<p>The idea is getting more and more common because of the rise in renewable energy. Most countries have feed-in tariffs for the grid that power generators have to pay. The scheme is usually some variant of the following: at every accounting period (say three hours), each generator  has to present an estimate of the power it will generate in the <em>next</em> several accounting periods (say three).  So using these numbers, every three hours an electricity generator has to say how much power it will inject into the grid in the next nine hours. There's a complementary tariff scheme for aggregate consumers (not individuals), and taken together these allow the grid operators to balance supply and demand. The important point is that this exercise has real and quantifiable financial costs: generators are charged if they over- or under-supply by more than an agreed margin of error.</p>
<p>Now this is fine if you run a gas-, oil- or nuclear-powered power station. However, if you run a wind farm or a tidal barrage, it's rather more tricky, since you don't know with any accuracy how much power you'll generate: it depends on circumstances outwith your control. (I did some work for a company making control systems for wind farms, and one of their major issues was power prediction.) The tariffs can be a show-stopper, and can cause a lot of renewable-energy generators to run significantly below capacity just to hedge their tariff risk.</p>
<p>The other side of smart grids is to manage demand. It's well-known that demand is spiky, for example leaping a half-time in a popular televised football match as everybody puts the kettle on. A major goal of smart grids is to smooth-out demand, and one of the ways to do this is to identify power loads than can be time-shifted: they are relatively insensitive to when they occur, and so can be moved so that they occur at times when the aggregate power demand is less. In a domestic setting, some kinds of storage heating work like this and can create and store heat during off-peak hours (overnight). Lights and television can't be time-shifted as they're needed at particular times. So what are the major power loads, other than storage heating, in domestic settings that can apparently be time-shifted?</p>
<p>Washing machines and dishwashers.</p>
<p>Except we now know that time-shifting them to overnight running runs exactly counter to fire service advice as it increases the dangers of domestic fires. So one of the major strategies for smart grid demand management would, if widely deployed, potentially cause significant losses, of property and even lives. Reducing energy bills will (in time) increase the insurance premiums for anyone allowing time-shifting of their main appliances. In other words, while these risks exist, its a non-starter.</p>
<p>In some ways this is a good thing: good to learn about now, anyway, before too much investment. There are a lot of things that could be done to ameliorate the risks, for example designing machines explicitly designed for time-shifted operation.</p>
<p>But I think a more pertinent observation is the holistic nature of this kind of pervasive computing system. You can't treat <em>any one element</em> in isolation, as they all interact with each other. It's as though pervasive computing breaks the normal way we think of computing systems as being built from independent components. In pervasive computing the composition operators are non-linear: two independently-correct components or solutions do not always compose to form one that is also correct. This has major implications for design and analysis, as well as for engineering.</p>
<p>Thanks, mum!</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../../2011/06/06/cfp-midsens11/" class="u-url">Call for papers: MidSens'11</a></h1>

        
        <div class="metadata">
            <p class="dateline"><a href="../../2011/06/06/cfp-midsens11/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2011-06-06T10:30:18+01:00" title="2011-06-06 10:30">2011-06-06 10:30</time></a></p>

                <p class="commentline"><i class="fa fa-comment"></i>         <a href="../../2011/06/06/cfp-midsens11/#disqus_thread" data-disqus-identifier="cache/posts/2011/06/06/cfp-midsens11.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <p></p>
<p>Papers are invited on topics in middleware, tools and services  for sensor and other embedded systems.</p>
<!--more-->
<p></p>
<h2>Sixth International Workshop on Middleware Tools, Services and  Run-time Support for Networked Embedded Systems (<a href="http://www.midsens.org/index.html" target="_blank">MidSens’11</a>)</h2>
<h3>Co-located with <a href="http://2011.middleware-conference.org/">Middleware 2011</a> (December 12th - December 16th, 2011), Lisbon, Portugal</h3>
<p>The aim of MidSens’11 is to stimulate research in the  specific domain of middleware for networked embedded systems. This  year’s focus is on sensor networks and robotics control – a broader  focus than the previous editions – since we believe that the extended  scope will result in complementary and synergetic submissions from  researchers working in both niches. Along with the ‘core’ topic of  middleware architectures, services and tool support, MidSens’11 will  also seek quality papers describing novel programming languages,  run-time support and relevant experience reports. As with previous  editions of this workshop, MidSens’11 will investigate how middleware  support can relieve developers from low-level, platform specific  concerns, while enabling optimal exploitation of available resources. We  hope that you will be able to join us in Lisbon on December 12th 2011.</p>
<p>Middleware for networked embedded systems such as sensor networks and  robotics is a critical research domain which addresses key challenges  that application developers are facing today. The five previous editions  of this workshop (<a href="http://www.cs.kuleuven.ac.be/conference/MidSens2006/">MidSens'06</a>, <a href="http://www.cs.kuleuven.be/conference/MidSens2007/">MidSens'07</a>, <a href="http://www.comp.lancs.ac.uk/computing/midsens08/">MidSens'08</a>, <a href="http://distrinet.cs.kuleuven.be/events/midsens09/">MidSens'09</a> and <a href="http://www.midsens.org/2010/"> MidSens'10</a>)  attracted researchers from Europe, Asia, and the United States. The  MidSens workshop series has served to trigger and guide research efforts  to create an <em>integrated middleware vision</em>, which is required to  handle the challenges inherent in developing, deploying and managing  complex networked embedded applications in an efficient way.</p>
<p>The workshop seeks papers in, but not limited to:</p>
<ul>
<li>Middleware Tools and Architectures:
<ul>
<li> Architectures for networked embedded systems.</li>
    <li> Novel programming abstractions.</li>
    <li> Lightweight agent middleware for embedded systems.</li>
    <li> Testing and simulation tools.</li>
    <li> Fault identification, diagnosis and repair.</li>
</ul>
</li>
    <li>Middleware services:
<ul>
<li> Location tracking, localization, and synchronization.</li>
    <li> Support for real-time and safety-critical systems.</li>
    <li> Data management, aggregation and filtering.</li>
    <li> Energy-aware middleware mechanisms.</li>
    <li> Fault tolerance, reliability and quality of service.</li>
    <li> Privacy and security services.</li>
    <li> Virtualization, sharing and trading of resources.</li>
</ul>
</li>
    <li>Run-time Support:
<ul>
<li> Overlay and topology creation, maintenance and   management.</li>
    <li> Resource/Service discovery and management.</li>
    <li> Support for reconfiguration and adaptation.</li>
    <li> Effective naming and addressing schemes.</li>
    <li> Support for modeling and enacting safe software  reconfiguration.</li>
</ul>
</li>
    <li>Management and Experiences:
<ul>
<li> Managing heterogeneity and network dynamism.</li>
    <li> Integration of embedded systems with web services.</li>
    <li> Experience and evaluation of middleware platforms.</li>
    <li> Support for the unification of various networked embedded platforms.</li>
    <li> Shared infrastructure embedded systems.</li>
</ul>
</li>
</ul>
<h3>Submission</h3>
<p>Submitted papers must be original work in English without substantial  overlap with papers that have been published or that are simultaneously  submitted to a journal or conference with proceedings. Submissions must  not exceed 6 pages, must strictly follow the ACM conference proceedings  format, and must be submitted in PDF format.  All workshop papers will  be uploaded to the ACM Digital Library. Full instructions can be found <a href="http://www.midsens.org/2011/submission.html" target="_blank">here</a>.</p>
<h3>Important dates</h3>
<ul>
<li>Paper submission: 15 August 2011</li>
    <li>Review notification: 29 September 2011</li>
    <li>Camera-ready: 10 October 2011</li>
    <li>Registration: 7 October 2011</li>
</ul>
<h3>Programme committee</h3>
<ul>
<li>Gordon Blair, Lancaster University, UK</li>
    <li>Vinny Cahill, Trinity College, Ireland</li>
    <li>Paolo Costa, Imperial College London, UK</li>
    <li>Simon Dobson, University of St. Andrews, UK</li>
    <li>Michael Fisher, University of Liverpool, UK</li>
    <li>Wen Hu, CSIRO, Australia</li>
    <li>Joerg Kaiser, University of Magdeburg, Germany</li>
    <li>Torsten Kroeger, Stanford University, USA</li>
    <li>Ajay Kshemkalyani, University of Illinois at Chicago</li>
    <li>Kristof Van Laerhoven, Technical University of Darmstadt</li>
    <li>Sam Michiels, K.U.Leuven, Belgium</li>
    <li>Nader Mohamed, United Arab Emirates University, UAE</li>
    <li>Luca Mottola, SICS, Sweden</li>
    <li>Mirco Musolesi, University of Birmingham, UK</li>
    <li>Dennis Pfisterer, University of Lübeck, Germany</li>
    <li>Kay Römer, University of Lübeck, Germany</li>
    <li>Coen De Roover, Vrije Universiteit Brussel, Belgium</li>
    <li>Romain Rouvoy, INRIA Lille, France</li>
    <li>Jo Ueyama, Universidade de Sao Paulo, Brazil</li>
</ul>
<p></p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../../2011/05/20/evolving/" class="u-url">Evolving programming languages</a></h1>

        
        <div class="metadata">
            <p class="dateline"><a href="../../2011/05/20/evolving/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2011-05-20T08:00:11+01:00" title="2011-05-20 08:00">2011-05-20 08:00</time></a></p>

                <p class="commentline"><i class="fa fa-comment"></i>         <a href="../../2011/05/20/evolving/#disqus_thread" data-disqus-identifier="cache/posts/2011/05/20/evolving.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <p></p>
<div id="heystaks_preview" style="width: 100%;height: 100%"></div>
Most programming languages have fixed definitions and hard boundaries. In thinking about building software for domains we don't understand very well, a case can be made for a more relaxed, evolutionary approach to language design.
<!--more-->

<p>I've been thinking a lot about languages this week, for various reasons: mainly about the recurring theme of what are the right programming structures for systems driven by sensors, whether they're pervasive systems or sensor networks. In either case, the structures we've evolved for dealing with desktop and server systems don't feel like they're the right abstractions to effectively take things forward.</p>
<p>A favourite example is the <tt>if</tt> statement: first decide whether a condition is true or false, and execute one piece of code or another depending on which it is. In a sensor-driven system we often can't make this determination cleanly because of noise and uncertainty -- and if we can, it's often only probably true, and only for a particular period. So are <tt>if</tt> statements (and <tt>while</tt> loops and the like) actually appropriate constructs, when we can't make the decisions definitively?</p>
<p>Whatever you think of this example (and plenty of people hate it) there are certainly differences between what we want to do between traditional and highly sensorised systems, and consequently how we program them. The question is, how do we work out what the right structures are?</p>
<p>Actually, the question is broader than this. It should be: how do we improve our ability to develop languages that match the needs of particular computational and conceptual domains?</p>
<p>Domain-specific languages (DSLs) have a tangled history in computer science, pitched between those who like the idea and those who prefer their programming languages general-purpose and re-usable across a <em>range</em> of domains. There are strong arguments on both sides: general-purpose languages are more productive to learn and are often more mature, but can be less efficient and more cumbersome to apply; DSLs mean learning <em>another</em> language that may not last long and will probably have far weaker support, but can be enormously more productive and well-targeted in use.</p>
<p>In some ways, though, the similarities between traditional languages and DSLs are very strong. As a general rule both will have syntax and semantics defined up-front: they won't be experimental in the sense of allowing experimentation <em>within the language itself</em>. If we don't know what we're building, does it make sense to be this definite?</p>
<p>There are alternatives. One that I'm quite keen on is the idea of <a href="../../2010/05/languages-extensible-vms/" target="_blank">extensible virtual machines</a>, where the primitives of a language are left "soft" to be extended as required. This style has several advantages. Firstly, it encourages experimentation by not forcing a strong division of concepts between the language we write (the target language) and the language this is implemented in (the host language): the two co-evolve. Secondly, it allows extensions to be as efficient as "base" elements, assuming we can reduce the cost of building new elements appropriately low. Thirdly, it allows multiple paradigms and approaches to co-exist within the same system, since they can share some elements while having other that differ.</p>
<p>Another related feature is the ability to modify the compiler: that is, don't fix the syntax <em>or</em> the way in which its handled. So as well as making the low level soft, we also make the high level soft. The advantage here is two-fold. Firstly, we can modify the forms of expression we allow to capture concepts precisely. A good example would be the ability to add concurrency control to a language: the low-level might use semaphores, but programing might demand monitors or some other construct. Modifying the high-level form of the language allows these constructs to be added if required -- and ignored if not.</p>
<p>This actually leads to the  second advantage, that we can <em>avoid</em> features we don't want to be available, for example not providing general recursion for languages that need to complete all operations in a finite time. This is something that's surprisingly uncommon in language design despite being common in teaching programming: leaving stuff out can have a major simplifying effect.</p>
<p>Some people argue that syntax modification is unnecessary in a language that's sufficiently expressive, for example Haskell. I don't agree. The counter-example is actually in Haskell itself, in the form of the <tt>do</tt> block syntactic sugar for simplifying monadic computations. This <em>had</em> to be in the language to make it in any way usable, which implied a change of definition, and the monad designers couldn't add it without the involvement of the language "owners", even though the construct is really just a <a href="../../2010/06/monads-language-design-perspective/" target="_blank">re-formulation and generalisation of one common in other languages</a>. There are certainly other areas in which such sugaring would be desirable to make the forms of expression simpler and more intuitive. The less well we understand a domain, the more likely this is to happen.</p>
<p>Perhaps surprisingly, there are a couple of existing examples of systems that do pretty much what I'm suggesting. Forth is a canonical example (which explains my current work on <a href="http://www.threaded-interpreter.org" target="_blank">Attila</a>); Smalltalk is another, where the parser an run-time are almost completely exposed, although abstracted behind several layers of higher-level structure. Both the languages are quite old, have devoted followings, and weakly and dynamically typed -- and may have a lot to teach us about how to develop languages for new domains. They share a design philosophy of allowing a language to <em>evolve</em> to meet new applications. In Forth, you don't so much write applications as extend the language to meet the problem; in Smalltalk you develop a model of co-operating objects that provide   direct-manipulation interaction through the GUI.</p>
<p>In both cases the whole language, including the definition and control structures, is built in the language itself <em>via</em> bootstrapping and cross-compilation. Both languages are compiled, but in both cases the separation between run-time and compile-time are weak, in the sense that the compiler is by default available interactively. Interestingly this doesn't stop you building "normal" compiled applications: cross-compile a system without including the compiler itself, a process that can still take advantage of any extensions added into the compiler without cluttering-up the compiled code. You're unlikely to get strictly the best performance or memory footprint as you might with a mature C compiler, but you <em>do</em> get advantages in terms of expressiveness and experimentation which seem to outweigh these in a domain we don't understand well. In particular, it means you can evolve the language quickly, easily, and within itself, to explore the design space more effectively and find out whether your wackier ideas are actually worth pursuing further.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../../2011/04/11/spectrum/" class="u-url">Adventures at either end of the performance spectrum</a></h1>

        
        <div class="metadata">
            <p class="dateline"><a href="../../2011/04/11/spectrum/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2011-04-11T19:00:43+01:00" title="2011-04-11 19:00">2011-04-11 19:00</time></a></p>

                <p class="commentline"><i class="fa fa-comment"></i>         <a href="../../2011/04/11/spectrum/#disqus_thread" data-disqus-identifier="cache/posts/2011/04/11/spectrum.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <p></p>
<p>Over the past week I've been playing with some very small machines intended as sensor network nodes. Paradoxically this has involved deploying a ridiculous amount of computing power.</p>
<!--more-->

<p>Most of my work on sensor networks is at the level of data and sensors, not hardware. I was feeling the need to get my hands dirty, so I bought an <a href="http://www.arduino.cc">Arduino</a>, an open-source prototyping platform that's actually somewhat <em>less</em> capable than many of the nodes we work with. They're basically a hobbyist platform and are often looked down upon by professionals as being toys.</p>
<p>I think these criticisms are unfair. Firstly, Arduinos massively simplify software development by abstracting-away from a lot of the complexities that simply aren't needed in many applications. Secondly, unlike a lot of sensor network hardware, they're <em>mainstream</em> and will benefit from competition, economies of scale and the like in a way that more specialised kit probably never will. Thirdly, as the centres of <a href="http://shieldlist.org/" target="_blank">an ecosystem of other boards</a> they can focus on doing one function -- co-ordination -- and let the daughter boards focus on their <em>their</em> own functions, rather than tying everything together.</p>
<p>In some ways this makes hardware more like software, and more amenable to software-like rapid development cycles. It means that each component can move up its own learning curve independently of the others, and not hold everything back to the speed of the slowest (and often hardest-to-improve) component. That has been the unfortunate outcome several times in the past: I'm reminded strongly of the demise of the <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Transputer" target="_blank">Transputer</a>, that lost its early lead by trying to be too integrated. (That's an interesting story for another time.)</p>
<p>One good example of Arduino  re-use is that it can interface to Zigbee radios, specifically to <a href="http://www.digi.com/products/wireless-wired-embedded-solutions/zigbee-rf-modules/zigbee-mesh-module/xbee-zb-module.jsp" target="_blank">Digi's range of XBee modules</a>. Zigbee is the latest-and-greatest short-range wireless protocol, and Arduino kit can interface directly to it rather than relying on an integrated radio sub-system. They mesh together and do all sorts of other fun stuff that's great for sensor systems, and I'm looking forward to understanding them better,</p>
<p>However getting XBee radios to work often involves re-flashing their firmware to make sure they take on the appropriate role in the mesh network. The tool that Digi provide to do this (unhelpfully called X-CTU)  only runs on Windows. As might not be a complete surprise, I don't have any Windows machines.</p>
<p>I doubt I'm unusual in this: if you're the sort of person who's likely to play around with hobbyist hardware, there's a reasonable chance that you run Linux and/or Mac OS X as your main or only operating systems. So building kit for the hobby hardware market that relies on Windows-only tools is short-sighted. And unnecessary: there are plenty of cross-platform user interface tools available for C, or they could just write it in Java.</p>
<p>By a strange quirk I also don't have an Intel-based Linux machine at the moment, so I was left in something of a quandary as to how to run the necessary firmware tools. Solving it takes us to the other end of the performance spectrum. The solution was to run X-CTU under the <a href="http://www.winehq.org/" target="_blank">Wine</a> emulator for Linux, with the Linux in question being a <a href="http://www.debian.org" target="_blank">Debian</a> installation running virtualised under <a href="http://www.virtualbox.org/" target="_blank">VirtualBox</a> on my Macbook Air. To put it another way, I created a virtual stand-alone PC on my Mac, within which I installed Linux, which therefore thought it was running on its own separate machine, within which I installed a Windows emulation layer and ran X-CTU -- all to change the firmware on a radio with significantly less computational power than a central heating thermostat.</p>
<p>It's things like this that make one realise how ludicrously, insanely overpowered modern computers are.</p>
<p>The Mac can run three-layer emulations like this without any problem at all, and can still do a load of other stuff simultaneously. And it's a laptop, and not one noted for being massively powerful by modern standards. It seems rather perverse to need to deploy this kind of power to work with such tiny machines. I think there are several lessons. Computing power really is really, <em>really</em> cheap -- so cheap that it's not worth worrying about it, and we haven't come close to hitting a plateau in practical terms yet. But this just highlights that programming sensor networks requires a completely different discipline and skill-set, which may not be common in programmers of more recent vintage. If this gap is going to remain -- and <a href="../../2010/03/things-that-wont-change/">I think it is</a> -- it's something we need to consider in the ways we teach computer science.</p>
    </div>
    </article>
</div>
        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="index-3.html" rel="next">Newer posts</a>
            </li>
            <li class="previous">
                <a href="index-1.html" rel="prev">Older posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="simoninireland";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
  </section><script src="../../assets/js/baguetteBox.min.js"></script><script src="../../assets/js/moment-with-locales.min.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(2, "YYYY-MM-DD HH:mm");
  </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
    ignoreClass: 'islink',
    captions: function(element) {
    return element.getElementsByTagName('img')[0].alt;
    }});
  </script><script src="../../assets/js/ToggleNav.js"></script>
</body>
</html>
