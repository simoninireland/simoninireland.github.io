<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson (Posts about xbee)</title><link>https://simondobson.org/</link><description></description><atom:link href="https://simondobson.org/categories/xbee.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Sat, 16 Mar 2024 13:15:01 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>XBee sleeping</title><link>https://simondobson.org/2013/08/02/xbee-sleeping/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;p&gt;Clearly saving battery power means getting the XBee radio to sleep at the behest of the Arduino. This turns out to be fairly simple, but does require modifying the XBee shield slightly.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;Our &lt;a href="https://simondobson.org/2013/07/31/power/"&gt;previous measurements&lt;/a&gt; indicate that the XBee draws about 45mA of current -- something we have to save for battery-powered nodes. Fortunately XBee radios have a hardware-controlled sleep mode, so the Arduino can sleep the radio when not in use.&lt;/p&gt;
&lt;p&gt;Since XBees work as a &lt;a href="https://simondobson.org/2013/07/02/mesh-network/"&gt;mesh network&lt;/a&gt;, it's clearly going to be an issue as to &lt;em&gt;when&lt;/em&gt; a radio sleeps, and for how long -- since when asleep the radio can't route packets, and so the network starts to break down. But that's a higher-level concern: for the moment, we'll focus on the mechanics of getting the XBee to sleep.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Pins relating to XBee sleep mode" src="https://simondobson.org/images/citizen-sensing/sleep-pin.jpg"&gt;&lt;/p&gt;
&lt;p&gt;The basic mechanism is simple, and involves hardware and software. At the hardware level, the XBee uses pin 9 (shown in red right) as a control pin. This pin can be used to sleep the radio: setting it to 3,3V ("high" or "asserted") causes the radio to sleep; setting it to 0V ("low" or "deasserted") wakes the radio up. The XBee only takes account of the pin when in certain sleep modes, however: these are analogous to the &lt;a href="https://simondobson.org/2013/07/23/arduino-watchdog/"&gt;Arduino's sleep modes&lt;/a&gt;. This is the software part: the XBee needs to be placed into the correct sleep mode, and can then be controlled from the Arduino.&lt;/p&gt;
&lt;p&gt;Also note I/O line 7, pin 12 (in green): we'll come back to this later.&lt;/p&gt;
&lt;p&gt;We'll deal with the hardware part first, and then the software.&lt;/p&gt;
&lt;h3&gt;Getting access to the sleep pin&lt;/h3&gt;

&lt;p&gt;The XBee shield doesn't connect the sleep pin to anything by default, so to control it we have to connect it. There are several ways we could do this, with the simplest being to solder a wire from the pan on pin 9 to an appropriate header on the shield, which is then connected to a digital pin on the Arduino. For simplicity we'll start with a wire that's long enough to reach &lt;em&gt;any&lt;/em&gt; header: we'll actually plug it into the header for the Arduino's D7 pin.&lt;/p&gt;
&lt;p&gt;There's a slight concern about voltage levels in this approach, as the
Arduino operates at 5V while the XBee uses 3.3V. Experimentally this
doesn't seem to make a difference; for a production system we'd
probably want to create a resistor network to drop the voltage to that
needed by the radio, to avoid any risk of damage. We'd also probably
want to solder a header to XBee pin 9's pad to make it easier to
connect the wiring.&lt;/p&gt;
&lt;h3&gt;Setting the sleep mode&lt;/h3&gt;

&lt;p&gt;The XBee's sleep mode is controlled by a single AT command called (unsurprisingly) SM. The default (SM 0) is for the radio to be on all the time; SM 1 selects the pin-sleep mode described above, and is the one we'll be using as it places the radio under the (hardware) control of the Arduino. (There are other sleep modes where the radio sleeps under the control of its own internal timer. Some projects use the radio's timer to wake the Arduino rather than the other way round: we prefer to keep the Arduino in control.)&lt;/p&gt;
&lt;p&gt;Setting the sleep mode is simply a matter of &lt;a href="https://simondobson.org/2013/08/02/at-commands-2"&gt;issuing the appropriate AT command&lt;/a&gt;. However, as with a lot of things to do with hardware, we have to set things up slightly first.&lt;/p&gt;
&lt;p&gt;The first issue concerns the setting of the XBee's sleep pin. If we
select pin-sleep mode with the pin high, the XBee will sleep
immediately, which might not be what we intended. So if we've
connected the sleep pin to D7, we need to set things up so that the
pin is low to keep the radio awake, and then select its sleep mode:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="cp"&gt;#define XBEE_SLEEP 7                &lt;/span&gt;&lt;span class="c1"&gt;// Xbee sleep pin on D7&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;pinMode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;XBEE_SLEEP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUTPUT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// sleep control&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;digitalWrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;XBEE_SLEEP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LOW&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// deassert to keep radio awake when sleep mode selected&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;(Some early mistakes showed that -- contrary to what might be expected -- the sleep pin defaults to high (send radio to sleep) rather than low. So this step is important.)&lt;/p&gt;
&lt;p&gt;The next issue concerns the rather intricate behaviour of the XBee's other pins when sleeping. When the radio enters sleep mode, it asserts its I/O 7 line (pin 12) so that external devices know that it's asleep. This could be used to make sure that external peripherals wake up only when the radio is active, but for some reason the XBee shield's designers have connected this pin to the Arduino's reset line, which means that sleeping the radio will reset (and in fact freeze) the Arduino. &lt;a href="http://rubenlaguna.com/wp/2009/03/05/setting-xbee-to-sleep-causes-arduino-reset/" target="_blank"&gt;Some posts suggest&lt;/a&gt; that solving this requires cutting lines on the shield, which might have been true for earlier shields but now isn't: we simply need to disable the output of this pin, using another AT command:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;atCommand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"D7"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This disables the XBee's D7 line (not to be confused with the Arduino's D7 line, which we've attached to the XBee's sleep pin), which is enough to stop the Arduino freezing. on sleep. (Yes, this &lt;em&gt;did&lt;/em&gt; take quite a while to work out, since you ask...)&lt;/p&gt;
&lt;p&gt;We can now put all this together to place the XBee into SM 1  and let the Arduino sleep it at will:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="cp"&gt;#define LED 13&lt;/span&gt;
&lt;span class="cp"&gt;#define XBEE_SLEEP 7                &lt;/span&gt;&lt;span class="c1"&gt;// XBee sleep pin on D7&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;pinMode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LED&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUTPUT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// LED signal&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;pinMode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;XBEE_SLEEP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUTPUT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// sleep control&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;Serial&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9600&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;radio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setSerial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Serial&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;digitalWrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;XBEE_SLEEP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LOW&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// deassert to keep radio awake when sleep mode selected&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;atCommand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"D7"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;atCommand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"SM"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// AT commands failed, flash frantically&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that we've used local AT commands to set the radio's mode. It's
also possible to do this &lt;a href="https://simondobson.org/2013/07/xctu/"&gt;statically using
X-CTU&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Results&lt;/h3&gt;

&lt;p&gt;&lt;img alt="XBee with sleep control" src="https://simondobson.org/images/citizen-sensing/xbee-sleep.jpg"&gt;&lt;/p&gt;
&lt;p&gt;The results of all this hacking are that the Arduino can put the XBee into sleep mode whenever it wants to simply by asserting D7. The voltages on pins are maintained even when the Arduino itself sleeps, so it can put the radio to sleep and then sleep itself, wake up and wake up the radio.&lt;/p&gt;
&lt;p&gt;Measuring current shows that the sleeping Arduino and XBee draw abour 35mA, the same as an Arduino alone. This makes sense, as the XBee datasheet suggests that when sleeping it draws current in the microamp range -- far too small for a normal ammeter to measure, and dwarfed by the quiescent current of the Arduino board (which still needs some work).&lt;/p&gt;
&lt;p&gt;Waking the radio happens quickly when the sleep pin is deasserted, but it seems to take some time to re-connect to the mesh co-ordinator: around 7s, in fact, which is a little strange and needs some more exploration.&lt;/p&gt;</description><category>arduino</category><category>at command</category><category>making</category><category>power management</category><category>project:ditch</category><category>xbee</category><guid>https://simondobson.org/2013/08/02/xbee-sleeping/</guid><pubDate>Fri, 02 Aug 2013 14:41:30 GMT</pubDate></item><item><title>Issuing AT commands</title><link>https://simondobson.org/2013/08/02/at-commands-2/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;p&gt;Controlling the XBee requires issuing AT commands. The XBee library has the low-level machinery to do this.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;AT commands are the basis for controlling almost all modems, and the XBee is no different. In API mode, AT commands are issued in a similar manner to sending data. The Arduino XBee library has the low-level code needed, which can be wrapped into a slightly easier-to-use form.&lt;/p&gt;
&lt;p&gt;The basic approach is to send an AT command request packet and then
read a returned packet acknowledging the command. For the moment we'll
stick to "setting" commands, where the AT command takes an integer
parameter: the other are needed less frequently. We construct the
request packet, send it, read the response, and check that all went
well. This isolates the rest of the program from the message exchange,
but also hides the exact nature of any error.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;XBee.h&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;XBee&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;radio&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;atCommand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// send local AT command&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;AtCommandRequest&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AtCommandRequest&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;amp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;radio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// receive response frame&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;AtCommandResponse&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AtCommandResponse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;radio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readPacket&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;500&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;                               &lt;/span&gt;&lt;span class="c1"&gt;// read packet from radio&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;radio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getResponse&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getApiId&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AT_RESPONSE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// right type?&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;radio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getResponse&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getAtCommandResponse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isOk&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;                                     &lt;/span&gt;&lt;span class="c1"&gt;// not an error?&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// if we get here, return a failure&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This function can be used to issue the different control codes for the radio. Some parameters can be &lt;a href="https://simondobson.org/2013/07/02/xctu/"&gt;set using X-CTU &lt;/a&gt;when the radio firmware is installed, but commands are sometimes needed at run-time too.&lt;/p&gt;</description><category>arduino</category><category>at command</category><category>making</category><category>project:ditch</category><category>xbee</category><guid>https://simondobson.org/2013/08/02/at-commands-2/</guid><pubDate>Fri, 02 Aug 2013 11:03:54 GMT</pubDate></item><item><title>Basic power measurements</title><link>https://simondobson.org/2013/07/31/power/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;p&gt;Some initial measurements of power consumption.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;How much power does Arduino sleep mode save? The simplest way to work this out is to power an Arduino from a battery pack and measure the current being drawn in the different modes. A simple program to demonstrate the different modes is:
&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;Normal &lt;code&gt;delay()&lt;/code&gt; loop&lt;/li&gt;
    &lt;li&gt;Deep sleep for a period (deep sleep)&lt;/li&gt;
    &lt;li&gt;Flash the LED (awake)&lt;/li&gt;
    &lt;li&gt;Flash the LED differently while sending out radio messages (awake and transmitting)&lt;/li&gt;
&lt;/ul&gt;
We perform these tasks repeatedly, keeping them going for 10s each to let the power draw stabilise.
&lt;p&gt;The results are as follows:&lt;/p&gt;
&lt;table style="border: 1"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Activity&lt;/td&gt;
&lt;td&gt;Power mode&lt;/td&gt;
&lt;td&gt;Current&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Nothing&lt;/td&gt;
&lt;td&gt;&lt;code&gt;delay()&lt;/code&gt; loop&lt;/td&gt;
&lt;td&gt;43mA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Nothing&lt;/td&gt;
&lt;td&gt;Deep sleep&lt;/td&gt;
&lt;td&gt;33mA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Steady LED&lt;/td&gt;
&lt;td&gt;Deep sleep&lt;/td&gt;
&lt;td&gt;34mA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Flashing LED&lt;/td&gt;
&lt;td&gt;Awake&lt;/td&gt;
&lt;td&gt;45mA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Xbee (quiet)&lt;/td&gt;
&lt;td&gt;Deep sleep&lt;/td&gt;
&lt;td&gt;72mA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Xbee (quiet)&lt;/td&gt;
&lt;td&gt;Awake&lt;/td&gt;
&lt;td&gt;85mA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Xbee (transmitting)&lt;/td&gt;
&lt;td&gt;Awake&lt;/td&gt;
&lt;td&gt;87mA&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The good news is that SleepySketch makes it very easy to access the deep sleep mode, and to stay in it by default. This is good, as the normal approach of using &lt;code&gt;delay()&lt;/code&gt; is quite power-hungry. The bad news is that the "at rest" power consumption of an Arduino even in deep sleep  -- the quiescent current being drawn by the voltage regulator and other components on the board, regardless of what the microcontroller is doing -- is about 35mA, with an XBee drawing an additional 40mA.There is very little difference in power whether the radio is transmitting or not (although the current being drawn looked more variable when transmitting, suggesting that there's some variation happening faster than the ammeter's sample time).&lt;/p&gt;
&lt;p&gt;The radio isn't put to sleep when the Arduino is asleep, which is clearly something that needs to happen: it draws power even when the Arduino is incapable of using it. Something to explore. Potentially more serious is the power being drawn when the Arduino is asleep. A battery pack with 4 x 1500mAH batteries will be drained in about 7 days (6000mAH / 35mA) even with the system asleep all the time.&lt;/p&gt;
&lt;p&gt;[UPDATE 1Aug2013: made the table layout a bit clearer.]&lt;/p&gt;</description><category>arduino</category><category>making</category><category>power management</category><category>project:ditch</category><category>xbee</category><guid>https://simondobson.org/2013/07/31/power/</guid><pubDate>Wed, 31 Jul 2013 17:12:55 GMT</pubDate></item><item><title>Radio survey</title><link>https://simondobson.org/2013/07/26/radio-survey/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;p&gt;A simple radio survey establishes the ranges that the radios can manage.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;The 2mW XBee radios we've got have a nominal range of 100m -- but that's in free air, with no obstructions like bushes, ditches, and houses, and not when enclosed in a plastic box to protect them from the elements. There's a reasonable chance that these obstacles will reduce the real range significantly.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Arduino, radio, batteries, and their enclosure in the field (literally)" src="https://simondobson.org/images/citizen-sensing/sensor-enclosure.jpg"&gt;&lt;/p&gt;
&lt;p&gt;A radio survey is fairly simple to accomplish. We load software that talks to a server on the base station -- something as simple as possible, like sending a single packet with a count every ten seconds -- and keep careful track of the return values coming back from the radio library. We then use the only output device we have -- an LED -- to indicate the success or failure of each operation, preferably with an indication of &lt;em&gt;why&lt;/em&gt; it failed if it did. (Three flashes for unsuccessful transmission, five for no response received, and so forth.) We then walk away from the base station, watching the behaviour of the radio. When it starts to get errors, we've reached the edge of the effective range.&lt;/p&gt;
&lt;p&gt;With two sensor motes, we can also check wireless mesh networking. If we place the first mote in range of the base station, we should then be able to walk further and have the second mote connect &lt;em&gt;via&lt;/em&gt; the first, automatically. That's the theory, anyway...&lt;/p&gt;
&lt;p&gt;(One extra thing to improve robustness: if the radios lose connection or get power-cycled, they can end up on a different radio channel to the co-ordinator. To prevent this, the radio needs to have an ATJV1 command issued to it. The easiest way to do this is at set-up, &lt;a href="https://simondobson.org/2013/07/02/xctu/" target="_blank"&gt;through the advanced settings in X-CTU&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;The results are fairly unsurprising. In an enclosure, in the field, with a base station inside a house (and so behind double glazing and suchlike) the effective range of the XBees is about 30--40m -- somewhat less than half the nominal range, and not really sufficient to reach the chosen science site: another 10--20m would be fine. On the other hand, the XBees mesh together seamlessly: taking a node out of range and placing another between it and the base station connects the network with no effort.&lt;/p&gt;
&lt;p&gt;This is somewhat disappointing, but that's what this project is all about: the practicalities of sensor networking with cheap hardware.&lt;/p&gt;
&lt;p&gt;There are several options to improve matters. A higher-powered radio would help: the 50mW XBee has a nominal range of 1km and so would be easily sufficient (and could probably be run at reduced transmission power). A router node halfway between base station and sensors could extend the network, and the cost of an additional non-sensing component. Better antennas on the 2mW radios might help too, especially if they could be placed outside the enclosure.&lt;/p&gt;
&lt;p&gt;It's also worth noting that the radio segment is horrendously hard to debug with only a single LED for signalling. Adding more LEDs might help, but it's still a very poor debugging interface, even compared to printing status messages to the USB port.&lt;/p&gt;</description><category>making</category><category>network</category><category>project:ditch</category><category>wireless</category><category>xbee</category><guid>https://simondobson.org/2013/07/26/radio-survey/</guid><pubDate>Fri, 26 Jul 2013 11:11:52 GMT</pubDate></item><item><title>API communications now working</title><link>https://simondobson.org/2013/07/06/api-communications/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;p&gt;A small sensor network now working, with two edge devices talking to a base station.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;&lt;img alt="Network" src="https://simondobson.org/images/citizen-sensing/network.jpg"&gt;&lt;/p&gt;
&lt;p&gt;This step of the project accomplishes two things: is gets API networking mode working for the XBee radios, and makes sure the the interaction between software on the Arduinos and software running on the base station work too.&lt;/p&gt;
&lt;p&gt;The data stream is simple enough: each Arduino counts up from 0 to 255 every 5s, passing the result up to the co-ordinator radio. A Processing program on the laptop collects the numbers and prints them. Naturally they become somewhat intertwined as their clocks aren't quite synchronised.&lt;/p&gt;
&lt;p&gt;Actually this is enough to perform a simple radio survey to check transmission distance: we can move the radios away from the base station until they lose contact (nominally 100m for these 2mW radios, in reality probably substantially less), then move back into range, and then move one of the radios again to check that it meshes with the intermediate node in reaching back to the base station. This will also check that battery power works.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Meshing" src="https://simondobson.org/images/citizen-sensing/processing-xbee-api.png"&gt;&lt;/p&gt;
&lt;p&gt;The software is quite straightforward, and the &lt;a href="https://simondobson.org/2013/07/03/xbee-arduino/"&gt;xbee-arduino library&lt;/a&gt; handles all the low-level communications -- although it's very low-level, fine for the experienced programmer but probably all but mystifying to anyone not used to this kind of software. The corresponding Java xbee-api library is slightly more friendly, but &lt;em&gt;only&lt;/em&gt; slightly: they probably both need wrapping into a framework that hides the radio nastiness.&lt;/p&gt;
&lt;p&gt;I think the biggest hurdle for this sort of system is the data format -- or, more precisely, the need (or desire, at least) to to use C at one end and Processing/Java at the other, which means that the data on the wire is being described twice. A framework approach could use (for example) &lt;a href="http://www.json.org/" target="_blank"&gt;JSON&lt;/a&gt;, although there'd still be a need to make sure it was compactly encoded and transmitted.&lt;/p&gt;</description><category>arduino</category><category>making</category><category>processing</category><category>project:ditch</category><category>wireless</category><category>xbee</category><guid>https://simondobson.org/2013/07/06/api-communications/</guid><pubDate>Sat, 06 Jul 2013 11:12:05 GMT</pubDate></item><item><title>The xbee-arduino library</title><link>https://simondobson.org/2013/07/03/xbee-arduino/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;p&gt;A library for using XBee radios with Arduinos.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;The XBee radio operates in &lt;a href="https://simondobson.org/2013/07/01/xbee/" target="_blank"&gt;two modes&lt;/a&gt;: transparent or text-based, and API or binary-based. The latter (API mode) is generally considered more suitable for computer-to-computer interactions, as it's faster and simpler for computers to manipulate. However, using an XBee in this mode requires additional software.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://code.google.com/p/xbee-arduino/" target="_blank"&gt;xbee-arduino library&lt;/a&gt; provides Arduino functions to access the API mode functionality of the various XBee radio modules. The library is quite low-level, but does provide access to all the necessary functions like issuing AT commands to control the modem and sensing and receiving packets of data to other radios in the mesh network.&lt;/p&gt;
&lt;p&gt;To use the library you download the latest version from the web page and unpack it into the &lt;tt&gt;libraries/&lt;/tt&gt; directory of your Arduino IDE. You also need to make sure that the radios you use have the &lt;a href="https://simondobson.org/2013/07/02/xctu/" target="_blank"&gt;API function set installed using X-CTU&lt;/a&gt;, as the library only makes sense for radios in API mode. You also have to set the "AP" parameter to 2 when writing the firmware.&lt;/p&gt;</description><category>arduino</category><category>making</category><category>project:ditch</category><category>software</category><category>xbee</category><guid>https://simondobson.org/2013/07/03/xbee-arduino/</guid><pubDate>Wed, 03 Jul 2013 07:30:22 GMT</pubDate></item><item><title>XBee firmware management with X-CTU</title><link>https://simondobson.org/2013/07/02/xctu/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;p&gt;Managing Digi's XBee radio modules requires using their X-CTU package to upload the correct firmware. In this post we explain how.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;This post is slightly depressing: not because it's on an unhappy topic, but because the effort and software needed to manage XBee radios is so complex to set up. In many ways this is just a function of the good design of the XBee: it's so minimal in terms of footprint and power consumption at run-time that it offloads a lot of work to external tools (and the user) at system build-time. But it's still a lot of work to get such a small piece of kit running.&lt;/p&gt;
&lt;p&gt;X-CTU is intended to upload firmware to XBee radio modules. This is needed to change the firmware between router and co-ordinator of the Zigbee &lt;a href="https://simondobson.org/2013/07/02/mesh-network/" target="_blank"&gt;mesh network&lt;/a&gt;, and between the different protocol variants that the XBee radios can support.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Xbee on USB" src="https://simondobson.org/images/citizen-sensing/2013-06-29-13.35.45.jpg"&gt;&lt;/p&gt;
&lt;p&gt;One limitation of X-CTU is that it only works on Windows: if you're running Linux, X-CTU will run under &lt;a href="http://www.winehq.org/" target="_blank"&gt;Wine&lt;/a&gt;. You can download the latest X-CTU from &lt;a href="http://www.digi.com/support/kbase/kbaseresultdetl?id=2125" target="_blank"&gt;Digi's X-CTU page&lt;/a&gt;; alternatively, there's a version installed on the &lt;a href="https://simondobson.org/download/virtual-machine/" target="_blank"&gt;Citizen Sensing VM&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To use X-CTU you need to connect your XBee module to your computer. The easiest way to do this is using an XBee USB breakout board, which provides an XBee socket and a USB socket. Insert the radio into the board, plug in a USB cable, and plug the other end into a USB socket. The light on the breakout board will then come on (see photograph above).&lt;/p&gt;
&lt;p&gt;&lt;img alt="X-CTU in operation" src="https://simondobson.org/images/citizen-sensing/xctu-connect.png"&gt;&lt;/p&gt;
&lt;p&gt;You next need to start up X-CTU and tell it where the XBee is. It hangs off a Windows COM port, and X-CTU will typically find it automatically. You should then be able to press the "Test/Query" button, and X-CTU will interrogate the XBee and display a small window showing some information about it, as shown in the screenshot on the right: the details don't matter, but this shows that the XBee is talking to the computer properly.&lt;/p&gt;
&lt;p&gt;&lt;img alt="X-CTU router firmware" src="https://simondobson.org/images/citizen-sensing/xctu-firmware-router.png"&gt;&lt;/p&gt;
&lt;p&gt;Assuming everything is now working correctly, the next step is to decide what firmware to download to the radio. Click on the "Modem configuration" tab, and then click the "Read" button: this reads the firmware that's on the XBee at the moment, and puts the details into the window. Typically this results in a display like that shown on the left. The important things to notice are the two drop-down boxes labelled "Function Set" and "Version". The function set is the description of the firmware, in which case indicating that the XBee is running Zigbee router firmware that responds to AT commands (more on this below).&lt;/p&gt;
&lt;p&gt;&lt;img alt="X-CTU co-ordinator firmware" src="https://simondobson.org/images/citizen-sensing/xctu-firmware-coordinator.png"&gt;&lt;/p&gt;
&lt;p&gt;To download a new firmware, we then select the function set and version we want to use. Suppose we want to make this XBee into the mesh co-ordinator. We change the function set to "Zigbee Coordinator AT" (keeping with Zigbee and the AT command set) in  "Function set" the drop-down, then select the most recent version of this function set from the "Version" drop-down. (Versions are identified by hex numbers: the most recent in the screenshot right is "20A7", that being the highest hex number. Unfortunately X-CTU orders the numbers alphabetically, not in hex-numeric order.) Pressing "Write" will update the radio's firmware, and the radio is then ready for use as a co-ordinator.&lt;/p&gt;
&lt;p&gt;If you look through the list of function sets, there will be quite a few options, including protocols other than Zigbee. These probably aren't worth too much exploration, but you'll also notice that there are Zigbee AT and API function sets corresponding to the &lt;a href="https://simondobson.org/2013/07/01/xbee/" target="_blank"&gt;two modes (transparent and API)&lt;/a&gt; that the XBee can support. Be sure to select the correct one for your application.&lt;/p&gt;
&lt;p&gt;That's it: the radio is now ready for use.
&lt;/p&gt;&lt;h3&gt;Advanced use: setting optional parameters&lt;/h3&gt;
There's one more thing that X-CTU can be used for: it can set parameters to the firmware function set, and this is sometimes important when using the radios.
&lt;p&gt;&lt;img alt="X-CTU parameter setting" src="https://simondobson.org/images/citizen-sensing/xctu-parameter-setting.png"&gt;&lt;/p&gt;
&lt;p&gt;When you've read the firmware from a radio, the main part of the X-CTU window contains a hierarchy of folders and cryptic values, for example "(4) PL - Power level". These are parameters that can be changed to modify the detailed behaviour of the radio. Some can also be set using AT commands. The example we used sets the radio's power level to 4. If you click on this, it will show a drop-down box giving other options. You might, for some applications, choose to reduce the radio power to 1 ("low") to save batteries. If you choose this and then write the firmware to the radio, the module will use this power setting.&lt;/p&gt;
&lt;p&gt;In the example shown on the left, we're changing the AP parameter ("API enable") to 2, which is needed for the &lt;a href="https://simondobson.org/2013/07/03/xbee-arduino" target="_blank"&gt;xbee-arduino library&lt;/a&gt; to work properly. If we now write the firmware (with the Zigbee co-ordinator API function set selected as shown), the radio will be ready for use.&lt;/p&gt;</description><category>arduino</category><category>firmware</category><category>making</category><category>project:ditch</category><category>software</category><category>wireless</category><category>x-ctu</category><category>xbee</category><guid>https://simondobson.org/2013/07/02/xctu/</guid><pubDate>Tue, 02 Jul 2013 08:00:34 GMT</pubDate></item><item><title>XBee radios</title><link>https://simondobson.org/2013/07/01/xbee/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;p&gt;The XBee is a series of small radio modules that implement the Zigbee protocol and work well with Arduinos.&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;&lt;img alt="Xbees and an Arduino" src="https://simondobson.org/images/citizen-sensing/2013-07-01-18.12.32.jpg"&gt;&lt;/p&gt;
&lt;p&gt;XBees are made by &lt;a href="http://www.digi.com" target="_blank"&gt;Digi&lt;/a&gt;. The range includes a number of &lt;a href="http://digi.com/products/wireless-wired-embedded-solutions/zigbee-rf-modules/zigbee-mesh-module/" target="_blank"&gt;options&lt;/a&gt;: you almost certainly want some variant of the Zigbee range. The Series 2 (S2) modules seem to offer good performance, low power, and a useful range of functions. There are several different antenna types and two different radio powers (2mW and 50mW): larger power provides more range (1km nominal as opposed to 100m) at the cost of twenty-five times the power consumption: best avoided unless really needed. A collection of XBee modules co-operate to form a mesh network that's quite robust against partial failure, which makes them great for use in the field.&lt;/p&gt;
&lt;p&gt;To get XBees working with an Arduino you need several pieces of hardware and software:
&lt;/p&gt;&lt;ul&gt;
    &lt;li&gt;Two or more radios (obvious, but surprisingly easy to only buy one...)&lt;/li&gt;
    &lt;li&gt;One or more Arduinos&lt;/li&gt;
    &lt;li&gt;One Arduino XBee shield for each radio-equipped Arduino&lt;/li&gt;
    &lt;li&gt;One XBee USB breakout board&lt;/li&gt;
    &lt;li&gt;The X-CTU firmware management software&lt;/li&gt;
&lt;/ul&gt;
There are also variations of Arduinos that take XBee modules directly, as well as other sensor mote systems that can work with them: they're not completely Arduino-specific.
&lt;p&gt;When buying radios, buy them all the same series: the different series aren't guaranteed to interwork (although they often do). In the photograph above there are two &lt;em&gt;different&lt;/em&gt; XBees: one with a patch antenna and one with a whip antenna.&lt;/p&gt;
&lt;p&gt;The Xbee shield fits on top of the Arduino. They're sold without a radio module.&lt;/p&gt;
&lt;p&gt;The breakout board is used to connect an XBee to the USB port of a computer, allowing your network to be accessed from the desktop. This is useful for debugging and for data logging, unless you're also going to build a dedicated data logger.&lt;/p&gt;
&lt;p&gt;The X-CTU software manages the firmware on the radio module. Because the radios are small and low-power, they don't have room for a sophisticated software stack, and so aren't programmed in the normal way. Instead you download a firmware providing exactly the functions you need. Each network is given an identifier (a &lt;em&gt;personal area network id&lt;/em&gt; or &lt;em&gt;PAN&lt;/em&gt;) so that several networks can co-exist in the same area without interfering with each other. Each network has exactly one co-ordinator, with the others being routers, Co-ordinator and router use different firmware: you nominate one of your radios as co-ordinator (which will typically live on the base station, or on the data logger) and use X-CTU to load co-ordinator firmware to it; the other radios get router firmware and are placed onto the sensor motes.&lt;/p&gt;
&lt;p&gt;XBees actually have two communication modes you can choose between, by choosing different firmware. The simplest is the AT firmware. These provide simple, text-based communications between radios: what one Arduino writes as text comes out on the other. In this mode the XBee also responds to Hayes AT commands, a standard way of controlling a modem (which is what an XBee technically is): we'll explore these commands in another post. This function set -- router and co-ordinator -- sets up what might be called a &lt;em&gt;transparent&lt;/em&gt; network, in the sense that it behaves just like a serial pipe. This makes it easy to get things up and running.Text-based interaction isn't great for computer-to-computer communications, however, not least because of the effort (and memory) needed to understand text-based protocols. For this reason, the XBee also supports API function sets that provide binary communications. These are better for computers, and faster when running, but require more programming and more intellectual effort to understand. We'll deal with API communications in another post too.&lt;/p&gt;
&lt;p&gt;We'll deal with the details of using X-CTU &lt;a href="https://simondobson.org/2013/07/02/xctu/"&gt;in another post&lt;/a&gt;, as well as explaining how to set up a simple network.&lt;/p&gt;</description><category>hardware</category><category>making</category><category>project:ditch</category><category>wireless</category><category>xbee</category><guid>https://simondobson.org/2013/07/01/xbee/</guid><pubDate>Mon, 01 Jul 2013 17:23:15 GMT</pubDate></item></channel></rss>