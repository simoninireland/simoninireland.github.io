<!DOCTYPE html>
<html prefix="
	og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Posts about citizen-sensing (old posts, page 3) | Simon Dobson</title>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
<link rel="stylesheet" href="assets/css/normalize.css">
<link rel="stylesheet" href="assets/css/main.css">
<link href="../../assets/css/baguetteBox.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/fonts.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../rss.xml">
<link rel="canonical" href="https://simondobson.org/categories/cat_citizen-sensing/index-3.html">
<link rel="prev" href="." type="text/html">
<link rel="next" href="index-2.html" type="text/html">
<!--[if lt IE 9]><script src="../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-10943215-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-10943215-1');
</script><link rel="alternate" type="application/rss+xml" title="RSS for category citizen-sensing" hreflang="en" href="../cat_citizen-sensing.xml">
</head>
<body>
  <a href="#page-content" class="sr-only sr-only-focusable">
    Skip to main content
  </a>

  

  <section id="header"><a href="../../">
      <div class="logo">
	  <div id="nologoimage">
	    Simon Dobson
	  </div>
      </div>
    </a>
  </section><section id="socialNav"><!-- Navigation Menu - on top on small screens, down the left on larger --><div class="navlinks">
<!--
      <a href="/">
	<div id="titleauth">
	    by Simon Dobson
	</div>
      </a>
-->

      <!-- Navigation links (hidden by default) -->
      <div id="navmenuitems">
	      <a href="../../index.html" title="Home">
	<span class="menuitemtext">Home</span>
	<span class="menuitemicon"><i class="fa fa-home"></i></span>
      </a>
      <a href="../../personal/" title="About me">
	<span class="menuitemtext">About me</span>
	<span class="menuitemicon"><i class="fa fa-user"></i></span>
      </a>
      <a href="../../research/" title="Research">
	<span class="menuitemtext">Research</span>
	<span class="menuitemicon"><i class="fa fa-lightbulb"></i></span>
      </a>
      <a href="../../development/projects/" title="Software">
	<span class="menuitemtext">Software</span>
	<span class="menuitemicon"><i class="fa fa-cogs"></i></span>
      </a>
      <a href="../../writing/" title="Writing">
	<span class="menuitemtext">Writing</span>
	<span class="menuitemicon"><i class="fa fa-feather"></i></span>
      </a>
      <a href="../../personal/contact/" title="Contact">
	<span class="menuitemtext">Contact</span>
	<span class="menuitemicon"><i class="fa fa-info-circle"></i></span>
      </a>
      <a href="../../rss.xml" title="RSS">
	<span class="menuitemtext">RSS</span>
	<span class="menuitemicon"><i class="fa fa-rss"></i></span>
      </a>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
     <img alt="Creative Commons License CC-BY-NC-SA-4.0" style="border-width:0" src="../../images/cc-by-nc-sa-4.0.png"></a>
  
  

      </div>

      <!-- "Hamburger menu" / "Bar icon" to toggle the navigation links -->
      <a href="javascript:void(0);" id="hamburger" class="icon" onclick="toggleNav()">
	<i class="fa fa-bars">
	</i>
      </a>
    </div>
  </section><section class="page-content"><div class="content" rel="main">
    <header><h1>Posts about citizen-sensing (old posts, page 3)</h1>
        <div class="metadata">
                            <p class="feedlink">
                                    <a href="../cat_citizen-sensing.xml" hreflang="en" type="application/rss+xml">RSS feed</a>

                </p>

            
        </div>
    </header><div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../../2013/07/26/improvements/" class="u-url">Some improvements to SleepySketch</a></h1>

        
        <div class="metadata">
            <p class="dateline"><a href="../../2013/07/26/improvements/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2013-07-26T16:20:38+01:00" title="2013-07-26 16:20">2013-07-26 16:20</time></a></p>

                <p class="commentline"><i class="fa fa-comment"></i>         <a href="../../2013/07/26/improvements/#disqus_thread" data-disqus-identifier="cache/posts/2013/07/26/improvements.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <p>It's funny how even early experiences change the way you think about a design. Two minor changes to SleepySketch have been suggested by early testing.</p>
<!--more-->

<p>The first issue is obvious: milliseconds are a really inconvenient way to think about timing, especially when you're planning on staying asleep for long periods. A single method in SleepySketch to convert from more programmer-friendly days/hours/minutes/seconds times makes a lot of difference.</p>
<p>The second issue concerns scheduling -- or rather regular
scheduling. Most sampling and communication tasks occur on predictable
schedules, say every five hours. In an <a href="../../blog/2013/06/01/actor-systems/" target="_blank">actor
framework</a>, that means the actor instance (or another one) has to
be re-scheduled after the first has run. We can do this within the
definition of the actor, for example using the <code>post()</code>
action:</p>
<div class="code"><pre class="code literal-block"><span class="n">class</span><span class="w"> </span><span class="n">PeriodicActor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">public</span><span class="w"> </span><span class="n">Actor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="nf">post</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="nf">behaviour</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="p">...</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="n">PeriodicActor</span><span class="o">::</span><span class="n">post</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">scheduleIn</span><span class="p">(</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">expandTime</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>(This also demonstrates the <code>expandTime()</code> function to re-schedule after 0 days and 5 hours, incidentally.) Simple, but bad design: we can't re-use <code>PeriodicActor</code> on a different schedule. If we add a variable to keep track of the repeating period, we'd be mixing up "real" behaviour with scheduling; more importantly, we'd have to do that for <em>every</em> actor that wants to run repeatedly.</p>
<p>A better way is to use an actor combinator that takes an actor and a period and creates an actor that runs first re-schedules the actor to run after the given period, and then runs the underlying actor. (We do it this way so that the period isn't affected by the time the actor actually takes to run.)</p>
<div class="code"><pre class="code literal-block"><span class="n">Actor</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">RepeatingActor</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">SomeActor</span><span class="p">(),</span><span class="w"> </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">expandTime</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">));</span><span class="w"></span>
<span class="n">Sleepy</span><span class="p">.</span><span class="n">scheduleIn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">expandTime</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w"></span>
</pre></div>

<p>The <code>RepeatingActor</code> runs the behaviour of
<code>SomeActor</code> every 5 hours, and we initially schedule it to
run in 5 hours. We can actually encapsulate all of this by adding a
method to <code>SleepySketch</code> itself:</p>
<div class="code"><pre class="code literal-block"><span class="n">Sleepy</span><span class="p">.</span><span class="n">scheduleEvery</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">SomeActor</span><span class="p">(),</span><span class="w"> </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">expandTime</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">));</span><span class="w"></span>
</pre></div>

<p>to perform the wrapping and initial scheduling automatically.</p>
<p>Simple sleepy sketches can now be created at set-up, by scheduling
repeating actors, and we can define the various actors and re-use them
in different scheduling situations without complicating their own
code.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../../2013/07/26/radio-survey/" class="u-url">Radio survey</a></h1>

        
        <div class="metadata">
            <p class="dateline"><a href="../../2013/07/26/radio-survey/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2013-07-26T12:11:52+01:00" title="2013-07-26 12:11">2013-07-26 12:11</time></a></p>

                <p class="commentline"><i class="fa fa-comment"></i>         <a href="../../2013/07/26/radio-survey/#disqus_thread" data-disqus-identifier="cache/posts/2013/07/26/radio-survey.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <p>A simple radio survey establishes the ranges that the radios can manage.</p>
<!--more-->

<p>The 2mW XBee radios we've got have a nominal range of 100m -- but that's in free air, with no obstructions like bushes, ditches, and houses, and not when enclosed in a plastic box to protect them from the elements. There's a reasonable chance that these obstacles will reduce the real range significantly.</p>
<p><img alt="Arduino, radio, batteries, and their enclosure in the field (literally)" src="../../images/citizen-sensing/sensor-enclosure.jpg"></p>
<p>A radio survey is fairly simple to accomplish. We load software that talks to a server on the base station -- something as simple as possible, like sending a single packet with a count every ten seconds -- and keep careful track of the return values coming back from the radio library. We then use the only output device we have -- an LED -- to indicate the success or failure of each operation, preferably with an indication of <em>why</em> it failed if it did. (Three flashes for unsuccessful transmission, five for no response received, and so forth.) We then walk away from the base station, watching the behaviour of the radio. When it starts to get errors, we've reached the edge of the effective range.</p>
<p>With two sensor motes, we can also check wireless mesh networking. If we place the first mote in range of the base station, we should then be able to walk further and have the second mote connect <em>via</em> the first, automatically. That's the theory, anyway...</p>
<p>(One extra thing to improve robustness: if the radios lose connection or get power-cycled, they can end up on a different radio channel to the co-ordinator. To prevent this, the radio needs to have an ATJV1 command issued to it. The easiest way to do this is at set-up, <a href="../../blog/2013/07/02/xctu/" target="_blank">through the advanced settings in X-CTU</a>.)</p>
<p>The results are fairly unsurprising. In an enclosure, in the field, with a base station inside a house (and so behind double glazing and suchlike) the effective range of the XBees is about 30--40m -- somewhat less than half the nominal range, and not really sufficient to reach the chosen science site: another 10--20m would be fine. On the other hand, the XBees mesh together seamlessly: taking a node out of range and placing another between it and the base station connects the network with no effort.</p>
<p>This is somewhat disappointing, but that's what this project is all about: the practicalities of sensor networking with cheap hardware.</p>
<p>There are several options to improve matters. A higher-powered radio would help: the 50mW XBee has a nominal range of 1km and so would be easily sufficient (and could probably be run at reduced transmission power). A router node halfway between base station and sensors could extend the network, and the cost of an additional non-sensing component. Better antennas on the 2mW radios might help too, especially if they could be placed outside the enclosure.</p>
<p>It's also worth noting that the radio segment is horrendously hard to debug with only a single LED for signalling. Adding more LEDs might help, but it's still a very poor debugging interface, even compared to printing status messages to the USB port.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../../2013/07/25/sleepy-sketches/" class="u-url">Sleepy sketches</a></h1>

        
        <div class="metadata">
            <p class="dateline"><a href="../../2013/07/25/sleepy-sketches/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2013-07-25T13:00:01+01:00" title="2013-07-25 13:00">2013-07-25 13:00</time></a></p>

                <p class="commentline"><i class="fa fa-comment"></i>         <a href="../../2013/07/25/sleepy-sketches/#disqus_thread" data-disqus-identifier="cache/posts/2013/07/25/sleepy-sketches.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <p></p>
<p>Keeping the microcontroller asleep as much as possible is a key goal for a sensor system, so it makes sense to organise the entire software process around that.</p>
<!--more-->

<p>The standard Arduino software model is, well, standard: programs ("sketches") are structured in terms of a <code>setup()</code> function that runs once when the system restarts and a <code>loop()</code> function that is run repeatedly. This suggests that the system spends its time running, which possibly isn't all that desirable: a sensor system typically tries to <a href="../../blog/2013/07/23/arduino-watchdog">stay in a low-power mode</a> as much as possible. The easiest way to do this is to provide a programming framework that handles the sleeping, and where the active bits of the program are scheduled automatically.</p>
<p>There are at least two ways to do this. The simplest is a library that lets <code>loop()</code> sleep, either directly or indirectly. This is good for simple programs and not so good for more complicated ones, as it means that <code>loop()</code> encapsulates all the program's logic in a single block. A more modern and compositional approach is to let program fragments request when they want to run somehow, and have a scheduler handle the sleeping, waking up, and execution of those fragments. That lets (for example) one fragment decide at run-time to schedule another</p>
<p>If we adopt this approach,we have to worry about the fact that one fragment might lock-out another. A desktop system might use threads; this is more problematic for a microcontroller, but an alternative is to force all fragments to only execute for a finite amount of time, so that the scheduler always gets control back. This might lead to a fragment not running when it asked (if other fragments were still running), but if we assume that the system spends most of its time asleep anyway, there will be plenty of catch-up time. Doing this results in an <a href="../../blog/2013/06/01/actor-systems/">actor system</a> where the fragments are actors that are scheduled from an actor queue.</p>
<p>Turning this into code, we get the <code>SleepySketch</code> library: a library for building Arduino sketches that spend most of their time sleeping.</p>
<p><img alt="SleepySketch design" src="../../images/citizen-sensing/sleepysketch.png"></p>
<p>There are a few wrinkles that need to be taken care of for running on a resource-constrained system. Firstly, the number of actors available is fixed at start-up (defaulting to 10), so that we can balance RAM usage.(With only 2k to play with, we need to be careful). Secondly, we use a class to manage the sleeping functionality in different ways: a <code>BusySleeper</code> that uses the normal <code>delay()</code> function (a busy loop) with no power-saving functions, a <code>HeavySleeper</code> that uses the watchdog timer to shut the system down as far as possible, and possibly some other intermediate strategies. Actors are provided by sub-classing the <code>Actor</code> class and providing a behaviour. We also allow pre- and post-behaviour actions to define families of actors, for example sensor observers. We separate the code for an actor from its scheduling.</p>
<p>The standard library uses singleton classes quite a lot, so for example the <code>Serial</code> object represents the USB connection from an Arduino to its host computer and is the target for all methods. We use the same approach and define a singleton, <code>Sleepy</code></p>
<p>The program structure then loops something like this. If we assume
that we've defined an actor class <code>PingActor</code>, then we can
do the following:</p>
<div class="code"><pre class="code literal-block"><span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">HeavySleeper</span><span class="p">());</span><span class="w"></span>

<span class="w">   </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">scheduleIn</span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">PingActor</span><span class="p">(</span><span class="s">"Ping!"</span><span class="p">),</span><span class="w"> </span><span class="mi">10000</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">Sleepy</span><span class="p">.</span><span class="n">loop</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>The <code>setup()</code> code initialises the serial port and the sleepy sketch using a <code>HeavySleeper</code>, and then schedules an actor to run in 10000ms. The loop() code runs the actors while there are actors remaining to schedule. If the <code>PingActor</code> instance just prints its message, then there will be no further actors to execute and the program will end; alternatively the actor could schedule further actors to be run later, and the sketch will pick them up. The sketch will remain asleep for as long as possible (probably for over 9s between start-up and the first ping), allowing for some fairly significant power saving.</p>
<p>This is a first design, now just about working. It's still not as easy
as it could be, however, and needs some testing to make sure that the
power savings do actually materialise.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../../2013/07/23/arduino-watchdog/" class="u-url">Understanding Arduino sleep modes: the watchdog timer</a></h1>

        
        <div class="metadata">
            <p class="dateline"><a href="../../2013/07/23/arduino-watchdog/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2013-07-23T15:21:27+01:00" title="2013-07-23 15:21">2013-07-23 15:21</time></a></p>

                <p class="commentline"><i class="fa fa-comment"></i>         <a href="../../2013/07/23/arduino-watchdog/#disqus_thread" data-disqus-identifier="cache/posts/2013/07/23/arduino-watchdog.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <p></p>
<p>The Arduino has several sleep modes that can be used to reduce power consumption. The most useful for sensor networks is probably the one that uses the watchdog timer.</p>
<!--more-->

<p>[mathjax]</p>
<p>Powering-down the Arduino makes a lot of sense for a sensor network: it saves battery power allowing the system to survive for longer. Deciding <em>when</em> to power the system down is another story, but in this post we'll concentrate on documenting the mechanics of the process. The details are necessarily messy and low-level. (I've been greatly helped in writing this post by <a href="http://www.atmel.com/devices/atmega328p.aspx?tab=documents" target="_blank">the data sheet for the Atmel ATmega328P microcontroller</a> that's used in the Arduino Uno, as well as by <a href="http://donalmorrissey.blogspot.ie/2010/04/putting-arduino-diecimila-to-sleep-part.html" target="_blank">a series of blog posts by Donal Morrissey</a> that also deal with other sleep modes for the Atmel.)
</p>
<h3>Header files and general information</h3>
To use the watchdog timer, a sketch needs to include three header files:
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;avr/power.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;avr/wdt.h&gt;</span><span class="cp"></span>
</pre></div>

<p>These provide definitions for various functions and variables needed to control the watchdog timer and manage some of the other power functions.</p>
<h3>Power modes</h3>
<p>A power (or sleep) mode is a setting for the microcontroller that allows it to use less power in exchange of disabling some of its functions. Since a microcontroller is, to all intents and purposes, a small computer on a chip, it has a lot of sub-systems that may not be needed all the time. A power mode lets you shut these unneeded sub-systems down. The result saves power but reduces functionality.</p>
<p>Power modes are pretty coarse control mechanisms, and can shut down more than you intend. If your project is basically software-driven, with the Arduino making all the decisions, then a "deep" power-saving mode is ideal; on the other hand, if you rely on hardware-based signals at all, a "deep" sleep will probably ignore your hardware and the Arduino may never wake up.</p>
<p>The watchdog timer is used to manage the "power-down" mode, the deepest sleep mode with the biggest power savings.</p>
<h3>Watchdog timer</h3>
<p>The Arduino's watchdog timer is a countdown timer that's driven by its own oscillator on the microcontroller. It's designed to run even when all the other circuitry is powered down, meaning that the microcontroller is drawing as little power as possible without actually being turned off completely.</p>
<p>Why "watchdog" timer? The basic function of a watchdog timer is to "bite" after a certain period, where "biting" means raising an interrupt, re-setting the system, or both. A typical use of a watchdog is to make a system more robust to software failures. Since the watchdog is handled by the microcontroller's hardware, independent of any program being run, it will still bite even if the software gets stuck in an infinite loop (for example). Some designers set the watchdog ahead of complex operations, so that if the operation fails, the system will reset in a short amount of time and end up back in a known-good configuration. At the end of a successful operation, the program disables the watchdog (before it bites) and carries on. Of course this assumes that the operation completes before the watchdog bites, which means the programmer needs to have a good idea of how long it will take.</p>
<h3>Setting the time-out period</h3>
<p>It's as well to understand how watchdog timers on microcontrollers work. Typically they have a fairly coarse resolution, counting a fixed number of timer ticks before "biting" and performing some function. In the case of the Arduino, the watchdog timer is driven by the internal oscillator running at 128KHz and counts off some multiple of ticks before biting. This value -- the number of ticks counted -- is referred to as the "prescalar" for the timer.</p>
<p>The prescalar is controlled by the values of four bits in the watchdog timer's control register, <code>WDTCSR</code>. To set them up, you pick the value of prescalar you want and set the appropriate bits. If the bits contain a number ( i ), then the watchdog will bite after ( (2048 &lt;&lt; i) / 128000 ) seconds. So ( i = 0) means the watchdog bites after 16ms; ( i = 1 ) produces  delay of 32ms; and so on up to ( i = 9 ) (the largest value allowed) means the watchdog bites after about 8s.</p>
<p>The word "about" is important here: the oscillator's exact frequency depends on the supply voltage to the chip and some other factors, meaning that you should be conservative about relying on the delay time.</p>
<p>Writing the appropriate value of ( i ) into the control register
involves representing ( i ) as a four-digit binary number and then
writing these bits into four bits of the register -- and unfortunately
these bits aren't consecutive. if ( i = 7 ) for example, then this
is 0b0111 in binary, so we write 1 into bits <code>WDP0</code>,
<code>WDP1</code> and <code>WDP2</code>, and 0 into bit
<code>WDP3</code>, and 0 into all the other bits:</p>
<div class="code"><pre class="code literal-block"><span class="n">WDTCSR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDP0</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDP1</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDP2</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>The phrases of the form <code>(1 &lt;&lt; WDP0)</code> simply takes a binary digit 1 and shifts it left into bit position <code>WDP0</code>. The <code>|</code> symbols logically OR these bits together to generate the final bit mask that is assigned to the control register.</p>
<p>Actually there's a little bit more to it than this, as we can't change the watchdog's configuration arbitrarily. Instead we have to notify the chip that it's configuration is about to be changed, by setting two other bits in the control register and then performing the updates we want:</p>
<div class="code"><pre class="code literal-block"><span class="n">WDTCSR</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDCE</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDE</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>Setting <code>WDCE</code> enables changes in configuration to be made in the next few processor cycles, <em>i.e.</em> immediately. Setting <code>WDE</code> resets the timer.</p>
<p>Finally we enable the watchdog timer interrupts by setting bit
<code>WDIE</code>. When the watchdog timer bites, the microcontroller
executes an interrupt handler, re-starts the main program, and clears
<code>WDIE</code>. Any further interrupts, if the time is re-enabled,
will then cause a system reset.</p>
<div class="code"><pre class="code literal-block"><span class="n">WDTCSR</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDIE</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>So the complete code the setting up the watchdog timer to bite in 2s is:</p>
<div class="code"><pre class="code literal-block"><span class="n">set_sleep_mode</span><span class="p">(</span><span class="n">SLEEP_MODE_PWR_DOWN</span><span class="p">);</span><span class="w">              </span><span class="c1">// select the watchdog timer mode</span>
<span class="n">MCUSR</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDRF</span><span class="p">);</span><span class="w">                            </span><span class="c1">// reset status flag</span>
<span class="n">WDTCSR</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDCE</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDE</span><span class="p">);</span><span class="w">               </span><span class="c1">// enable configuration changes</span>
<span class="n">WDTCSR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDP0</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDP1</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDP2</span><span class="p">);</span><span class="w"> </span><span class="c1">// set the prescalar = 7</span>
<span class="n">WDTCSR</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">WDIE</span><span class="p">);</span><span class="w">                            </span><span class="c1">// enable interrupt mode</span>
<span class="n">sleep_enable</span><span class="p">();</span><span class="w">                                   </span><span class="c1">// enable the sleep mode ready for use</span>
<span class="n">sleep_mode</span><span class="p">();</span><span class="w">                                     </span><span class="c1">// trigger the sleep</span>

<span class="cm">/* ...time passes ... */</span><span class="w"></span>

<span class="n">sleep_disable</span><span class="p">();</span><span class="w">                                  </span><span class="c1">// prevent further sleeps&lt;/pre&gt;</span>
</pre></div>

<h3> Interrupt handler</h3>
<p>What happens when the watchdog bites? It causes an interrupt that has to be handled before the program can continue. The interrupt could be used for all sorts of things, but there's often no point in worrying about it: but it still has to be there, to prevent the microcontroller just resetting. The following code installs a dummy interrupt handler:</p>
<div class="code"><pre class="code literal-block"><span class="n">ISR</span><span class="p">(</span><span class="w"> </span><span class="n">WDT_vect</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="cm">/* dummy */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>The <code>WDT_vect</code> identifies the watchdog timer's interrupt vector.</p>
<p>While this might seem like a waste of time, it's important to have an interrupt handler as the default behaviour of the watchdog timer is to reset the microcontroller, which we want to avoid. It's also worth noting that, once enabled, the watchdog timer will keep biting, so the interrupt handler will be called repeatedly. (Put a print statement in the hander to see.) This doesn't cause any problems.</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="../../2013/07/09/temperature-sensors-working/" class="u-url">Temperature sensors working</a></h1>

        
        <div class="metadata">
            <p class="dateline"><a href="../../2013/07/09/temperature-sensors-working/" rel="bookmark"><i class="fa fa-clock"></i> <time class="published dt-published" datetime="2013-07-09T19:00:20+01:00" title="2013-07-09 19:00">2013-07-09 19:00</time></a></p>

                <p class="commentline"><i class="fa fa-comment"></i>         <a href="../../2013/07/09/temperature-sensors-working/#disqus_thread" data-disqus-identifier="cache/posts/2013/07/09/temperature-sensors-working.html">Comments</a>


        </p>
</div>
    </header><div class="p-summary entry-summary">
    <p></p>
<p>Temperature sensing using digital temperature sensors is easy to get working.</p>
<!--more-->

<p>The temperature sensing part of the project requires three sensors for ambient, high-up and low-down measurement. The <a href="../../blog/2013/07/08/ds18b20/">DS18B20 temperature sensor </a>seems well-suited for the job.</p>
<p><img alt="DS18B20" src="../../images/citizen-sensing/three-ds18b20.png"></p>
<p>Three DS18B20 temperature sensors sharing a OneWire bus, standard (rail) power mode</p>
<p>Hooking-up a OneWire bus for the three sensors lets them share a single microcontroller pin -- which isn't important for hardware reasons in this project, but also saves some microcontroller RAM, which might be. The circuit is very simple, with the three sensors sharing power and ground lines and with a common data line pulled-up to the power rail through a 4.7K resistor. The DQ line is attached to one of the Arduino's digital lines. The OneWire library is then used to instantiate a protocol handler for that line, and passed to the temperature control library to manage the interaction with the devices, including their conversion from raw to "real" temperature values.</p>
<p>The resulting code is almost comically simple:</p>
<div class="code"><pre class="code literal-block"><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;DallasTemperature.h&gt;</span><span class="cp"></span>

<span class="n">OneWire</span><span class="w"> </span><span class="nf">onewire</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span><span class="w">                  </span><span class="c1">// OneWire bus on pin 8</span>
<span class="n">DallasTemperature</span><span class="w"> </span><span class="nf">sensors</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onewire</span><span class="p">);</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">sensors</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">sensors</span><span class="p">.</span><span class="n">requestTemperatures</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sensors</span><span class="p">.</span><span class="n">getTempCByIndex</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Sensor "</span><span class="p">);</span><span class="w">   </span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">   </span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">" = "</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w">   </span><span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"C"</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">delay</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>That's it! The temperature library packages everything up nicely, including the conversion and the interaction with the OneWire protocol (which is quite fiddly).</p>
<p><img alt="Three DS18B30s on a prototyping shield" src="../../images/citizen-sensing/ds18b20-prototype.jpg"></p>
<p>One potential problem for the future is that access to the sensors is by index, not by any particular identifier, and it;s not clear whether the ordering is always the same: does the sensor closest to the microcontroller always appear as index 0, for example? If not, then we'll have to identify which sensor is which somehow to sample the temperature from the correct place, or run each one on a different OneWire bus instance.</p>
<p>There's also an interesting point about parasite power mode, which is where the DS18B20 draws its power from the data bus rather than from a dedicated power rail. This might make power management easier, since the sensor would be unpowered when not being used, such as when the Arduino is asleep. This suggests it's probably worth looking into parasite power a bit more.</p>
    </div>
    </article>
</div>
        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="." rel="next">Newer posts</a>
            </li>
            <li class="previous">
                <a href="index-2.html" rel="prev">Older posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="simoninireland";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
  </section><script src="../../assets/js/baguetteBox.min.js"></script><script src="../../assets/js/moment-with-locales.min.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(2, "YYYY-MM-DD HH:mm");
  </script><!-- end fancy dates --><script>
    baguetteBox.run('div#content', {
    ignoreClass: 'islink',
    captions: function(element) {
    return element.getElementsByTagName('img')[0].alt;
    }});
  </script><script src="../../assets/js/ToggleNav.js"></script>
</body>
</html>
