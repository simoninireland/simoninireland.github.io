<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson (Posts about project:lisp-bibliography)</title><link>https://simondobson.org/</link><description></description><atom:link href="https://simondobson.org/categories/projectlisp-bibliography.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Fri, 02 Feb 2024 14:12:08 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>LISPcraft</title><link>https://simondobson.org/2024/02/02/lispcraft/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org29167e9" class="outline-2"&gt;
&lt;h2 id="org29167e9"&gt;LISPcraft&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org29167e9"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/fc/8f0d76-df2a-43eb-b5ca-a79b21c2351a/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Robert Wilensky.  &lt;i&gt;LISPcraft&lt;/i&gt;. W.W. Norton. ISBN
0-393-95442-0. 1984.
&lt;/p&gt;

&lt;p&gt;
Hard to know whether to include this as an introduction or
collection of applications, since it runs all the way from basic
uses to pattern-matching and associative retrieval, by way of the
non-list data types in Lisp, and includes discussion of the symbol
table and other internals that definitely fall into the "advanced"
category.
&lt;/p&gt;

&lt;p&gt;
However, this was my second introduction to Lisp (after &lt;a href="/2024/01/27/structure-and-interpretation-of-computer-programs/"&gt;SICP&lt;/a&gt;), so
it has a fond place in my memory. The fact that it deals with
language internals isn't a bad thing, because it deals with the
basics so well. It's very much a traditional programming
introduction focusing on the "needed" parts of the language. It
pre-dates the Common Lisp standard and doesn't touch on CLOS,
which perhaps make it a less appropriate choice for newcomers
these days than &lt;a href="/2024/01/27/practical-common-lisp/"&gt;Practical Common Lisp&lt;/a&gt;.
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
There is also a second edition. I haven't read it, but it seems that
it addresses at least the concern about being non-standard:
&lt;/p&gt;

&lt;p&gt;
Robert Wilensky.  &lt;i&gt;Common LISPcraft&lt;/i&gt;. W.W. Norton. ISBN
978-039395544-6. 1986.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/02/02/lispcraft/</guid><pubDate>Fri, 02 Feb 2024 12:23:08 GMT</pubDate></item><item><title>The CONNIVER reference manual</title><link>https://simondobson.org/2024/02/02/the-conniver-reference-manual/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org0fda5a5" class="outline-2"&gt;
&lt;h2 id="org0fda5a5"&gt;The CONNIVER reference manual&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0fda5a5"&gt;
&lt;p&gt;
Drew McDermott and Gerald Jay Sussman.  &lt;i&gt;&lt;a href="https://dspace.mit.edu/handle/1721.1/6204"&gt;The Conniver Reference
Manual&lt;/a&gt;&lt;/i&gt;. Technical report AIM-259a. MIT AI Laboratory. 1974.
&lt;/p&gt;

&lt;p&gt;
I think Conniver may have a claim to being the most influential
language you've never heard of. It's a mostly forgotten Lisp
variant that was a laboratory for some radically different
language design ideas, and a precursor to a surprising set of
features – many of which are still uncommon in the mainstream.
&lt;/p&gt;

&lt;p&gt;
Conniver was intended to manage knowledge databases. This does
make the report slightly hard to read in places, as there are a
lot of explicit references to planning techniques wrapped-up with
language mechanisms that don't really depend on them.
&lt;/p&gt;

&lt;p&gt;
Conniver is (to the best of my knowledge) the first appearance of
&lt;b&gt;generators&lt;/b&gt; in a programming language. It is therefore a distant
precursor of all the lazy functional languages and libraries, as
well as the generators found in Python. Implementing generators
&lt;i&gt;within&lt;/i&gt; a language (rather than as a built-in part of one)
requires control structures that can be exited and re-entered, and
therefore needs more flexible frames for controlling executing
code rather than conventional stack frames that are unwound
destructively on return.
&lt;/p&gt;

&lt;p&gt;
The obvious (for Lisp, anyway) next step is to make these "hairy"
control structures visible within the language, to allow them to
be re-arranged in interesting ways. It does this by exposing the
structure of frames, consisting of:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;the bound variables&lt;/li&gt;
&lt;li&gt;the state of the ongoing computation within the frame (&lt;i&gt;e.g.&lt;/i&gt;,
the program counter)&lt;/li&gt;
&lt;li&gt;a link (the &lt;code&gt;ALINK&lt;/code&gt;) to the frame within which free variables
should be looked-up&lt;/li&gt;
&lt;li&gt;a link (the &lt;code&gt;CLINK&lt;/code&gt;) to the frame to which control should return
on exit from the frame&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
This structure in turn mandates the use of &lt;b&gt;spaghetti stack&lt;/b&gt; (or
&lt;a href="https://en.wikipedia.org/wiki/Parent_pointer_tree"&gt;parent pointer trees&lt;/a&gt;) where frames are implemented using lists
that can be combined in richer ways than actual, literal stacks.
Thee are the underpinnings of several different common structures:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;generators and continuations&lt;/li&gt;
&lt;li&gt;closures&lt;/li&gt;
&lt;li&gt;non-local transfers, like &lt;code&gt;CATCH&lt;/code&gt; and &lt;code&gt;THROW&lt;/code&gt; in Common Lisp, and
therefore probably encompassing the entire condition system&lt;/li&gt;
&lt;li&gt;functions with access to extra state (as with object methods,
but in this case used as callbacks for database updates)&lt;/li&gt;
&lt;li&gt;symbolic debuggers (not mentioned in the text)&lt;/li&gt;
&lt;li&gt;lexical &lt;i&gt;versus&lt;/i&gt; dynamic variable scope (not mentioned in the
text, and I think it's a binary choice between one or the other
depending on the &lt;code&gt;ALINK&lt;/code&gt;, rather than accommodating lexical and
"special" variable classes as Common Lisp does)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
So these features are constructed in Conniver from more basic
mechanisms rather than being provided built-in. I'm fascinated by
what other structures one might build when every frame has &lt;i&gt;two&lt;/i&gt;
independent super-frames (one for variable lookup,one for control
return) instead of one, and both can be modified independently.
This is radically different to most languages in which frames are
hidden and their manipulation reserved for the compiler and
run-time: it's a set of ideas that re-surface at the object level
in metaobject protocols.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>language-reference</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/02/02/the-conniver-reference-manual/</guid><pubDate>Fri, 02 Feb 2024 12:14:30 GMT</pubDate></item><item><title>Common Lisp: the language</title><link>https://simondobson.org/2024/02/02/common-lisp-the-language/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge0d8015" class="outline-2"&gt;
&lt;h2 id="orge0d8015"&gt;Common Lisp: the language&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge0d8015"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/20/46d76e-4b50-4cf1-866c-7515d6fd427f/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Guy Steele.  &lt;i&gt;&lt;a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html"&gt;Common Lisp: The Language&lt;/a&gt;&lt;/i&gt;. Digital Press. ISBN
1-55558-041-6. 1990.
&lt;/p&gt;

&lt;p&gt;
The reference manual for Common Lisp, also &lt;a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html"&gt;available online in its
entirety&lt;/a&gt;. This is very much a reference manual and not a
tutorial, but having said that it's a lot more accessible than
many such documents.
&lt;/p&gt;

&lt;p&gt;
It's remarkable that Common Lisp's standard has been stable for
over thirty years, despite enormous advances in Lisp practices in
that time. It shows the care that went into the original
standardisation process, but also the effects of some detailed
technical choices and (especially) the use of macros in preference
to new core mechanisms.
&lt;/p&gt;

&lt;p&gt;
However, it has to be said that the standard also fixed in place
certain choices that now seem questionable. It's a matter of
opinion, of course, but personally I think the questionable set
includes at least: multiple-value returns and binds, which are
unnecessary when you can return lists and destructure them and
that impinge on the minimalism of the core language; and allowing
symbols to be bound simultaneously to values and functions, which
unnecessarily treats the two differently (and for which reason it
was removed from Scheme).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>language-reference</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/02/02/common-lisp-the-language/</guid><pubDate>Fri, 02 Feb 2024 12:10:26 GMT</pubDate></item><item><title>Structure and interpretation of computer programs</title><link>https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org0638c56" class="outline-2"&gt;
&lt;h2 id="org0638c56"&gt;Structure and interpretation of computer programs&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0638c56"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/52/6b5639-18fe-4fc6-b8b1-7c93e3011194/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Harold Abelson and Gerald Jay Sussman.  &lt;i&gt;&lt;a href="https://web.mit.edu/6.001/6.037/sicp.pdf"&gt;Structure and
Interpretation of Computer Programs&lt;/a&gt;&lt;/i&gt;. MIT Press. 1985.
&lt;/p&gt;

&lt;p&gt;
A book once described (&lt;a href="https://simondobson.org/2010/05/14/cs-book-worth-reading-twice/"&gt;by me&lt;/a&gt;, actually) as "the only computer
science book worth reading twice", and which was the foundational
text for teaching programming at MIT for decades.
&lt;/p&gt;

&lt;p&gt;
There are many reasons that this book is so popular and
long-lived. It's resolutely an introductory text, but it treats
topics that are uncommon in introductions, and does so to a depth
that's quite astonishing – although it has to be said that the
authors avoid the more complex constructions like conditions and
the complexities of macros, (They do deal with continuations,
however, which are essential for good Scheme programming.)
&lt;/p&gt;

&lt;p&gt;
But what other introduction to programming includes a complete
meta-linguistic re-implementation of the language itself? – and
in two different styles! It can do this because Scheme is so
regular and so simple – &lt;i&gt;homoiconic&lt;/i&gt; (one representation for
programs and data), (although they don't use that term).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/</guid><pubDate>Sat, 27 Jan 2024 15:46:19 GMT</pubDate></item><item><title>Learn Common Lisp in Y minutes</title><link>https://simondobson.org/2024/01/27/learn-common-lisp-in-y-minutes/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org1e4659c" class="outline-2"&gt;
&lt;h2 id="org1e4659c"&gt;Learn Common Lisp in Y minutes&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1e4659c"&gt;
&lt;p&gt;
&lt;a href="https://learnxinyminutes.com/docs/common-lisp/"&gt;https://learnxinyminutes.com/docs/common-lisp/&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A one-web-page introduction to Common Lisp covering pretty much
all the language in enough detail to at least start writing simple
command-line programs (and understanding those of others).
Includes macros and CLOS. Quite an achievement to make it all so
readable.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/01/27/learn-common-lisp-in-y-minutes/</guid><pubDate>Sat, 27 Jan 2024 14:14:35 GMT</pubDate></item><item><title>Practical Common Lisp</title><link>https://simondobson.org/2024/01/27/practical-common-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org12de14d" class="outline-2"&gt;
&lt;h2 id="org12de14d"&gt;Practical Common Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org12de14d"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/b8/4b7fa7-83e9-4756-8ede-1c3cdeaeafef/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Peter Seibel.  &lt;i&gt;&lt;a href="https://gigamonkeys.com/book/"&gt;Practical Common Lisp&lt;/a&gt;&lt;/i&gt;. Apress. ISBN
978-1-4302-0017-8. 2005.
&lt;/p&gt;

&lt;p&gt;
The classic, very thorough and hands-on tutorial introduction that
doesn't skip the hard parts like the condition system and
non-local blocks and exists (and the relationship between the
two). It's also got good chapters on CLOS.
&lt;/p&gt;

&lt;p&gt;
The text is complemented by a set of modern examples, for web
services, database, and binary file parsers: quite a long way
removed from the examples in many introductory texts. It doesn't
make much use of macro programming in these examples, which is a
shame, so follow with On Lisp or Let over Lambda once the
structure of the language is clear.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/01/27/practical-common-lisp/</guid><pubDate>Sat, 27 Jan 2024 13:15:30 GMT</pubDate></item></channel></rss>