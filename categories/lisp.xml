<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson (Posts about lisp)</title><link>https://simondobson.org/</link><description></description><atom:link href="https://simondobson.org/categories/lisp.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Wed, 06 Mar 2024 19:17:43 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Common Lisp recipes: A problem-solution approach</title><link>https://simondobson.org/2024/03/06/common-lisp-recipes-a-problem-solution-approach/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org39b5a23" class="outline-2"&gt;
&lt;h2 id="org39b5a23"&gt;Common Lisp recipes: A problem-solution approach&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org39b5a23"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/2e/6e47a1-73a8-4ac5-a703-1f6ab0a2262b/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Edmund Weitz.  &lt;i&gt;&lt;a href="https://doi.org/10.1007/978-1-4842-1176-2"&gt;Common Lisp Recipes: A Problem-Solution Approach&lt;/a&gt;&lt;/i&gt;.
Apress. 2016.
&lt;/p&gt;

&lt;p&gt;
An extensive list of recipes for using common data structures,
how the differ in Lisp from the equivalents in other languages,
and what novel features Lisp has to offer. A great place to start
when moving away from being a beginner, and for dipping into in
search of solutions.
&lt;/p&gt;

&lt;p&gt;
It's probably strongest on the "gotchas" and dangers that Lisp
presents, but also has a lot to say about coding style and code
optimisation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/06/common-lisp-recipes-a-problem-solution-approach/</guid><pubDate>Wed, 06 Mar 2024 18:55:31 GMT</pubDate></item><item><title>The Common Lisp condition system</title><link>https://simondobson.org/2024/03/06/the-common-lisp-condition-system/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org792bbd5" class="outline-2"&gt;
&lt;h2 id="org792bbd5"&gt;The Common Lisp condition system&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org792bbd5"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/06/efe121-b8ab-4558-a705-733fbbe7b1f9/978-1-4842-6134-7.webp" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Michał "phoe" Herda.  &lt;i&gt;&lt;a href="https://doi.org/10.1007/978-1-4842-6134-7"&gt;The Common Lisp Condition System&lt;/a&gt;&lt;/i&gt;. Apress. 2020.
&lt;/p&gt;

&lt;p&gt;
An enormously detailed look at the condition system, sometimes
regarded as the Lisp equivalent of exception-handling in other
languages.
&lt;/p&gt;

&lt;p&gt;
But that's massively unfair to the condition system, which is
really a way to deal with non-local transfers of control in the
most flexible way possible. Exceptions are &lt;i&gt;just one type&lt;/i&gt; of
this, and the condition system aims to separate three aspects that
are often combined in other languages: detecting and signalling a
condition, responding to a condition, and deciding on the binding
between the two, possibly combining responses differently in
different contexts. It's a set of concepts that are in many ways
foreign to a lot of other languages, and so justify the detail for
those occasions when these techniques are appropriate: deciding
&lt;i&gt;when&lt;/i&gt; they are appropriate is non-trivial, a matter of both
functionality and style.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/06/the-common-lisp-condition-system/</guid><pubDate>Wed, 06 Mar 2024 18:46:57 GMT</pubDate></item><item><title>Anatomy of Lisp</title><link>https://simondobson.org/2024/03/06/anatomy-of-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org94f3557" class="outline-2"&gt;
&lt;h2 id="org94f3557"&gt;Anatomy of Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org94f3557"&gt;
&lt;p&gt;
John Allen.  &lt;i&gt;Anatomy of Lisp&lt;/i&gt;. McGraw-Hill. ISBN
0-07-001115-X. 1978.
&lt;/p&gt;

&lt;p&gt;
This is a hard book to characterise. It's simultaneously an
introduction, a collection of advanced (for the time) programming
techniques, and a guide to some very low-level implementation
details. It contains a lot of the usual introductory material, but
then delves into different representational choices for the basic
data structures – lists, but also arrays and hash tables as well
as Lisp code itself – and for the frames needed to represent
function calls. It the tackles interpretation &lt;i&gt;versus&lt;/i&gt;
compilation, and even topics such as cross-compilation and
just-in-time or memoised compilation.
&lt;/p&gt;

&lt;p&gt;
It's impossible to read this book without thinking of &lt;a href="/2024/01/27/structure-and-interpretation-of-computer-programs/"&gt;SICP&lt;/a&gt;, and
indeed I think in many ways it's a direct precursor. (It's
referenced a couple of times in SICP.) It has that same
combination of high-level, semantics-driven programming combined
with descriptions of underlying mechanisms. Where I think it
mainly differs is that it mixes representations, using a more
semantics-driven notation and explicit assembler instructions
rather than sticking with Lisp variants for &lt;i&gt;everything&lt;/i&gt;. It's
only when you see the two approaches side by side that you realise
how &lt;i&gt;clear&lt;/i&gt; Lisp can be in radically different contexts..
&lt;/p&gt;

&lt;p&gt;
Another important book was published in 1978: Kernighan and
Ritchie's &lt;i&gt;&lt;a href="https://en.wikipedia.org/wiki/The_C_Programming_Language"&gt;The C programming language&lt;/a&gt;&lt;/i&gt;. The two books share a
certain low-level focus, but come to very different conclusions
about the correct approach to dynamic storage, as the following
footnote by Allen (slightly edited for clarity) illustrates:
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
Experiments have been performed in which Lisp programmers were
allowed to return "garbage" to the free-space list themselves. The
results were disastrous: list structure thought to be garbage was
returned to the free-space list even though the structure was
still being used by other computations.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
C, of course, accepts this "disaster" as a natural consequence of
manual allocation management. It encapsulates the different
attitudes of the two contemporary language communities, though:
one wanting a machine in which to think (and willing to use
computing power to simplify tasks), and those wanting raw
performance from limited hardware (and willing to complicate the
programming task to get it).
&lt;/p&gt;

&lt;p&gt;
Overall, Allen's book is a great attempt at an end-to-end
discussion of Lisp all the way down to the metal. Many of the
techniques are still relevant, at least as exemplars against
later, more efficient, techniques should be judged.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>implementation-techiques</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/06/anatomy-of-lisp/</guid><pubDate>Wed, 06 Mar 2024 18:38:17 GMT</pubDate></item><item><title>Trying to refute some criticisms of Lisp</title><link>https://simondobson.org/2024/02/10/some-criticisms-of-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgb91bd34" class="outline-2"&gt;
&lt;h2 id="orgb91bd34"&gt;Trying to refute some criticisms of Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb91bd34"&gt;
&lt;p&gt;
I recently had a discussion with someone on Mastodon about Lisp and
its perceived (by them) deficiencies as a language. There were some
interesting points, but I felt I had to try to refute them, at least
partially.
&lt;/p&gt;

&lt;p&gt;
I should say from the start the I'm not blind to Lisp's many
inadequacies and anachronisms, merely pointing out that it has a
context like everything else.
&lt;/p&gt;

&lt;p&gt;
There seemed to be two main issues:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Poor design decisions throughout, and especially a lack of static
typing&lt;/li&gt;
&lt;li&gt;The shadows of really early machines in &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cadr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
These points are tied together, but let's try to unpack them.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0817fac" class="outline-3"&gt;
&lt;h3 id="org0817fac"&gt;Design&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0817fac"&gt;
&lt;p&gt;
Let's start with design. Lisp is over half a century old. I'd argue
it was exceptionally well-designed – when it was designed. It
lacks most modern advances in types because … well, they didn't
exist, many of them arose as solutions to perceived problems in
Lisp (and Fortran), and many of those "solutions" still aren't
universally accepted, such as static typing itself.
&lt;/p&gt;

&lt;p&gt;
What we've actually learned is that many aspects of programming
lack any really universal solutions. If static typing were such an
obvious and unarguable route to efficiency and quality, all new
software would be being written in Haskell.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org4994c1d" class="outline-3"&gt;
&lt;h3 id="org4994c1d"&gt;Typing and features&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4994c1d"&gt;
&lt;p&gt;
And the lack of modern types isn't really as clear-cut as it
appears. The argument about the &lt;i&gt;lack&lt;/i&gt; of features in Lisp also
ignores the &lt;i&gt;presence&lt;/i&gt; of other features that are absent from
almost all other languages.
&lt;/p&gt;

&lt;p&gt;
Lisp's numeric types are surprisingly flexible. Indeed, Common Lisp
is still, in the 21st century, just about the only language in
which one can write modern crypto algorithms like Diffie-Hellman
key exchange without recourse to additional libraries, because it
has arbitrary-precision integer arithmetic built-in to the standard
operators. It also has rational numbers, so no loss of precision on
division either.
&lt;/p&gt;

&lt;p&gt;
The Common Lisp Object System (CLOS) is vastly more flexible than
&lt;i&gt;any&lt;/i&gt; modern object-oriented language. Sub-class methods can
specify their relationship with the methods they override, such as
being called after or just filtering the return values. Methods
themselves are multiple-dispatch and so can be selected based on
the types of their arguments as well as their target. The basic
mechanisms can be overridden or extended using a meta-object
protocol.
&lt;/p&gt;

&lt;p&gt;
Then there are macros. It's easy to underestimate these: after all,
C has macros, doesn't it? Well, yes – and no. A C macro is a
function from strings to strings that can do literal string
substitution of its arguments. A Lisp macro is a function from code
to code that can perform arbitrary computation. They're really not
the same things at all, and it's misleading that the same word is
used for both. (C++ templates are a closer analogy, but still
limited in comparison.)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org5e0fdee" class="outline-3"&gt;
&lt;h3 id="org5e0fdee"&gt;The persistence of hardware 1: Stupid operation names&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5e0fdee"&gt;
&lt;p&gt;
The complaints about &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are long established: they
were originally derived from &lt;a href="https://en.wikipedia.org/wiki/CAR_and_CDR"&gt;machine-language instructions on the
IBM 704&lt;/a&gt; that was used for the first Lisp implementations. They're
a terrible hold-over from that terrible decision … aren't they?
&lt;/p&gt;

&lt;p&gt;
Well, yes – and no. Of course they're terrible in one sense. But
&lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are basically nouns as far as Lisp programmers are
concerned. One could replace them with more modern usages like
&lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; (and indeed many Lisps define these using
macros).
&lt;/p&gt;

&lt;p&gt;
But it's important to remember that even "head" and "tail" are
analogies, sanctified by familiarity in the computer science
literature but still inexplicable to anyone outside. (If you doubt
that, try explaining to someone who isn't a programmer that a
shopping list has a "head" consisting of the first entry, and a
"tail" consisting of another, shorter, shopping list, is "in fact"
a recursive type, and you have to acquire each item of shopping
sequentially by working your way down the list from the head.)
&lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; are artificial nouns, and &lt;code&gt;cons&lt;/code&gt; is an artificial
verb – but really no more artificial that &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;tail&lt;/code&gt;, and
&lt;code&gt;append&lt;/code&gt;, their rough equivalents in other languages.
&lt;/p&gt;

&lt;p&gt;
One can argue that the persistence of &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; drives the
persistence of compounds like &lt;code&gt;caaddr&lt;/code&gt;. But those are unnecessary
and seldom used: barely anyone would mind if they were removed.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgc410e1a" class="outline-3"&gt;
&lt;h3 id="orgc410e1a"&gt;The persistence of hardware 2: It happens a lot&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc410e1a"&gt;
&lt;p&gt;
The suggestion that Lisp has hardware holdovers that should be
removed also neglects these holdovers in other languages.
&lt;/p&gt;

&lt;p&gt;
As an example, check the definition of &lt;code&gt;std::memcpy&lt;/code&gt; in C++. It
doesn't work with overlapping memory areas. Why is that? – why is
it so fast, but so dangerous? Does it relate to underlying machine
features, such as machine code move instructions on particular
machines with particular restrictions? Doesn't this introduce the
risk of security flaws like buffer overruns?
&lt;/p&gt;

&lt;p&gt;
Languages with more abstracted machine models don't have these
issues. I struggle to think of how one could even introduce the
&lt;i&gt;concept&lt;/i&gt; of a buffer overrun into Lisp, other than by using some
external raw-memory-access library: the language itself is immune,
as far as I know.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf8bbd7c" class="outline-3"&gt;
&lt;h3 id="orgf8bbd7c"&gt;The different choices&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf8bbd7c"&gt;
&lt;p&gt;
For the sake of argument, let's turn the argument around and ask:
give that early Lisps had proper macros, arbitrary-precision
integers, and so on, why did these features disappear from what we
now consider to be "the mainstream" of programming language design?
&lt;/p&gt;

&lt;p&gt;
Lisp's designers had a goal of building a powerful machine in which
to think: indeed, they intended it to eventually have its own
hardware designed specifically for it to run on. They therefore
didn't buy into the necessity of immediate performance, and as
their applications were largely symbolic AI they didn't need
numerical performance at all. They chose instead to create high-level
constructs even if these couldn't be compiled efficiently, and
explored using these to create more code as they identified more
and more abstract patterns whose details could be automated away.
(Paul Graham has &lt;a href="https://paulgraham.com/diff.html"&gt;a great essay&lt;/a&gt; on this.)
&lt;/p&gt;

&lt;p&gt;
Other language designers had other priorities. Often they needed to
do numerical simulation, and needed both performance and scale. So
they chose a different design pathway, emphasising efficient
compilation to the hardware they had available, and made the
compromises needed to get it. These have persisted, and that's why
we have languages with fixed-width integers scaled to fit into a
single machine register, and compilers that generate – but don't
directly execute – the code of programs, which limits our ability
to abstract and automate code generation without recourse to
complicated external tools.
&lt;/p&gt;

&lt;p&gt;
It's interesting to explore these choices. They're at one level
"just" historical: accidents that shaped the present. But at
another level they're still very much present in the hardware and
software landscape we inhabit. I think it's important that we
remind ourselves, continuously, that &lt;i&gt;much of that landscape is a
choice&lt;/i&gt;, not a given, and one we can question and change as we wish.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>programming</category><guid>https://simondobson.org/2024/02/10/some-criticisms-of-lisp/</guid><pubDate>Sat, 10 Feb 2024 17:07:48 GMT</pubDate></item><item><title>LISPcraft</title><link>https://simondobson.org/2024/02/02/lispcraft/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgc448478" class="outline-2"&gt;
&lt;h2 id="orgc448478"&gt;LISPcraft&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc448478"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/fc/8f0d76-df2a-43eb-b5ca-a79b21c2351a/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Robert Wilensky.  &lt;i&gt;LISPcraft&lt;/i&gt;. W.W. Norton. ISBN
0-393-95442-0. 1984.
&lt;/p&gt;

&lt;p&gt;
Hard to know whether to include this as an introduction or
collection of applications, since it runs all the way from basic
uses to pattern-matching and associative retrieval, by way of the
non-list data types in Lisp, and includes discussion of the symbol
table and other internals that definitely fall into the "advanced"
category.
&lt;/p&gt;

&lt;p&gt;
However, this was my second introduction to Lisp (after &lt;a href="/2024/01/27/structure-and-interpretation-of-computer-programs/"&gt;SICP&lt;/a&gt;), so
it has a fond place in my memory. The fact that it deals with
language internals isn't a bad thing, because it deals with the
basics so well. It's very much a traditional programming
introduction focusing on the "needed" parts of the language. It
pre-dates the Common Lisp standard and doesn't touch on CLOS,
which perhaps make it a less appropriate choice for newcomers
these days than &lt;a href="/2024/01/27/practical-common-lisp/"&gt;Practical Common Lisp&lt;/a&gt;.
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;
There is also a second edition. I haven't read it, but it seems that
it addresses at least the concern about being non-standard:
&lt;/p&gt;

&lt;p&gt;
Robert Wilensky.  &lt;i&gt;Common LISPcraft&lt;/i&gt;. W.W. Norton. ISBN
978-039395544-6. 1986.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/02/02/lispcraft/</guid><pubDate>Fri, 02 Feb 2024 12:23:08 GMT</pubDate></item><item><title>The CONNIVER reference manual</title><link>https://simondobson.org/2024/02/02/the-conniver-reference-manual/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgc6e0b54" class="outline-2"&gt;
&lt;h2 id="orgc6e0b54"&gt;The CONNIVER reference manual&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc6e0b54"&gt;
&lt;p&gt;
Drew McDermott and Gerald Jay Sussman.  &lt;i&gt;&lt;a href="https://dspace.mit.edu/handle/1721.1/6204"&gt;The Conniver Reference
Manual&lt;/a&gt;&lt;/i&gt;. Technical report AIM-259a. MIT AI Laboratory. 1974.
&lt;/p&gt;

&lt;p&gt;
I think Conniver may have a claim to being the most influential
language you've never heard of. It's a mostly forgotten Lisp
variant that was a laboratory for some radically different
language design ideas, and a precursor to a surprising set of
features – many of which are still uncommon in the mainstream.
&lt;/p&gt;

&lt;p&gt;
Conniver was intended to manage knowledge databases. This does
make the report slightly hard to read in places, as there are a
lot of explicit references to planning techniques wrapped-up with
language mechanisms that don't really depend on them.
&lt;/p&gt;

&lt;p&gt;
Conniver is (to the best of my knowledge) the first appearance of
&lt;b&gt;generators&lt;/b&gt; in a programming language. It is therefore a distant
precursor of all the lazy functional languages and libraries, as
well as the generators found in Python. Implementing generators
&lt;i&gt;within&lt;/i&gt; a language (rather than as a built-in part of one)
requires control structures that can be exited and re-entered, and
therefore needs more flexible frames for controlling executing
code rather than conventional stack frames that are unwound
destructively on return.
&lt;/p&gt;

&lt;p&gt;
The obvious (for Lisp, anyway) next step is to make these "hairy"
control structures visible within the language, to allow them to
be re-arranged in interesting ways. It does this by exposing the
structure of frames, consisting of:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;the bound variables&lt;/li&gt;
&lt;li&gt;the state of the ongoing computation within the frame (&lt;i&gt;e.g.&lt;/i&gt;,
the program counter)&lt;/li&gt;
&lt;li&gt;a link (the &lt;code&gt;ALINK&lt;/code&gt;) to the frame within which free variables
should be looked-up&lt;/li&gt;
&lt;li&gt;a link (the &lt;code&gt;CLINK&lt;/code&gt;) to the frame to which control should return
on exit from the frame&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
This structure in turn mandates the use of &lt;b&gt;spaghetti stack&lt;/b&gt; (or
&lt;a href="https://en.wikipedia.org/wiki/Parent_pointer_tree"&gt;parent pointer trees&lt;/a&gt;) where frames are implemented using lists
that can be combined in richer ways than actual, literal stacks.
Thee are the underpinnings of several different common structures:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;generators and continuations&lt;/li&gt;
&lt;li&gt;closures&lt;/li&gt;
&lt;li&gt;non-local transfers, like &lt;code&gt;CATCH&lt;/code&gt; and &lt;code&gt;THROW&lt;/code&gt; in Common Lisp, and
therefore probably encompassing the entire condition system&lt;/li&gt;
&lt;li&gt;functions with access to extra state (as with object methods,
but in this case used as callbacks for database updates)&lt;/li&gt;
&lt;li&gt;symbolic debuggers (not mentioned in the text)&lt;/li&gt;
&lt;li&gt;lexical &lt;i&gt;versus&lt;/i&gt; dynamic variable scope (not mentioned in the
text, and I think it's a binary choice between one or the other
depending on the &lt;code&gt;ALINK&lt;/code&gt;, rather than accommodating lexical and
"special" variable classes as Common Lisp does)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
So these features are constructed in Conniver from more basic
mechanisms rather than being provided built-in. I'm fascinated by
what other structures one might build when every frame has &lt;i&gt;two&lt;/i&gt;
independent super-frames (one for variable lookup,one for control
return) instead of one, and both can be modified independently.
This is radically different to most languages in which frames are
hidden and their manipulation reserved for the compiler and
run-time: it's a set of ideas that re-surface at the object level
in metaobject protocols.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>language-reference</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/02/02/the-conniver-reference-manual/</guid><pubDate>Fri, 02 Feb 2024 12:14:30 GMT</pubDate></item><item><title>Common Lisp: the language</title><link>https://simondobson.org/2024/02/02/common-lisp-the-language/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org4b56ae4" class="outline-2"&gt;
&lt;h2 id="org4b56ae4"&gt;Common Lisp: the language&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4b56ae4"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/20/46d76e-4b50-4cf1-866c-7515d6fd427f/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Guy Steele.  &lt;i&gt;&lt;a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html"&gt;Common Lisp: The Language&lt;/a&gt;&lt;/i&gt;. Digital Press. ISBN
1-55558-041-6. 1990.
&lt;/p&gt;

&lt;p&gt;
The reference manual for Common Lisp, also &lt;a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html"&gt;available online in its
entirety&lt;/a&gt;. This is very much a reference manual and not a
tutorial, but having said that it's a lot more accessible than
many such documents.
&lt;/p&gt;

&lt;p&gt;
It's remarkable that Common Lisp's standard has been stable for
over thirty years, despite enormous advances in Lisp practices in
that time. It shows the care that went into the original
standardisation process, but also the effects of some detailed
technical choices and (especially) the use of macros in preference
to new core mechanisms.
&lt;/p&gt;

&lt;p&gt;
However, it has to be said that the standard also fixed in place
certain choices that now seem questionable. It's a matter of
opinion, of course, but personally I think the questionable set
includes at least: multiple-value returns and binds, which are
unnecessary when you can return lists and destructure them and
that impinge on the minimalism of the core language; and allowing
symbols to be bound simultaneously to values and functions, which
unnecessarily treats the two differently (and for which reason it
was removed from Scheme).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>language-reference</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/02/02/common-lisp-the-language/</guid><pubDate>Fri, 02 Feb 2024 12:10:26 GMT</pubDate></item><item><title>Structure and interpretation of computer programs</title><link>https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org22cf69e" class="outline-2"&gt;
&lt;h2 id="org22cf69e"&gt;Structure and interpretation of computer programs&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org22cf69e"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/52/6b5639-18fe-4fc6-b8b1-7c93e3011194/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Harold Abelson and Gerald Jay Sussman.  &lt;i&gt;&lt;a href="https://web.mit.edu/6.001/6.037/sicp.pdf"&gt;Structure and
Interpretation of Computer Programs&lt;/a&gt;&lt;/i&gt;. MIT Press. 1985.
&lt;/p&gt;

&lt;p&gt;
A book once described (&lt;a href="https://simondobson.org/2010/05/14/cs-book-worth-reading-twice/"&gt;by me&lt;/a&gt;, actually) as "the only computer
science book worth reading twice", and which was the foundational
text for teaching programming at MIT for decades.
&lt;/p&gt;

&lt;p&gt;
There are many reasons that this book is so popular and
long-lived. It's resolutely an introductory text, but it treats
topics that are uncommon in introductions, and does so to a depth
that's quite astonishing – although it has to be said that the
authors avoid the more complex constructions like conditions and
the complexities of macros, (They do deal with continuations,
however, which are essential for good Scheme programming.)
&lt;/p&gt;

&lt;p&gt;
But what other introduction to programming includes a complete
meta-linguistic re-implementation of the language itself? – and
in two different styles! It can do this because Scheme is so
regular and so simple – &lt;i&gt;homoiconic&lt;/i&gt; (one representation for
programs and data), (although they don't use that term).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/</guid><pubDate>Sat, 27 Jan 2024 15:46:19 GMT</pubDate></item><item><title>Learn Common Lisp in Y minutes</title><link>https://simondobson.org/2024/01/27/learn-common-lisp-in-y-minutes/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgb7db32b" class="outline-2"&gt;
&lt;h2 id="orgb7db32b"&gt;Learn Common Lisp in Y minutes&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb7db32b"&gt;
&lt;p&gt;
&lt;a href="https://learnxinyminutes.com/docs/common-lisp/"&gt;https://learnxinyminutes.com/docs/common-lisp/&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A one-web-page introduction to Common Lisp covering pretty much
all the language in enough detail to at least start writing simple
command-line programs (and understanding those of others).
Includes macros and CLOS. Quite an achievement to make it all so
readable.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/01/27/learn-common-lisp-in-y-minutes/</guid><pubDate>Sat, 27 Jan 2024 14:14:35 GMT</pubDate></item><item><title>Locally overriding a function throughout a dynamic extent</title><link>https://simondobson.org/2024/01/22/locally-overriding-a-function-throughout-a-dynamic-extent/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org5e8a8e5" class="outline-2"&gt;
&lt;h2 id="org5e8a8e5"&gt;Locally overriding a function throughout a dynamic extent&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5e8a8e5"&gt;
&lt;p&gt;
A horribly dangerous but occasionally useful Lisp technique.
&lt;/p&gt;

&lt;p&gt;
My use case is as follows. &lt;code&gt;ebib&lt;/code&gt; has a command to copy a
formatted reference to the kill ring, using
&lt;code&gt;citar-citeproc-format-reference&lt;/code&gt; to actually do the formatting.
This means it's easy to change the style of the formatted
reference. However, &lt;code&gt;citar-citeproc-format-reference&lt;/code&gt;  itself uses
&lt;code&gt;citar-render-bib&lt;/code&gt; with a plain-text formatter. This is a sensible
default, but since I'm almost always copying references into
org-more documents, it loses a lot of information: it'd be better
to use the org formatter, but there's no argument to specify it.
&lt;/p&gt;

&lt;p&gt;
Clearly the correct solution is to change
&lt;code&gt;citar-citeproc-format-reference&lt;/code&gt; to take a key or optional
argument to specify the formatter, but that involves changing
someone else's code. The hacker solution is to change the call
&lt;code&gt;(citeproc-render-bib proc 'plain)&lt;/code&gt; to &lt;code&gt;(citeproc-render-bib proc
  'org)&lt;/code&gt;, but without re-writing the entire surrounding function to
keep the change just to the case where I need it.
&lt;/p&gt;

&lt;p&gt;
One way to do this would be to define a variant
&lt;code&gt;citeproc-render-bib&lt;/code&gt; that ignores its second argument (the
formatter) and always uses &lt;code&gt;'org&lt;/code&gt; instead, and then substitute
this variant for the original – but &lt;i&gt;only&lt;/i&gt; in the dynamic extent
of a &lt;i&gt;particular&lt;/i&gt; call to &lt;code&gt;citar-citeproc-format-reference&lt;/code&gt;. In
most languages this would be impossible – but not in Emacs Lisp.
&lt;/p&gt;

&lt;p&gt;
The solution is to use &lt;code&gt;cl-letf&lt;/code&gt;, which overrides the values of
general places for the duration of its body forms and restores the
original value on exit (normal or otherwise). The important point
is that the change occurs across the &lt;i&gt;extent&lt;/i&gt; of the body – the
body and all the code called from the body – and not merely in
the &lt;i&gt;scope&lt;/i&gt; of the body, which would only affect calls made there
directly.
&lt;/p&gt;

&lt;p&gt;
For example, consider in the following:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defun&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Which when called gives:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
36
&lt;/pre&gt;


&lt;p&gt;
If we want to override the default value (10) that's passed to &lt;code&gt;f&lt;/code&gt;
and instead use 25, we can define a new version that ignores the
second argument and uses our preferred default, and then
temporarily override the definition of &lt;code&gt;f&lt;/code&gt; in the calling
environment. If we want to use the original in the overriding
definition we need to grab it first. This gives:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cl-letf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;				    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
51
&lt;/pre&gt;


&lt;p&gt;
What's going on? The &lt;code&gt;cl-letf&lt;/code&gt; macro is like &lt;code&gt;let&lt;/code&gt; but works with
general places (as in &lt;code&gt;setf&lt;/code&gt;). It sets the places in its argument
list for the duration of its body, and then restores them on exit,
regardless of whether that exit is normal or &lt;i&gt;via&lt;/i&gt; a condition.
&lt;/p&gt;

&lt;p&gt;
The &lt;code&gt;(symbol-function 'f)&lt;/code&gt; form returns the place that stores the
function associated with symbol &lt;code&gt;f&lt;/code&gt;. We use it twice: once to
capture this function so we can use it later, and once to identify
the place where we store our new variant function. This new binding
is then used for all calls made from the body of the &lt;code&gt;cl-letf&lt;/code&gt;,
regardless of depth, so the call to &lt;code&gt;first&lt;/code&gt; makes use of our variant
definition of &lt;code&gt;f&lt;/code&gt; rather than the original – but with the original
then being used in the variant in our case!
&lt;/p&gt;

&lt;p&gt;
If we'd used &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;cl-flet&lt;/code&gt; instead of &lt;code&gt;cl-letf&lt;/code&gt; we wouldn't
have got the behaviour we're looking for:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;'f&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cl-flet&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;	      &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;origf&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;first&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
36
&lt;/pre&gt;


&lt;p&gt;
Why? Because &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;cl-flet&lt;/code&gt; work over the &lt;i&gt;scope&lt;/i&gt; of the body,
so only calls to &lt;code&gt;f&lt;/code&gt; directly from the body of the assignment are
affected – not calls from calls. This is a great illustration of
the difference between the closely-related concepts of (static,
lexical) scope and (dynamic, run-time) extent, incidentally.
&lt;/p&gt;

&lt;p&gt;
I did say it was horrible :-). It's basically like adding
temporary &lt;code&gt;:around&lt;/code&gt; advice, and could probably benefit from a
macro to wrap it up. It's also inconceivable that it's thread- or
co-routine-safe, although I haven't checked.
&lt;/p&gt;

&lt;p&gt;
Part of the horribleness comes from the fact that the redefinition
is made for the entire dynamic extent of the body forms, which
means &lt;i&gt;all&lt;/i&gt; instances of the overridden function will use the
overridden value. There might be more than you think! But for
well-understood code it's sometimes useful, avoiding duplicating
code to make tiny changes.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>emacs</category><category>lisp</category><category>programming</category><guid>https://simondobson.org/2024/01/22/locally-overriding-a-function-throughout-a-dynamic-extent/</guid><pubDate>Mon, 22 Jan 2024 10:34:45 GMT</pubDate></item></channel></rss>