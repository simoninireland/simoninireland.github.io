<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson (Posts about lisp)</title><link>https://simondobson.org/</link><description></description><atom:link href="https://simondobson.org/categories/lisp.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Fri, 14 Jun 2024 13:28:39 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Lisp macros versus Rust macros</title><link>https://simondobson.org/2024/06/14/lisp-macros-versus-rust-macros/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgb0dcbd6" class="outline-2"&gt;
&lt;h2 id="orgb0dcbd6"&gt;Lisp macros &lt;i&gt;versus&lt;/i&gt; Rust macros&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb0dcbd6"&gt;
&lt;p&gt;
I was talking with one of my colleagues the other day about
programming languages, and we ended up comparing macros in Rust and
Lisp.
&lt;/p&gt;

&lt;p&gt;
Rust has a couple of &lt;a href="https://doc.rust-lang.org/reference/procedural-macros.html"&gt;couple of different kinds&lt;/a&gt; of macros:
&lt;b&gt;declarative&lt;/b&gt; macros that pattern-match on arguments to emit code; and
&lt;b&gt;procedural&lt;/b&gt; macros that perform more general code-to-code
transformations. Lisp has only one kind that operates from code to
code.
&lt;/p&gt;

&lt;p&gt;
Both approaches are &lt;i&gt;far&lt;/i&gt; more powerful than the macros in C and C++,
which are basically just string expanders. Indeed, one definition of
macroprogramming is that it's writing code that returns code, and
there's a reasonable argument that C's "macros" are programs that
return &lt;i&gt;strings&lt;/i&gt; and therefore aren't macros at all. But that's just
bring pedantic.
&lt;/p&gt;

&lt;p&gt;
The Rust operations seem quite awkward, at least from a Lisp
perspective. They're invoked in a way that's syntactically different
to ordinary code, so it's always possible to see in the source code
where procedural code generation is occurring. Perhaps that's not an
entirely bad thing, as it makes it obvious when compile-time
computation occurs – although one might also argue that a true
language extension or DSL should be so seamless that you don't &lt;i&gt;need&lt;/i&gt;
to see it.
&lt;/p&gt;

&lt;p&gt;
I think a more basic difference is in how Rust needs to handle
code-type arguments. A macro is a function from code to code, so it
needs to represent its code arguments in a way that the macros
(which is also code) can manipulate. Lisp's &lt;a href="https://en.wikipedia.org/wiki/Homoiconicity"&gt;homoiconicity&lt;/a&gt; makes this
trivial: code is a list, just like non-code, and can ba manipulated
as such. Rust doesn't have this, so code needs to be passed to
macros as a token stream that's been parsed from the program text.
That's a reasonable solution to the problem, but it does mean that
to write macros you need to understand how Rust is tokenised. You
also get a token stream, not an abstract syntax tree (AST), which
means that manipulating complex code is more difficult: essentially
you need to re-create as much of the AST as you need and traverse it
within the macro body. There's a standard library that does this for
Rust's own syntax, which simplifies matters somewhat but still means
that writing macros exposes the programmer to the underlying
representations. Hopefully they won't change, as that would break a
lot of macros.
&lt;/p&gt;

&lt;p&gt;
By contrast, Lisp macros only require an understanding of Lisp
itself, not of its internals, and can operate on the entire detailed
structure of the code arguments. It's a striking example of the
power of homoiconicity.
&lt;/p&gt;

&lt;p&gt;
An approach closer to that of Rust is also available, in Common Lisp
anyway, in the form of &lt;b&gt;reader macros&lt;/b&gt; that modify the Lisp reader to
allow access to the character stream as the source code is being
read. I think I've only ever encountered read macros for providing
new styles of literals, or variants of strings that benefit from
being treated slightly differently at read-time: they're an unusual
use case, anyway, and Lisp makes the more usual case of macros
manipulating Lisp code a lot simpler, without exposing the
programmer to parsing.
&lt;/p&gt;

&lt;p&gt;
I suspect the main difference between the two languages' approaches
is that macros are &lt;b&gt;additional&lt;/b&gt; to Rust but &lt;b&gt;inherent&lt;/b&gt; to Lisp. None of
the core of Rust uses macros: they're for extensions. By contrast,
even common operations like &lt;code&gt;defun&lt;/code&gt; in Lisp are actually macros that
expand to the simpler core operations. This perhaps explains the
Rust designers' decision to make macros syntactically distinct.
&lt;/p&gt;

&lt;dl class="org-dl"&gt;
&lt;dt&gt;tags&lt;/dt&gt;&lt;dd&gt;&lt;a href="https://simondobson.org/2024/06/14/lisp-macros-versus-rust-macros/personal/notebook/lisp.html#ID-7240ed21-61a0-493f-8799-87aaabc6e09d"&gt;lisp&lt;/a&gt; &lt;a href="https://simondobson.org/2024/06/14/lisp-macros-versus-rust-macros/personal/notebook/programming.html#ID-a09035c3-bbf7-4664-af41-2c2d0864ae6a"&gt;programming&lt;/a&gt; &lt;a href="https://simondobson.org/2024/06/14/lisp-macros-versus-rust-macros/personal/notebook/rust.html#ID-0d8ccbf1-1fec-4cf0-b0ce-bff5d214098a"&gt;rust&lt;/a&gt; &lt;a href="https://simondobson.org/2024/06/14/lisp-macros-versus-rust-macros/personal/notebook/macroprogramming.html#ID-185b94cf-fb44-4feb-9c06-86eea9a972da"&gt;macroprogramming&lt;/a&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>macroprogramming</category><category>programming</category><category>rust</category><guid>https://simondobson.org/2024/06/14/lisp-macros-versus-rust-macros/</guid><pubDate>Fri, 14 Jun 2024 13:23:46 GMT</pubDate></item><item><title>Pascal Costanza's highly opinionated guide to Lisp</title><link>https://simondobson.org/2024/05/27/pascal-costanza1s-highly-opinionated-guide-to-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org9a991ba" class="outline-2"&gt;
&lt;h2 id="org9a991ba"&gt;Pascal Costanza's highly opinionated guide to Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9a991ba"&gt;
&lt;p&gt;
&lt;a href="https://www.p-cos.net/lisp/guide.html"&gt;Pascal Costanza's Highly Opinionated Guide to Lisp&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Part introduction, part paean to the language's power, part study
guide, while dipping into an eclectically-chosen subset of Lisp
features that really illustrate what makes it different.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>experience</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/05/27/pascal-costanza1s-highly-opinionated-guide-to-lisp/</guid><pubDate>Mon, 27 May 2024 16:04:50 GMT</pubDate></item><item><title>A road to Common Lisp</title><link>https://simondobson.org/2024/05/27/a-road-to-common-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orga7343e8" class="outline-2"&gt;
&lt;h2 id="orga7343e8"&gt;A road to Common Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga7343e8"&gt;
&lt;p&gt;
&lt;a href="https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/"&gt;A Road to Common Lisp&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
This a really brief, yet really interesting, approach to
introducing Lisp to someone. Interesting because it covers all the
usual ground, but also has copious pointers to other material
slightly-beyond-introductory ("Where to go from here"). It also
links to material that's essential to modern practice, such as
Lisp packages and systems, and the essential "standard libraries"
such as Alexandria, Bordeaux, CL-PPCRE, usocket, and the like: the
things that are needed in practice and which in other languages
would probably be built-in and included directly in an
introduction.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/05/27/a-road-to-common-lisp/</guid><pubDate>Mon, 27 May 2024 16:00:55 GMT</pubDate></item><item><title>TIL: The loudest Lisp program in the world</title><link>https://simondobson.org/2024/05/03/til-the-loudest-lisp-program-in-the-world/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org69b2fff" class="outline-2"&gt;
&lt;h2 id="org69b2fff"&gt;TIL: The loudest Lisp program in the world&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org69b2fff"&gt;
&lt;p&gt;
Today I learned about a program that generates the sounds that help
people navigate as they exit long tunnels when an emergency such as
a fire has destroyed the visibility.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://blog.funcall.org//lisp%20psychoacoustics/2024/05/01/worlds-loudest-lisp-program/"&gt;The World's Loudest Lisp Program to the Rescue&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
This describes the challenges of building a software system that has
to work unmonitored once deployed, for years, as well as
withstanding a fairly rugged environment where, for example, the
installedc hardware will be periodically sprayed with a
high-pressure hose as the walls get cleaned. Overall the system is
soft real-time, but has to cope with component failure, network
partitions, consensus, and all the usual distributed systems
challenges, while be guaranteed to work when needed.
&lt;/p&gt;

&lt;p&gt;
The developers built the system in Common Lisp, which wouldn't be
the normal go-to choice for an embedded system. But their argument
was that they could better handle complex and changing requirements
by retaining a high level of abstraction, and that development was
overall far faster than using C. Modern Common Lisp compilers are so
efficient that there's no significant performance hit at deployment.
They made use of complicated components like planners (for which
Lisp is an ideal choice), and built a set of macros to wrap-up the
handling of industrial control and robust communications.
&lt;/p&gt;

&lt;p&gt;
It's a great read.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>programming</category><category>til</category><guid>https://simondobson.org/2024/05/03/til-the-loudest-lisp-program-in-the-world/</guid><pubDate>Fri, 03 May 2024 08:50:16 GMT</pubDate></item><item><title>Loving Common Lisp, or the savvy programmer's secret weapon</title><link>https://simondobson.org/2024/04/02/loving-common-lisp-or-the-savvy-programmers-secret-weapon/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org1b914c8" class="outline-2"&gt;
&lt;h2 id="org1b914c8"&gt;Loving Common Lisp, or the savvy programmer's secret weapon&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1b914c8"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/7a/bd1498-3024-4f11-91a7-97f3e99084d7/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Mark Watson.  &lt;i&gt;&lt;a href="https://leanpub.com/lovinglisp"&gt;Loving Common Lisp, or the Savvy Programmer’s Secret
Weapon&lt;/a&gt;&lt;/i&gt;. Leanpub. 2023.
&lt;/p&gt;

&lt;p&gt;
While pitched as a way of sharing the author's enthusiasm for Lisp
(which really shines through), this book is really a deep
demonstration in using Lisp in modern applications – from web
APIs and the semantic web to deep learning, large language models,
and chatbots.
&lt;/p&gt;

&lt;p&gt;
In some ways, like many other Lisp books, it's really two books in
one. The first chapters are introductory – and to be perfectly
honest could be dispensed with, as they're inadequate as a proper
introduction and there are far better introductions out there. The
later chapters focus on applications, and provide the real value.
One could criticise them as often tying-together tools in other
languages, with the Lisp code basically being glue; but that's a
very effective way of leveraging all the code and services out
there, and is an important technique for Lisp programmers too.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>applications</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/04/02/loving-common-lisp-or-the-savvy-programmers-secret-weapon/</guid><pubDate>Tue, 02 Apr 2024 15:57:38 GMT</pubDate></item><item><title>Lisp in space</title><link>https://simondobson.org/2024/04/02/lisp-in-space/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org5458425" class="outline-2"&gt;
&lt;h2 id="org5458425"&gt;Lisp in space&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5458425"&gt;
&lt;p&gt;
&lt;a href="https://corecursive.com/lisp-in-space-with-ron-garret/"&gt;Lisp in space&lt;/a&gt; (podcast, 38 minutes)
&lt;/p&gt;

&lt;p&gt;
An interview on the Corecursive podcast with Ron Garret.
&lt;/p&gt;

&lt;p&gt;
In 1988 (when, for context, I was in the second year of my BSc)
Garret started working on autonomous navigation software for
&lt;a href="https://en.wikipedia.org/wiki/Sojourner_(rover)"&gt;Sojourner&lt;/a&gt;, NASA's first Mars rover, which flew in 1997. He used Lisp
to do planning, essentially developing an entire domain-specific
language for autonomous vehicles. The project was never flown, as
NASA opted for a far less ambitious approach to driving to rovers –
a decision that Garret now considers to have been the correct one.
&lt;/p&gt;

&lt;p&gt;
But that isn't the end of the story, because Garret then went on
to develop an autonomous Remote Agent controller for the &lt;a href="https://en.wikipedia.org/wiki/Deep_Space_1"&gt;Deep
Space 1&lt;/a&gt; technology demonstration mission that performed asteroid
and comet fly-bys. Without spoiling to story, the spacecraft flies
with a full Lisp system onboard, and Garret gets to interact with
its REPL at a distance of 30 light-minutes &lt;i&gt;via&lt;/i&gt; the Deep Space
Network – surely the longest latency of any REPL session ever!
&lt;/p&gt;

&lt;p&gt;
It's an fascinating insight into both the potentials of Lisp and
the political difficulties that using a non-standard development
language can engender.
&lt;/p&gt;

&lt;p&gt;
UPDATE 2024-05-16: Ron also wrote a &lt;a href="https://flownet.com/gat/jpl-lisp.html"&gt;short essay&lt;/a&gt; about his
experiences.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>applications</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/04/02/lisp-in-space/</guid><pubDate>Tue, 02 Apr 2024 15:32:56 GMT</pubDate></item><item><title>Lisp hackers: Interviews with 100x more productive programmers</title><link>https://simondobson.org/2024/03/23/lisp-hackers-interviews-with-100x-more-productive-programmers/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgd65153e" class="outline-2"&gt;
&lt;h2 id="orgd65153e"&gt;Lisp hackers: Interviews with 100x more productive programmers&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd65153e"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/4f/11131f-cfc4-4d14-8fae-72c78607964b/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Vsevolod Dyomkin.  &lt;i&gt;&lt;a href="https://leanpub.com/lisphackers"&gt;Lisp Hackers: Interviews with 100x More Productive
Programmers&lt;/a&gt;&lt;/i&gt;. Leanpub. 2013.
&lt;/p&gt;

&lt;p&gt;
I'm not convinced by the sub-title: at the very least, there's no
evidence to support the claim that Lisp programmers really are
hundreds of time more productive. But there are some serious
insights here from individuals who've made serious contributions
to the Lisp world – and beyond. The contributions all take the
form of email interviews consisting of a standard prelude of
questions (how did you discover Lisp?, do you use it at work?)
followed by a couple of questions tailored to the interviewee.
&lt;/p&gt;

&lt;p&gt;
The practitioners selected have all been affected by Lisp, either
in terms of it changing their own thought processes, or by helping
to develop the core ecosystem, or by applying Lisp to real-world
problems, and often to great effect. My favourite was the
discussion with someone who was using Common Lisp to develop
low-latency network routing for financial services: it's hard
to think of a better example of Lisp's power and range.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>experience</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/23/lisp-hackers-interviews-with-100x-more-productive-programmers/</guid><pubDate>Sat, 23 Mar 2024 14:57:08 GMT</pubDate></item><item><title>My Lisp experiences and the development of GNU Emacs</title><link>https://simondobson.org/2024/03/23/my-lisp-experiences-and-the-development-of-gnu-emacs/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgc8bb5fb" class="outline-2"&gt;
&lt;h2 id="orgc8bb5fb"&gt;My Lisp experiences and the development of GNU Emacs&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc8bb5fb"&gt;
&lt;p&gt;
&lt;a href="https://www.gnu.org/gnu/rms-lisp.html"&gt;My Lisp Experiences and the Development of GNU Emacs&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
The never-dull Richard Stallman talks about his experiences with
Lisp and with the development of Emacs. It's got some useful
observations on &lt;i&gt;why&lt;/i&gt; Lisp became the core of Emacs: it was news to
me that this hadn't always been the case. It started with an
"editor control" language in the spirit of editors like &lt;code&gt;ed&lt;/code&gt;. But as
people wanted more support from their editor, they wanted to
program it more effectively.
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
The language that you build your extensions on shouldn't be
thought of as a programming language in afterthought; it should be
designed as a programming language. In fact, we discovered that
the best programming language for that purpose was Lisp.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
The result was a re-write of Emacs in C (for portability), with a
Lisp interpreter specialised towards editing tasks.
&lt;/p&gt;

&lt;p&gt;
He then gives an insider's perspective on the Lisp machines and
their evolution, as well as revealing the genesis of his ideas for
the free software movement. While these are interesting to read,
it should be noted that much of it has been rebutted: his
description of the formation and later history of the two
spin-outs, Symbolics and Lisp Machines Inc, is strongly disputed
by Dan Weinreb on &lt;a href="https://web.archive.org/web/20090101103828/http://danweinreb.org/blog/rebuttal-to-stallmans-story-about-the-formation-of-symbolics-and-lmi"&gt;his blog&lt;/a&gt;.)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>experience</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/23/my-lisp-experiences-and-the-development-of-gnu-emacs/</guid><pubDate>Sat, 23 Mar 2024 14:55:26 GMT</pubDate></item><item><title>How Lisp is designing nanotechnology</title><link>https://simondobson.org/2024/03/15/how-lisp-is-designing-nanotechnology/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgfc2e383" class="outline-2"&gt;
&lt;h2 id="orgfc2e383"&gt;How Lisp is designing nanotechnology&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfc2e383"&gt;
&lt;p&gt;
&lt;a href="https://www.youtube.com/watch?v=fytGL8vzGeQ"&gt;How Lisp is designing nanotechnology&lt;/a&gt; (video, 52 minutes).
&lt;/p&gt;

&lt;p&gt;
An interview on the &lt;a href="https://www.youtube.com/@DeveloperVoices"&gt;Developer Voices&lt;/a&gt; podcast with &lt;a href="https://www.schafmeistergroup.com/"&gt;Prof Christian
Schafmeister&lt;/a&gt; on designing enzymes using a custom dialect of Lisp
to control computational chemistry libraries.
&lt;/p&gt;

&lt;p&gt;
He initially started from an idea based on CAD applications
(written in Smalltalk), but rapidly realised there were too many
possible components and combinations to work with graphically and
so started treating it as a language-design problem – and
designed a custom Lisp based on &lt;a href="https://ecl.common-lisp.dev/"&gt;ECL&lt;/a&gt;. Lisp provides simplicity and
efficiency, as well as being a "forever" language in which
software keeps working over the long term.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>applications</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/15/how-lisp-is-designing-nanotechnology/</guid><pubDate>Fri, 15 Mar 2024 19:19:15 GMT</pubDate></item><item><title>A micro-manual for Lisp: Not the whole truth</title><link>https://simondobson.org/2024/03/15/a-micro-manual-for-lisp-not-the-whole-truth/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org68fffef" class="outline-2"&gt;
&lt;h2 id="org68fffef"&gt;A micro-manual for Lisp: Not the whole truth&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org68fffef"&gt;
&lt;p&gt;
John McCarthy.  &lt;i&gt;&lt;a href="https://doi.org/10.1145/960118.808386"&gt;A Micro-Manual for Lisp: Not the Whole Truth&lt;/a&gt;&lt;/i&gt;. ACM
SIGPLAN Notices &lt;b&gt;13&lt;/b&gt;, pp.215–216. 1978.
&lt;/p&gt;

&lt;p&gt;
A "manual" in the sense of providing a complete implementation of
Lisp – in Lisp itself.
&lt;/p&gt;

&lt;p&gt;
Is that useful? A semantics expert would say "no", since such a
model has no real explanatory power: the recursion doesn't
bottom-out to define the concepts. However, a programming language
expert might disagree and observe that this is &lt;i&gt;meta-linguistic
abstraction&lt;/i&gt;, the use of one high-level language to capture the
definition of another. The "host" language provides a higher level
of abstraction than is usual when writing interpreters and
compilers, so it becomes easier to experiment with different forms
of "target" language as there's less low-level work to do. This
benefit exists even when host and target are the same: essentially
the target is bootstrapped and can then be adjusted while running
within an earlier version of itself.
&lt;/p&gt;

&lt;p&gt;
As far as I know this is the first example of meta-linguistic
abstraction in the computer science literature. The idea was
popularised by &lt;a href="/2024/01/27/structure-and-interpretation-of-computer-programs/"&gt;SICP&lt;/a&gt; (using Scheme), and forms the basis for a lot
of modern bootstrapped compilers.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/15/a-micro-manual-for-lisp-not-the-whole-truth/</guid><pubDate>Fri, 15 Mar 2024 17:25:10 GMT</pubDate></item></channel></rss>