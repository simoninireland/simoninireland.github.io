<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson (Posts about lisp)</title><link>https://simondobson.org/</link><description></description><atom:link href="https://simondobson.org/categories/lisp.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2025 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Wed, 26 Nov 2025 10:11:28 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Lisp from nothing</title><link>https://simondobson.org/2025/11/26/lisp-from-nothing/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgb3d1ff4" class="outline-2"&gt;
&lt;h2 id="orgb3d1ff4"&gt;Lisp from nothing&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb3d1ff4"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/c8/94f691-a88c-44ba-8366-02aa08aad82b/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Nils Holm.  &lt;i&gt;Lisp from Nothing&lt;/i&gt;. Lulu Press. 2025.
&lt;/p&gt;

&lt;p&gt;
This is a fascinating book that's very old-school – and I mean
that in the best possible way. It does exactly what it says:
develops a Lisp interpreter (and then a compiler) from first
principles, bootstrapped on top of an existing Lisp or Scheme
against a runtime written in C, with all code provided.
&lt;/p&gt;

&lt;p&gt;
It's more than this, though. There's a thorough discussion of the
differences between dynamic and lexical variable scope (and the
implications for both programming and implementation). There's a
digression into pure lambda calculus and the complexities that &lt;i&gt;it&lt;/i&gt;
introduces. There's a basic mark/sweep garbage collector. There's
a brief history of Lisp and Lisp machines. And there's a
performance evaluation that digs into where the costs lie within
the system.
&lt;/p&gt;

&lt;p&gt;
Overall this is a book that every implementor should read, if only
to see some other parts of the possible design space for Lisp
tooling. Many applications will want to occupy a different point
in that space, for example providing a richer compiler, or a
richer runtime. But there's a lot to learn from the simplicity of
the choices made here.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>implementation-techniques</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2025/11/26/lisp-from-nothing/</guid><pubDate>Wed, 26 Nov 2025 10:06:12 GMT</pubDate></item><item><title>Early LISP history 1956--1959</title><link>https://simondobson.org/2025/11/07/early-lisp-history-11956-19591/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgbb236cc" class="outline-2"&gt;
&lt;h2 id="orgbb236cc"&gt;Early LISP history (1956–1959)&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbb236cc"&gt;
&lt;p&gt;
Herbert Stoyan.  &lt;i&gt;&lt;a href="https://doi.org/10.1145/800055.802047"&gt;Early Lisp History (1956–1959)&lt;/a&gt;&lt;/i&gt;. In &lt;i&gt;LFP ’84:
Proceedings of the 1984 ACM Symposium on Lisp and Functional
Programming&lt;/i&gt;, pp.299–310. 1984.
&lt;/p&gt;

&lt;p&gt;
A study of Lisp's evolution from first proposal to practical
implementation.
&lt;/p&gt;

&lt;p&gt;
It begins with McCarthy's proposal (co-authored with Marvin
Minsky, Nathaniel Rochester, and Claude Shannon, and dated 31
August 1955) for a summer research project at Dartmouth College to
"study the relationship of language to intelligence".
&lt;/p&gt;

&lt;p&gt;
In a later (handwritten!) note McCarthy homed-in on the core
challenges in this programme: the lack of a clear way to describe
&lt;i&gt;procedures&lt;/i&gt; to each other (what &lt;a href="https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/"&gt;Abelson and Sussman&lt;/a&gt; later refer to
as &lt;i&gt;procedural epistemology&lt;/i&gt;), and the tight binding of programming
systems at that time to specific machines, and hence their need to
bow to engineering (rather than semantic) considerations. The
language that became Lisp sought primarily to overcome these two
challenges.
&lt;/p&gt;

&lt;p&gt;
The journey proceeded by taking the list data structures developed
by Allen Newell and Herb Simon as part of &lt;a href="https://en.wikipedia.org/wiki/Logic_Theorist"&gt;Logic Theorist&lt;/a&gt; and
embedding them into FORTRAN (for which there was already a working
compiler) – which also incidentally muddied the conceptual waters
by trying to express list and list-functional concepts in a
language built around numbers that barely allowed functions to be
defined by the user at all. Indeed, McCarthy and others had
long-running problems accepting that the list-processing functions
&lt;i&gt;were&lt;/i&gt; functions, given that their result does not depend solely on
their arguments when viewed at the lowest level. This shows how
pernicious a low-level implementation can be. The final resulting
language, the FORTRAN List Processing Language (FLPL), shared many
programming approaches function names with what became Lisp.
&lt;/p&gt;

&lt;p&gt;
McCarthy went on to champion the functional approach, including
the invention of conditional expressions (alongside or replacing
conditional statements) and the power of the different kinds of
function composition and higher-order functions. It's important to
remember that McCarthy's driving interest remained in AI, not
programming languages &lt;i&gt;per se&lt;/i&gt;:
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
Already in 1956 it was clear that one had to work with symbolic
expressions to reach the goal of artificial intelligence.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
Which is a fascinating piece of history in itself, as a large
branch of modern AI concerning machine learning and large language
models has explicit rejects this view in favour of sub-symbolic
AI. Which approach is "correct" in whatever sense remains to be
seen.
&lt;/p&gt;

&lt;p&gt;
But it remains McCarthy's contributions to programming languages
that stand out. As well as conditional expressions he can be
credited with garbage collection, meta-circular interpretation,
and clarifying the relationship between programming and proof:
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
We should mention here that McCarthy at the same time conceived the
idea of logic-oriented programming, that is, the idea of using logical
formulae to express goals that a program should try to establish and
of using the prover as programming language interpreter.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
(Although it's important to recognise that Newell and Simon's
work, on logic as an application rather than as a general
programming language, pre-dates McCarthy's.)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2025/11/07/early-lisp-history-11956-19591/</guid><pubDate>Fri, 07 Nov 2025 09:44:35 GMT</pubDate></item><item><title>The history of Lisp</title><link>https://simondobson.org/2025/11/07/the-history-of-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org67a97ae" class="outline-2"&gt;
&lt;h2 id="org67a97ae"&gt;The history of Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org67a97ae"&gt;
&lt;p&gt;
Herbert Stoyan.  &lt;i&gt;&lt;a href="https://www.softwarepreservation.org/projects/LISP/book/Stoyan-Geschichte.pdf"&gt;The History of Lisp&lt;/a&gt;&lt;/i&gt;. 1980. Updated in the 1990s,
translated into English 2023.
&lt;/p&gt;

&lt;p&gt;
Includes a history of the route from PLANNER to CONNIVER, in which
the former was criticised for being a theorem prover when a
programming language was needed – an argument between two schools
that's still going on today, as seen in the emergence of &lt;a href="https://lean-lang.org/"&gt;Lean&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2025/11/07/the-history-of-lisp/</guid><pubDate>Fri, 07 Nov 2025 08:49:57 GMT</pubDate></item><item><title>History of Lisp</title><link>https://simondobson.org/2025/11/07/history-of-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgd92a09b" class="outline-2"&gt;
&lt;h2 id="orgd92a09b"&gt;History of Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd92a09b"&gt;
&lt;p&gt;
John McCarthy.  &lt;i&gt;&lt;a href="https://www-formal.stanford.edu/jmc/history/lisp/lisp.html"&gt;History of Lisp&lt;/a&gt;&lt;/i&gt;. Artificial Intelligence
Laboratory, Stanford University. 1979.
&lt;/p&gt;

&lt;p&gt;
McCarthy's own take on the early history. It's quite brief, but is
very careful to give broad credit to the others who were involved
in the practical creation of the language.
&lt;/p&gt;

&lt;p&gt;
It's also got some great vignettes on &lt;i&gt;why&lt;/i&gt; certain features came
about - for example garbage collection coming from the need to
clean up intermediate structures when experimenting with symbolic
differentiation. McCarthy acknowledges taking the notation for
functions from Church, before admitting that he didn't understand
the rest of &lt;i&gt;Calculi of lambda conversion&lt;/i&gt; and so wasn't tempted to
add the more general aspects!
&lt;/p&gt;

&lt;p&gt;
Perhaps the most fascinating part of the story is that it was
originally so divorced from actual computers. The team had defined
an &lt;code&gt;eval&lt;/code&gt; function for interpreting Lisp programs – in the process
making the decision to represent the programs as lists – before
realising that this could be made interactive to provide a running
interpreter.
&lt;/p&gt;

&lt;p&gt;
What did McCarthy think of his creation? He was conscious that it
would have a lifetime:
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
LISP will become obsolete when someone makes a more comprehensive
language that dominates LISP practically and also gives a clear
mathematical semantics to a more comprehensive set of features.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
Haskell has a plausible claim to have accomplished the latter but
this doesn't seem to have led domination in practice.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>history</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2025/11/07/history-of-lisp/</guid><pubDate>Fri, 07 Nov 2025 08:47:09 GMT</pubDate></item><item><title>Tutorial on good Lisp programming style</title><link>https://simondobson.org/2025/01/31/tutorial-on-good-lisp-programming-style/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org5e8f4b3" class="outline-2"&gt;
&lt;h2 id="org5e8f4b3"&gt;Tutorial on good Lisp programming style&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5e8f4b3"&gt;
&lt;p&gt;
&lt;a href="https://www.cs.umd.edu/%7Enau/cmsc421/norvig-lisp-style.pdf"&gt;https://www.cs.umd.edu/%7Enau/cmsc421/norvig-lisp-style.pdf&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;i&gt;Expression + Understanding = Communication&lt;/i&gt;
&lt;/p&gt;

&lt;p&gt;
A great discussion of &lt;i&gt;style&lt;/i&gt;, perhaps the most elusive programming
skill. Illustrated across all the levels of abstraction that one
finds in Lisp: of data, functions, control, and syntax (the last
being essentially unique to Lisp macros). The discussion of
control abstraction deals extensively with catch/throw and other
primitives in the condition system that are dealt with at greater
length in &lt;a href="/2024/03/06/the-common-lisp-condition-system/"&gt;The Common Lisp condition system&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
The extended example (starting on page 71) of how to simplify
logical expressions is amazingly clear, and really shows the
progression from simple functions to embedded languages targeting
specific tasks and making them easy to describe and extend to new
applications: something that lies at the heart of the Lisp
experience.
&lt;/p&gt;

&lt;p&gt;
Much of the advice is actually language-agnostic, even though the
concrete examples are in Lisp. Norvig, of course, is the author of
&lt;a href="/2024/03/07/paradigms-of-artificial-intelligence-programming-case-studies-in-common-lisp/"&gt;Paradigms of artificial intelligence programming&lt;/a&gt;, and has made
enormous contributions to the theory and practice of Lisp.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>style-guide</category><guid>https://simondobson.org/2025/01/31/tutorial-on-good-lisp-programming-style/</guid><pubDate>Fri, 31 Jan 2025 09:21:02 GMT</pubDate></item><item><title>Lisp: Style and design</title><link>https://simondobson.org/2025/01/31/lisp-style-and-design/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org07a794e" class="outline-2"&gt;
&lt;h2 id="org07a794e"&gt;Lisp: Style and design&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org07a794e"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/da/4751c9-60cc-4acc-bfd3-ad7d50aa536a/lisp-style-design.jpg" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Molly Miller and Eric Benson. &lt;i&gt;Lisp: Style and Design&lt;/i&gt;. Digital Press.
ISBN 978-0135384220. 1990.
&lt;/p&gt;

&lt;p&gt;
A book that would serve as a primer for someone tackling a
significant piece of programming for the first time.
&lt;/p&gt;

&lt;p&gt;
The style is a bit stiff and occasionally slightly patronising,
definitely positioned as being from senior to junior programmers.
The depth of the material is variable: I found the treatment of
macros quite superficial, not helped by the examples generating
questionable code. It also places relatively little emphasis on
CLOS and generic functions, which would get more space in a more
modern treatment..
&lt;/p&gt;

&lt;p&gt;
The best chapters are those on debugging and (especially)
performance engineering, which dig into the interactive tools
generally available within Lisp and give a good end-to-end
description of the use of &lt;code&gt;declare&lt;/code&gt; forms to aid compiler
optimisations.
&lt;/p&gt;

&lt;p&gt;
But again the book's age shows. It predates the obsessive
relationship that many modern programmers have with unit testing
and test automation, treating testing as an interactive activity
alongside debugging rather than as a core and permanent part of
program development and maintenance.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>style-guide</category><guid>https://simondobson.org/2025/01/31/lisp-style-and-design/</guid><pubDate>Fri, 31 Jan 2025 08:27:35 GMT</pubDate></item><item><title>Lisp as a second language</title><link>https://simondobson.org/2024/11/29/lisp-as-a-second-language/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org0e5ab39" class="outline-2"&gt;
&lt;h2 id="org0e5ab39"&gt;Lisp as a second language&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0e5ab39"&gt;
&lt;p&gt;
Peter Desain.  &lt;i&gt;&lt;a href="https://hdl.handle.net/2066/74778"&gt;Lisp as a Second Language: Functional Aspects&lt;/a&gt;&lt;/i&gt;.
Perspectives on New Music &lt;b&gt;20&lt;/b&gt;, pp.192–222. 1990.
&lt;/p&gt;

&lt;p&gt;
In some ways this article should come under "applications", as
it's mainly concerned with using Lisp to represent and manipulate
music. Indeed, it presents a system that can be used to perform
all sorts of common transformations of the tones and timing of a
piece. It's easy to see how the resulting system could be used to
compose and then to drive instruments, for example through a MIDI
interface.
&lt;/p&gt;

&lt;p&gt;
The music perspective is however secondary to the goal of teaching
and showcasing Lisp through the medium of a realistic example of
symbolic programming. It covers a lot of ground, starting with
lists and functions and including first-class functions and
combinators as means of implementing the musical structures. It's
a great piece of pedagogy that treats the application and the
language as closely linked, and not shying-away from some quite
advanced techniques that have clear applications in the domain. It
would be great to see this used as a basis for actual musical
composition and performance.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>lisp</category><category>project:lisp-bibliography</category><category>tutorial</category><guid>https://simondobson.org/2024/11/29/lisp-as-a-second-language/</guid><pubDate>Fri, 29 Nov 2024 15:01:40 GMT</pubDate></item><item><title>Two Lisp compilers written in Lisp</title><link>https://simondobson.org/2024/10/18/two-lisp-compilers-written-in-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org1478a92" class="outline-2"&gt;
&lt;h2 id="org1478a92"&gt;Two Lisp compilers written in Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1478a92"&gt;
&lt;p&gt;
&lt;a href="http://www.ulisp.com/show?4W2I"&gt;A Lisp compiler to ARM written in Lisp&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;a href="http://www.ulisp.com/show?4Y20="&gt;A Lisp compiler to RISC-V written in Lisp&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Two native-code compilers written in the &lt;a href="http://www.ulisp.com/show?3J"&gt;uLisp&lt;/a&gt; dialect that targets
microcontroller-class machines. Both use a combination of stack
and register allocation to get efficiency – and they're &lt;i&gt;very&lt;/i&gt;
efficient, with the compiled versions sometimes being 100x faster
than the interpreted code.
&lt;/p&gt;

&lt;p&gt;
These are not complete ports, and indeed not on a complete or
standard underlying Lisp implementation. But it's still fascinating
to see how &lt;i&gt;simple&lt;/i&gt; it is, built as a recursive-descent tree-walker
that emits assembler directly. With careful initial design even a
compiler with no optimisation pathways can still get great speed-up
over an interpreter.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>implementation-techniques</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/10/18/two-lisp-compilers-written-in-lisp/</guid><pubDate>Fri, 18 Oct 2024 09:24:36 GMT</pubDate></item><item><title>The different energy footprints of different programming languages</title><link>https://simondobson.org/2024/09/27/the-different-energy-footprints-of-different-programming-languages/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgb8af6ca" class="outline-2"&gt;
&lt;h2 id="orgb8af6ca"&gt;The different energy footprints of different programming languages&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb8af6ca"&gt;
&lt;p&gt;
I've recently been thinking about low-power computing, from AI and
data centres down to sensors, as part of a new initiative the
University is considering. It's easy to forget the resource
footprint of our computing systems – especially those that are "out
of sight, out of mind" in the cloud – but there's growing evidence
that their growth threatens the renewable energy transition. Some of
the figures for AI electricity and water usage are astonishing.
&lt;/p&gt;

&lt;p&gt;
One aspect of this is the effect of choice of programming language.
I can across some work from 2017 on this:
&lt;/p&gt;

&lt;p&gt;
Rui Pereira, Marco Couto, Francisco Ribeiro, Rui Rua, Cunha Jácome,
João Paulo Fernandes, and João Saraiva. &lt;i&gt;&lt;a href="https://doi.org/10.1145/3136014.3136031"&gt;Energy Efficiency across
Programming Languages: How Do Energy, Time, and Memory Relate?&lt;/a&gt;&lt;/i&gt; In
&lt;i&gt;Proceedings of the 10th ACM SIGPLAN International Conference on
Software Language Engineering&lt;/i&gt;. 2017.
&lt;/p&gt;

&lt;p&gt;
The authors compare 13 benchmarks run in 27 different languages,
with the benchmarks being chosen widely to avoid being biased by
numeric performance. I was expecting some patterns: compiled
languages doing better on performance, memory, and energy usage, for
example. But I wasn't expecting exactly &lt;i&gt;how&lt;/i&gt; widely the figures
diverged, or some of the details.
&lt;/p&gt;

&lt;p&gt;
The following table is from the paper, annotated by me. The figures
are normalised against the best result in each category (so the top
language has value 1, and so on).
&lt;/p&gt;

&lt;p width="80%" align="center"&gt;
&lt;img src="https://simondobson.org/attachments/fb/debea0-0913-41c2-90bc-726153de8d28/pl-energy.png" alt="pl-energy.png"&gt;
&lt;/p&gt;

&lt;p&gt;
The two most-used languages for web application, Python and
JavaScript, perform uniformly pretty badly: 75 times C's energy
usage, in Python's case. But although JavaScript does substantially
better on energy (only a factor of 4), TypeScript – which is
usually thought of as JavaScript with type pre-processing –
requires 21 times C's energy, or 5 times JavaScript's. Why is that?
– I can't think of a reason.
&lt;/p&gt;

&lt;p&gt;
But the real surprise was that "research" languages like Haskell and
Lisp both hold up well: twice C's energy, in Lisp's case. I don't
think that would surprise modern Lisp programmers, who are used to
their compilers' efficiencies – but it would surprise someone used
only to the "hearsay" about Lisp. The same for Haskell, actually,
whose modern compilers really leverage the extra structure. When you
consider that both those languages are pretty much dependent on
garbage collection and so are doing substantially &lt;i&gt;more&lt;/i&gt; work than the
equivalent C program, it's impressive.
&lt;/p&gt;

&lt;p&gt;
(Also look in the table for Racket, consistently lower than Lisp
despite their close similarities. I suspect this is a compiler
optimisation issue more than anything else.)
&lt;/p&gt;

&lt;p&gt;
This work clearly isn't complete or definitive. Clojure is entirely
missing, as is Scala, and there will have been compiler improvements
since 2017 for the languages with the most active developer
communities. But it's still quite sobering that the differences are
&lt;i&gt;so&lt;/i&gt; wide, and that we've chosen to push languages that exacerbate
energy usage rather than managing it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>haskell</category><category>javascript</category><category>lisp</category><category>low power</category><category>programming</category><category>python</category><guid>https://simondobson.org/2024/09/27/the-different-energy-footprints-of-different-programming-languages/</guid><pubDate>Fri, 27 Sep 2024 15:15:23 GMT</pubDate></item><item><title>Purely functional data structures</title><link>https://simondobson.org/2024/09/27/purely-functional-data-structures/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orge75e26b" class="outline-2"&gt;
&lt;h2 id="orge75e26b"&gt;Purely functional data structures&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge75e26b"&gt;
&lt;p&gt;
Chris Okasaki. &lt;i&gt;Purely Functional Data Structures&lt;/i&gt;. Cambridge
University Press. ISBN 978-051153-010-4. 1998.
&lt;/p&gt;

&lt;p&gt;
Not a Lisp book &lt;i&gt;per se&lt;/i&gt;, but a treatment of data structures from a
functional programming perspective. The code examples are in
Standard ML, but the ideas apply strongly to Lisp and Scheme.
Definitely a useful source for an alternative take on data
structuring that doesn't start from assumptions of imperative
programming and mutability.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/09/27/purely-functional-data-structures/</guid><pubDate>Fri, 27 Sep 2024 15:12:14 GMT</pubDate></item></channel></rss>