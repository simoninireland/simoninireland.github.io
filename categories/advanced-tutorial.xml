<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson (Posts about advanced-tutorial)</title><link>https://simondobson.org/</link><description></description><atom:link href="https://simondobson.org/categories/advanced-tutorial.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Sun, 10 Mar 2024 10:24:55 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Paradigms of artificial intelligence programming: Case studies in Common Lisp</title><link>https://simondobson.org/2024/03/07/paradigms-of-artificial-intelligence-programming-case-studies-in-common-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgc0f48ab" class="outline-2"&gt;
&lt;h2 id="orgc0f48ab"&gt;Paradigms of artificial intelligence programming: Case studies in Common Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgc0f48ab"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/55/a8fc4d-075e-4914-90ea-c2bcc0021821/screenshot.png" alt="nil"&gt;
&lt;/p&gt;


&lt;p&gt;
Peter Norvig.  &lt;i&gt;&lt;a href="https://norvig.github.io/paip-lisp/"&gt;Paradigms of Artificial Intelligence Programming:
Case Studies in Common Lisp&lt;/a&gt;&lt;/i&gt;. Morgan Kaufmann. 1992.
&lt;/p&gt;

&lt;p&gt;
An absolute classic of both AI and Lisp, and really two books in
one. The applications presented cover the entire range of
"classic" AI up to the late 90s: expert systems, logic
programming, symbolic mathematics, knowledge representation,
constraint programming, game search, syntax-driven natural
language processing, and more.
&lt;/p&gt;

&lt;p&gt;
It uses Lisp as the programming vehicle, and doesn't shy-away from
depth, dealing with the effects of garbage collection (and how to
program effectively in its presence), the effects of different
representations, low-level optimisation and disassembly, and all
the approaches one needs to use Lisp in real, scalable practice.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/07/paradigms-of-artificial-intelligence-programming-case-studies-in-common-lisp/</guid><pubDate>Thu, 07 Mar 2024 19:07:31 GMT</pubDate></item><item><title>Common Lisp recipes: A problem-solution approach</title><link>https://simondobson.org/2024/03/06/common-lisp-recipes-a-problem-solution-approach/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org39b5a23" class="outline-2"&gt;
&lt;h2 id="org39b5a23"&gt;Common Lisp recipes: A problem-solution approach&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org39b5a23"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/2e/6e47a1-73a8-4ac5-a703-1f6ab0a2262b/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Edmund Weitz.  &lt;i&gt;&lt;a href="https://doi.org/10.1007/978-1-4842-1176-2"&gt;Common Lisp Recipes: A Problem-Solution Approach&lt;/a&gt;&lt;/i&gt;.
Apress. 2016.
&lt;/p&gt;

&lt;p&gt;
An extensive list of recipes for using common data structures,
how the differ in Lisp from the equivalents in other languages,
and what novel features Lisp has to offer. A great place to start
when moving away from being a beginner, and for dipping into in
search of solutions.
&lt;/p&gt;

&lt;p&gt;
It's probably strongest on the "gotchas" and dangers that Lisp
presents, but also has a lot to say about coding style and code
optimisation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/06/common-lisp-recipes-a-problem-solution-approach/</guid><pubDate>Wed, 06 Mar 2024 18:55:31 GMT</pubDate></item><item><title>The Common Lisp condition system</title><link>https://simondobson.org/2024/03/06/the-common-lisp-condition-system/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org792bbd5" class="outline-2"&gt;
&lt;h2 id="org792bbd5"&gt;The Common Lisp condition system&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org792bbd5"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/06/efe121-b8ab-4558-a705-733fbbe7b1f9/978-1-4842-6134-7.webp" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Michał "phoe" Herda.  &lt;i&gt;&lt;a href="https://doi.org/10.1007/978-1-4842-6134-7"&gt;The Common Lisp Condition System&lt;/a&gt;&lt;/i&gt;. Apress. 2020.
&lt;/p&gt;

&lt;p&gt;
An enormously detailed look at the condition system, sometimes
regarded as the Lisp equivalent of exception-handling in other
languages.
&lt;/p&gt;

&lt;p&gt;
But that's massively unfair to the condition system, which is
really a way to deal with non-local transfers of control in the
most flexible way possible. Exceptions are &lt;i&gt;just one type&lt;/i&gt; of
this, and the condition system aims to separate three aspects that
are often combined in other languages: detecting and signalling a
condition, responding to a condition, and deciding on the binding
between the two, possibly combining responses differently in
different contexts. It's a set of concepts that are in many ways
foreign to a lot of other languages, and so justify the detail for
those occasions when these techniques are appropriate: deciding
&lt;i&gt;when&lt;/i&gt; they are appropriate is non-trivial, a matter of both
functionality and style.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/06/the-common-lisp-condition-system/</guid><pubDate>Wed, 06 Mar 2024 18:46:57 GMT</pubDate></item><item><title>Structure and interpretation of computer programs</title><link>https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org22cf69e" class="outline-2"&gt;
&lt;h2 id="org22cf69e"&gt;Structure and interpretation of computer programs&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org22cf69e"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/52/6b5639-18fe-4fc6-b8b1-7c93e3011194/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Harold Abelson and Gerald Jay Sussman.  &lt;i&gt;&lt;a href="https://web.mit.edu/6.001/6.037/sicp.pdf"&gt;Structure and
Interpretation of Computer Programs&lt;/a&gt;&lt;/i&gt;. MIT Press. 1985.
&lt;/p&gt;

&lt;p&gt;
A book once described (&lt;a href="https://simondobson.org/2010/05/14/cs-book-worth-reading-twice/"&gt;by me&lt;/a&gt;, actually) as "the only computer
science book worth reading twice", and which was the foundational
text for teaching programming at MIT for decades.
&lt;/p&gt;

&lt;p&gt;
There are many reasons that this book is so popular and
long-lived. It's resolutely an introductory text, but it treats
topics that are uncommon in introductions, and does so to a depth
that's quite astonishing – although it has to be said that the
authors avoid the more complex constructions like conditions and
the complexities of macros, (They do deal with continuations,
however, which are essential for good Scheme programming.)
&lt;/p&gt;

&lt;p&gt;
But what other introduction to programming includes a complete
meta-linguistic re-implementation of the language itself? – and
in two different styles! It can do this because Scheme is so
regular and so simple – &lt;i&gt;homoiconic&lt;/i&gt; (one representation for
programs and data), (although they don't use that term).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/</guid><pubDate>Sat, 27 Jan 2024 15:46:19 GMT</pubDate></item></channel></rss>