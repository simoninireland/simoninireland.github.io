<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Simon Dobson (Posts about advanced-tutorial)</title><link>https://simondobson.org/</link><description></description><atom:link href="https://simondobson.org/categories/advanced-tutorial.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:simoninireland@gmail.com"&gt;Simon Dobson&lt;/a&gt; </copyright><lastBuildDate>Mon, 26 Aug 2024 16:33:15 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Let over Lambda</title><link>https://simondobson.org/2024/07/05/let-over-lambda/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orged90f8a" class="outline-2"&gt;
&lt;h2 id="orged90f8a"&gt;Let over Lambda&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orged90f8a"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/4d/e4b9aa-2377-42e7-a3e1-aa66a129c7ee/lol.jpg" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Doug Hoyte.  &lt;i&gt;&lt;a href="http://letoverlambda.com"&gt;Let over Lambda&lt;/a&gt;&lt;/i&gt;. HCSW and Hoytech. ISBN
978-1-4357-1275-1. 2008.
&lt;/p&gt;

&lt;p&gt;
A gloriously opinionated (in the best way) take on Lisp macro
programming. The author treats Lisp – one of the first languages
– as the ultimate, &lt;i&gt;final&lt;/i&gt; language to which all others can (and
should) be translated, since they're simply special cases of Lisp
forms. And he makes a surprisingly compelling case.
&lt;/p&gt;

&lt;p&gt;
The material builds extensively on &lt;a href="/2024/07/05/on-lisp/"&gt;On Lisp&lt;/a&gt;, re-presenting the
idea of &lt;i&gt;anaphoric&lt;/i&gt; macros (those that bind lexical variables for
use in their bodies) and extending them with &lt;i&gt;pandoric&lt;/i&gt; macros
that allow introspection into an otherwise closed lexical
environment. A lot of these examples feel contrived as presented,
but the techniques are anything but: powerful ways to build
abstractions.
&lt;/p&gt;

&lt;p&gt;
The finale is the implementation of Forth in Lisp, and then a
reflection to allow Forth programs to define Lisp functions –
converting a (transparent) threaded-interpreted structure into an
(opaque) code block. It's a slightly non-standard Forth, but it's
true to the basics and exposes issues like the implementations of
interpretation, compilation, and tail recursion really well. It's
only another step to explore Lisp &lt;i&gt;implemented&lt;/i&gt; in Forth through
the medium of macro programming, which deserves a book itself.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/05/let-over-lambda/</guid><pubDate>Fri, 05 Jul 2024 10:19:07 GMT</pubDate></item><item><title>On Lisp</title><link>https://simondobson.org/2024/07/05/on-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgaac5f5f" class="outline-2"&gt;
&lt;h2 id="orgaac5f5f"&gt;On Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgaac5f5f"&gt;
&lt;p&gt;
Paul Graham.  &lt;i&gt;&lt;a href="http://www.paulgraham.com/onlisp.html"&gt;On Lisp: Advanced Techniques for Common Lisp&lt;/a&gt;&lt;/i&gt;. Prentice
Hall. ISBN 0-13-030552-9. 1993.
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
An ideal world is left as an exercise to the reader.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;
One of the most famous advanced treatments of Lisp. Essentially
it's a book in two parts. The first deals with the traditional
advanced topics of functional programming such as identifying
patterns that can be factored-out into higher-order functions and
re-used. But the second, better-known, part deals with macro
programming in extraordinary detail and with enormous creativity,
including developing macros for continuations and several embedded
languages.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/05/on-lisp/</guid><pubDate>Fri, 05 Jul 2024 10:16:34 GMT</pubDate></item><item><title>Debugging Lisp</title><link>https://simondobson.org/2024/07/05/debugging-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgb9a4deb" class="outline-2"&gt;
&lt;h2 id="orgb9a4deb"&gt;Debugging Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb9a4deb"&gt;
&lt;p&gt;
&lt;a href="https://malisper.me/debugging-lisp-part-1-recompilation/"&gt;Debugging Lisp&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A four-part blog post series on debugging Lisp, covering:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Live recompilation of code from inside a debugging session,
together with re-executing changed code from within a running
stack trace&lt;/li&gt;
&lt;li&gt;Inspecting objects and interacting with traces of function calls&lt;/li&gt;
&lt;li&gt;Redefining classes, and how to ensure that existing instances
are upgraded to be compatible with the new definition&lt;/li&gt;
&lt;li&gt;Restarts, the neglected part of the condition system that
controls how programs continue after encountering errors&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;
The first two are essential, and show how &lt;i&gt;different&lt;/i&gt; Lisp
programming is from using other languages. In fact it requires a
considerable mental shift to re-acquire the right reflexes for
dealing with errors and debugging in a fully interactive
environment: well, it did for me, anyway. We're not used to
interactivity in large development environments. There is seldom
any need to close down a running Lisp session and start again, as
everything can usually be changed and adapted within a session.
This is very unlike the usual compile-edit-debug cycles we've
become accustomed to.
&lt;/p&gt;

&lt;p&gt;
The third post – on redefining classes – shows how one can
upgrade a program that simply &lt;i&gt;has&lt;/i&gt; to keep running, because its
live state upgrade can be programmed too.
&lt;/p&gt;

&lt;p&gt;
The most significant part of the mental shift is to realise that
the debugger is written in Lisp itself, and makes use of restarts
and other features to provide the interface. This is a consequence
of the degree of exposure of the Lisp run-time structures into to
language itself, where they can be examined and manipulated using
the full power of the language – and then be re-started or
discarded as required.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/07/05/debugging-lisp/</guid><pubDate>Fri, 05 Jul 2024 10:14:22 GMT</pubDate></item><item><title>Paradigms of artificial intelligence programming: Case studies in Common Lisp</title><link>https://simondobson.org/2024/03/07/paradigms-of-artificial-intelligence-programming-case-studies-in-common-lisp/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgaea97c7" class="outline-2"&gt;
&lt;h2 id="orgaea97c7"&gt;Paradigms of artificial intelligence programming: Case studies in Common Lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgaea97c7"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/55/a8fc4d-075e-4914-90ea-c2bcc0021821/screenshot.png" alt="nil"&gt;
&lt;/p&gt;


&lt;p&gt;
Peter Norvig.  &lt;i&gt;&lt;a href="https://norvig.github.io/paip-lisp/"&gt;Paradigms of Artificial Intelligence Programming:
Case Studies in Common Lisp&lt;/a&gt;&lt;/i&gt;. Morgan Kaufmann. 1992.
&lt;/p&gt;

&lt;p&gt;
An absolute classic of both AI and Lisp, and really two books in
one. The applications presented cover the entire range of
"classic" AI up to the late 90s: expert systems, logic
programming, symbolic mathematics, knowledge representation,
constraint programming, game search, syntax-driven natural
language processing, and more.
&lt;/p&gt;

&lt;p&gt;
It uses Lisp as the programming vehicle, and doesn't shy-away from
depth, dealing with the effects of garbage collection (and how to
program effectively in its presence), the effects of different
representations, low-level optimisation and disassembly, and all
the approaches one needs to use Lisp in real, scalable practice.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/07/paradigms-of-artificial-intelligence-programming-case-studies-in-common-lisp/</guid><pubDate>Thu, 07 Mar 2024 19:07:31 GMT</pubDate></item><item><title>Common Lisp recipes: A problem-solution approach</title><link>https://simondobson.org/2024/03/06/common-lisp-recipes-a-problem-solution-approach/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org8757d38" class="outline-2"&gt;
&lt;h2 id="org8757d38"&gt;Common Lisp recipes: A problem-solution approach&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8757d38"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/2e/6e47a1-73a8-4ac5-a703-1f6ab0a2262b/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Edmund Weitz.  &lt;i&gt;&lt;a href="https://doi.org/10.1007/978-1-4842-1176-2"&gt;Common Lisp Recipes: A Problem-Solution Approach&lt;/a&gt;&lt;/i&gt;.
Apress. 2016.
&lt;/p&gt;

&lt;p&gt;
An extensive list of recipes for using common data structures,
how the differ in Lisp from the equivalents in other languages,
and what novel features Lisp has to offer. A great place to start
when moving away from being a beginner, and for dipping into in
search of solutions.
&lt;/p&gt;

&lt;p&gt;
It's probably strongest on the "gotchas" and dangers that Lisp
presents, but also has a lot to say about coding style and code
optimisation.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/06/common-lisp-recipes-a-problem-solution-approach/</guid><pubDate>Wed, 06 Mar 2024 18:55:31 GMT</pubDate></item><item><title>The Common Lisp condition system</title><link>https://simondobson.org/2024/03/06/the-common-lisp-condition-system/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-org3832c73" class="outline-2"&gt;
&lt;h2 id="org3832c73"&gt;The Common Lisp condition system&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3832c73"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/06/efe121-b8ab-4558-a705-733fbbe7b1f9/978-1-4842-6134-7.webp" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Michał "phoe" Herda.  &lt;i&gt;&lt;a href="https://doi.org/10.1007/978-1-4842-6134-7"&gt;The Common Lisp Condition System&lt;/a&gt;&lt;/i&gt;. Apress. 2020.
&lt;/p&gt;

&lt;p&gt;
An enormously detailed look at the condition system, sometimes
regarded as the Lisp equivalent of exception-handling in other
languages.
&lt;/p&gt;

&lt;p&gt;
But that's massively unfair to the condition system, which is
really a way to deal with non-local transfers of control in the
most flexible way possible. Exceptions are &lt;i&gt;just one type&lt;/i&gt; of
this, and the condition system aims to separate three aspects that
are often combined in other languages: detecting and signalling a
condition, responding to a condition, and deciding on the binding
between the two, possibly combining responses differently in
different contexts. It's a set of concepts that are in many ways
foreign to a lot of other languages, and so justify the detail for
those occasions when these techniques are appropriate: deciding
&lt;i&gt;when&lt;/i&gt; they are appropriate is non-trivial, a matter of both
functionality and style.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/03/06/the-common-lisp-condition-system/</guid><pubDate>Wed, 06 Mar 2024 18:46:57 GMT</pubDate></item><item><title>Structure and interpretation of computer programs</title><link>https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/</link><dc:creator>Simon Dobson</dc:creator><description>&lt;div id="outline-container-orgea92793" class="outline-2"&gt;
&lt;h2 id="orgea92793"&gt;Structure and interpretation of computer programs&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgea92793"&gt;
&lt;p class="floater"&gt;
&lt;img src="https://simondobson.org/attachments/52/6b5639-18fe-4fc6-b8b1-7c93e3011194/screenshot.png" alt="nil"&gt;
&lt;/p&gt;

&lt;p&gt;
Harold Abelson and Gerald Jay Sussman.  &lt;i&gt;&lt;a href="https://web.mit.edu/6.001/6.037/sicp.pdf"&gt;Structure and
Interpretation of Computer Programs&lt;/a&gt;&lt;/i&gt;. MIT Press. 1985.
&lt;/p&gt;

&lt;p&gt;
A book once described (&lt;a href="https://simondobson.org/2010/05/14/cs-book-worth-reading-twice/"&gt;by me&lt;/a&gt;, actually) as "the only computer
science book worth reading twice", and which was the foundational
text for teaching programming at MIT for decades.
&lt;/p&gt;

&lt;p&gt;
There are many reasons that this book is so popular and
long-lived. It's resolutely an introductory text, but it treats
topics that are uncommon in introductions, and does so to a depth
that's quite astonishing – although it has to be said that the
authors avoid the more complex constructions like conditions and
the complexities of macros, (They do deal with continuations,
however, which are essential for good Scheme programming.)
&lt;/p&gt;

&lt;p&gt;
But what other introduction to programming includes a complete
meta-linguistic re-implementation of the language itself? – and
in two different styles! It can do this because Scheme is so
regular and so simple – &lt;i&gt;homoiconic&lt;/i&gt; (one representation for
programs and data), (although they don't use that term).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>advanced-tutorial</category><category>lisp</category><category>project:lisp-bibliography</category><guid>https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/</guid><pubDate>Sat, 27 Jan 2024 15:46:19 GMT</pubDate></item></channel></rss>